<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++学习笔记</title>
    <url>/2024/01/03/C++%E5%AD%A6%E4%B9%A0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/ClaireSy/article/details/120155878">黑马——C++基础入门</a></p>
<p><a href="https://blog.csdn.net/ClaireSy/article/details/108423047">黑马——C++核心编程</a></p>
<p><a href="https://blog.csdn.net/ClaireSy/article/details/108423061">黑马——C++提高编程</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>list.remove()函数删除结构体结点</title>
    <url>/2022/06/27/C++%E5%AD%A6%E4%B9%A0/list.remove()%E5%87%BD%E6%95%B0%E5%88%A0%E9%99%A4%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%93%E7%82%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>使用stl中list的list.remove()函数删除结构体结点时，会遇到&#x3D;&#x3D;的运算符重载问题，解决方法如下：</p>
<ul>
<li>结构体定义内容：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">msg</span></span><br><span class="line">&#123;</span><br><span class="line">  string studentNumber;</span><br><span class="line">  string studentName;</span><br><span class="line">  <span class="type">int</span> gradeChinese, gradeMath, gradeEnglish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x3D;&#x3D;运算符重载实现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> CInfoFile::msg&amp; msg1, <span class="type">const</span> CInfoFile::msg&amp; msg2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (msg1.studentNumber == msg2.studentNumber 					              		  &amp;&amp;msg1.studentName==msg2.studentName</span><br><span class="line">	  &amp;&amp;msg1.gradeChinese==msg2.gradeChinese</span><br><span class="line">      &amp;&amp;msg1.gradeEnglish==msg2.gradeEnglish</span><br><span class="line">      &amp;&amp;msg1.gradeMath==msg2.gradeMath)</span><br><span class="line">  flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>define或typedef遇到模板</title>
    <url>/2022/04/21/C++%E5%AD%A6%E4%B9%A0/%E5%BD%93define%E6%88%96%E8%80%85typedef%E9%81%87%E5%88%B0%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">NODE</span></span><br><span class="line">&#123;</span><br><span class="line">	T data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">NODE</span> *next;</span><br><span class="line">&#125; LinkList;</span><br></pre></td></tr></table></figure>

<p>这里的代码会报错，因为define和typedef不允许定义模糊的类型，如果要使用，一定要显式指明数据类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NODE</span></span><br><span class="line">&#123;</span><br><span class="line">	T data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">NODE</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> NODE&lt;<span class="type">int</span>&gt; LinkList;</span><br></pre></td></tr></table></figure>

<p>上面为正确的用法，并且对于typedef必须定义在模板结构的下面。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>STL学习总结</title>
    <url>/2022/12/30/C++%E5%AD%A6%E4%B9%A0/STL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h1><h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>string是C++风格的字符串，本质上是一个类。其内部封装了char*。</p>
</li>
<li><p>成员函数主要有find，copy，delete，replace，insert</p>
</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li><p><code>string();</code>&#x2F;&#x2F;生成空string</p>
</li>
<li><p><code>string(const char* s);</code>&#x2F;&#x2F;以字符串s初始化</p>
</li>
<li><p><code>string(const string&amp; str);</code>&#x2F;&#x2F;以string对象初始化另一个string对象</p>
</li>
<li><p><code>string(int n, char c);</code>&#x2F;&#x2F;以n个字符c初始化</p>
</li>
</ul>
<h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><ul>
<li><p><code>string&amp; operator=(const char* s);</code></p>
</li>
<li><p><code>string&amp; operator=(const string &amp;s);</code></p>
</li>
<li><p><code>string&amp; operator=(char c);</code></p>
</li>
<li><p><code>string&amp; assign(const char *s)</code></p>
</li>
<li><p><code>string&amp; assign(const char *s, int n)</code></p>
</li>
<li><p><code>string&amp; assign(const string &amp;s)</code></p>
</li>
<li><p><code>string&amp; assign(int n, char c);</code></p>
</li>
</ul>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><ul>
<li><p><code>string&amp; operator+=(const char* str);</code></p>
</li>
<li><p><code>string&amp; operator+=(const char c);</code></p>
</li>
<li><p><code>string&amp; operator+=(const string&amp; str);</code></p>
</li>
<li><p><code>string&amp; append(const char* s)</code></p>
</li>
<li><p><code>string&amp; append(const char* s,int n);</code></p>
</li>
<li><p><code>string&amp; append(const string&amp; str);</code></p>
</li>
<li><p><code>string&amp; append(const string &amp;s,int pos,int n);</code>&#x2F;&#x2F;字符串s中从pos开始的n个字符连接到字符串结尾</p>
</li>
</ul>
<h3 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h3><ul>
<li><p><code>int find(const string&amp; str, int pos = 0) const;</code>&#x2F;&#x2F;从pos开始查找str出现的第一次位置</p>
</li>
<li><p><code>int find(const char* s,int pos = 0) const</code>&#x2F;&#x2F;从pos开始查找s出现的第一次位置</p>
</li>
<li><p><code>int fing(const char* s, int pos, int n) const;</code>&#x2F;&#x2F;从pos开始查找s的前n个字符出现的第一次位置</p>
</li>
<li><p><code>int find(const char c,int pos = 0) const</code>&#x2F;&#x2F;从pos开始查找c出现的第一次位置</p>
</li>
<li><p><code>int rfind(const string&amp; str, int pos = npos) const;</code>&#x2F;&#x2F;从pos开始查找str出现的最后一次位置</p>
</li>
<li><p><code>int rfind(const char* s,int pos = npos) const</code>&#x2F;&#x2F;从pos开始查找s出现的最后一次位置</p>
</li>
<li><p><code>int rfind(const char* s, int pos, int n) const;</code>&#x2F;&#x2F;从pos开始查找s的前n个字符出现的最后一次位置</p>
</li>
<li><p><code>int find(const char c,int pos = 0) const</code>&#x2F;&#x2F;从pos开始查找c出现的最后一次位置</p>
</li>
<li><p><code>sting&amp; replace(int pos, int n, const string&amp; str)</code>&#x2F;&#x2F;替换从pos开始n个字符为字符串str</p>
</li>
<li><p><code>sting&amp; replace(int pos, int n, const char* s)</code>&#x2F;&#x2F;替换从pos开始n个字符为字符串s</p>
</li>
<li><p>find是从左往右，rfind是从右往左，二者都是寻找第一次找到的字符或字符串，故从结果上来看find的结果是从左到右第一次出现的位置，rfind的结果是从左到右最后一次出现的位置。</p>
</li>
<li><p>find和rfind找不到字符时返回-1。</p>
</li>
<li><p>replace在替换时要指定替换的开始位置、字符数量和字符内容。</p>
</li>
</ul>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><ul>
<li><p>比较方式：按ASCII码进行比较。<br>&#x3D; 返回 0<br>&gt; 返回 1<br>&lt; 返回 -1</p>
</li>
<li><p><code>int compare(const string&amp; s) const;</code></p>
</li>
<li><p><code>int compare(const char* s) const;</code></p>
</li>
</ul>
<h3 id="字符串存取"><a href="#字符串存取" class="headerlink" title="字符串存取"></a>字符串存取</h3><ul>
<li><p><code>char&amp; operator[](int n);</code>&#x2F;&#x2F;通过[]取字符</p>
</li>
<li><p><code>char&amp; at(int n);</code>&#x2F;&#x2F;通过at取字符</p>
</li>
</ul>
<h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><ul>
<li><p><code>string&amp; insert(int pos, const char* s);</code></p>
</li>
<li><p><code>string&amp; insert(int pos, const string&amp; str);</code></p>
</li>
<li><p><code>string&amp; insert(int pos, int n, char c);</code>&#x2F;&#x2F;在pos位置插入n个字符c</p>
</li>
<li><p><code>string&amp; erase(int pos, int n = npos);</code>&#x2F;&#x2F;删除从pos开始的n个字符</p>
</li>
<li><p><code>string&amp; erase(pos);</code>&#x2F;&#x2F;删除pos处的一个字符</p>
</li>
<li><p><code>erase(first,last);</code>&#x2F;&#x2F;删除从first到last之间的字符</p>
</li>
<li><p>插入和删除的下标都是从0开始。</p>
</li>
</ul>
<h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><ul>
<li><code>string substr(int pos = 0, int n = npos) const;</code>&#x2F;&#x2F;返回从pos开始的n个字符组成的字符串</li>
</ul>
<h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>vector数据结构和数组十分相似，也称为单端数组。</p>
</li>
<li><p>数组是静态空间，而vector可以动态扩展。<br>动态扩展：并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</p>
</li>
<li><p>vector的迭代器是支持随机访问的迭代器</p>
</li>
</ul>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li><p><code>vector&lt;T&gt; v;</code>&#x2F;&#x2F;采用模板实现类实现，默认构造函数</p>
</li>
<li><p><code>vector&lt;T&gt; v(num)</code>&#x2F;&#x2F;创建容量为num的vector，默认值为0</p>
</li>
<li><p><code>vector(v.begin(), v.end());</code>&#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身</p>
</li>
<li><p><code>vector(n, elem);</code>&#x2F;&#x2F;将n个elem拷贝给本身</p>
</li>
<li><p><code>vector(const vector&amp; vec);</code>&#x2F;&#x2F;拷贝构造</p>
</li>
</ul>
<h3 id="赋值操作-1"><a href="#赋值操作-1" class="headerlink" title="赋值操作"></a>赋值操作</h3><ul>
<li><p><code>vector&amp; operator=(const vector&amp; vec);</code></p>
</li>
<li><p><code>assign(beg, end);</code>&#x2F;&#x2F;将[beg, end)区间中的元素拷贝给本身</p>
</li>
<li><p><code>assign(n, elem);</code>&#x2F;&#x2F;将n个elem拷贝给本身</p>
</li>
</ul>
<h3 id="容量和大小"><a href="#容量和大小" class="headerlink" title="容量和大小"></a>容量和大小</h3><ul>
<li><p><code>empty();</code>&#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>capacity();</code>&#x2F;&#x2F;容器的容量</p>
</li>
<li><p><code>size();</code>&#x2F;&#x2F;容器的元素的个数</p>
</li>
<li><p><code>resize(int num);</code>&#x2F;&#x2F;重新指定容器的长度为num。若容器变长，则以默认值填充新位置；若容器变短，则多出的元素将被删除。</p>
</li>
<li><p><code>resize(int num, elem);</code>&#x2F;&#x2F;重新指定容器的长度为num。若容器变长，则以elem填充新位置；若容器变短，则多出的元素将被删除。</p>
</li>
</ul>
<h3 id="插入和删除-1"><a href="#插入和删除-1" class="headerlink" title="插入和删除"></a>插入和删除</h3><ul>
<li><p><code>push_back(elem);</code>&#x2F;&#x2F;尾插元素elem</p>
</li>
<li><p><code>pop_back();</code>&#x2F;&#x2F;删除最后一个元素</p>
</li>
<li><p><code>insert(const_iterator pos, elem);</code>&#x2F;&#x2F;迭代器指向位置pos插入元素elem</p>
</li>
<li><p><code>insert(const_iterator pos, int count, elem);</code>&#x2F;&#x2F;迭代器指向位置pos插入count个元素elem</p>
</li>
<li><p><code>erase(const_iterator pos);</code>&#x2F;&#x2F;删除迭代器指向的元素</p>
</li>
<li><p><code>erase(const_iterator start, const_iterator end);</code>&#x2F;&#x2F;删除迭代器从start到end之间的元素</p>
</li>
<li><p><code>clear();</code>&#x2F;&#x2F;删除容器中所有元素</p>
</li>
</ul>
<h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h3><ul>
<li><p><code>at(int idx);</code>&#x2F;&#x2F;返回索引idx所指的数据</p>
</li>
<li><p><code>operator[];</code></p>
</li>
<li><p><code>front();</code>&#x2F;&#x2F;返回容器中的第一个元素</p>
</li>
<li><p><code>back();</code>&#x2F;&#x2F;返回容器中的最后一个元素</p>
</li>
</ul>
<h3 id="互换容器"><a href="#互换容器" class="headerlink" title="互换容器"></a>互换容器</h3><ul>
<li><p><code>swap(vec);</code>&#x2F;&#x2F;将vec与本身的元素互换</p>
</li>
<li><p>swap可以使两个容器互换，可以达到收缩内存效果。</p>
</li>
</ul>
<h3 id="预留空间"><a href="#预留空间" class="headerlink" title="预留空间"></a>预留空间</h3><ul>
<li><p><code>reserve(int len);</code>&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问</p>
</li>
<li><p>预留空间可以减少vector在动态扩展容量时的扩展次数。如果数据量较大，可以一开始利用reserve预留空间。</p>
</li>
</ul>
<h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>vector对于头部的插入效率低，数据量越大，效率越低。deque相对而言对头部的插入速度更快。但是vector访问元素的速度更快。这与两者内部的实现有关。</p>
</li>
<li><p>内部工作原理：deque内部有个中控器，维护每段缓冲区的内容，缓冲区中存放真实数据。中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间。</p>
</li>
<li><p>deque容器的迭代器也是支持随机访问的。</p>
</li>
</ul>
<h3 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li><p><code>deque&lt;T&gt;depT;</code></p>
</li>
<li><p><code>deque(beg,end);</code>&#x2F;&#x2F;将[beg, end)区间中的元素拷贝给本身</p>
</li>
<li><p><code>deque(n,elem);</code>&#x2F;&#x2F;将n个elem拷贝给本身</p>
</li>
<li><p><code>deque(const deque&amp; dep);</code>&#x2F;&#x2F;拷贝构造函数</p>
</li>
</ul>
<h3 id="赋值操作-2"><a href="#赋值操作-2" class="headerlink" title="赋值操作"></a>赋值操作</h3><ul>
<li><p><code>deque&amp; operator=(const deque&amp; dep);</code></p>
</li>
<li><p><code>assign(beg, end);</code>&#x2F;&#x2F;将[beg, end)区间中的元素拷贝给本身</p>
</li>
<li><p><code>assign(n, elem);</code>&#x2F;&#x2F;拷贝构造函数</p>
</li>
</ul>
<h3 id="大小操作"><a href="#大小操作" class="headerlink" title="大小操作"></a>大小操作</h3><ul>
<li><p><code>deque.empty();</code>&#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>deque.size();</code>&#x2F;&#x2F;返回容器中元素的个数</p>
</li>
<li><p><code>deuqe.resize(int num);</code>&#x2F;&#x2F;重新指定容器的长度为num。若容器变长，则以默认值填充新位置；若容器变短，则多出的元素将被删除。</p>
</li>
<li><p><code>dque.resize(int num, elem);</code>&#x2F;&#x2F;重新指定容器的长度为num。若容器变长，则以elem填充新位置；若容器变短，则多出的元素将被删除。</p>
</li>
<li><p>deque容器没有容量的概念。</p>
</li>
</ul>
<h3 id="插入和删除-2"><a href="#插入和删除-2" class="headerlink" title="插入和删除"></a>插入和删除</h3><ul>
<li><p><code>push_back(elem);</code>&#x2F;&#x2F;在容器尾部添加一个数据</p>
</li>
<li><p><code>push_front(elem);</code>&#x2F;&#x2F;在容器头部添加一个数据</p>
</li>
<li><p><code>pop_back;</code>&#x2F;&#x2F;删除容器的最后一个数据</p>
</li>
<li><p><code>pop_front;</code>&#x2F;&#x2F;删除容器的第一个数据</p>
</li>
<li><p><code>insert(pos, elem);</code>&#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置</p>
</li>
<li><p><code>insert(pos, n, elem);</code>&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值</p>
</li>
<li><p><code>insert(pos, beg, end);</code>&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</p>
</li>
<li><p><code>clear();</code>&#x2F;&#x2F;清除所有数据</p>
</li>
<li><p><code>erase(beg, end);</code>&#x2F;&#x2F;删除[beg, end)区间的数据u，返回下一个数据的位置</p>
</li>
<li><p><code>erase(pos);</code>&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置</p>
</li>
<li><p>插入和删除提供的位置是迭代器</p>
</li>
</ul>
<h3 id="数据存取-1"><a href="#数据存取-1" class="headerlink" title="数据存取"></a>数据存取</h3><ul>
<li><p><code>at(int, idx);</code>&#x2F;&#x2F;返回索引idx所指的数据</p>
</li>
<li><p><code>operator[];</code></p>
</li>
<li><p><code>front();</code>&#x2F;&#x2F;返回第一个元素</p>
</li>
<li><p><code>end();</code>&#x2F;&#x2F;返回最后一个元素</p>
</li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li><p><code>sort(iterator beg, iterator end);</code>&#x2F;&#x2F;对beg和end之间的元素进行排序</p>
</li>
<li><p>sort算法使用时应包含头文件 algorithm。</p>
</li>
</ul>
<h2 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p>stack是一种先进后出的数据结构，它只有一个出口。栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为。栈中进出数据称为入栈，栈中弹出数据称为出栈。</p>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><p>构造函数</p>
<ul>
<li><p><code>stack&lt;T&gt; stk;</code></p>
</li>
<li><p><code>stack(const stack&amp; stk);</code>&#x2F;&#x2F;拷贝构造</p>
</li>
</ul>
<p>赋值操作</p>
<ul>
<li><code>stack&amp; operator=(const stack&amp; stk);</code></li>
</ul>
<p>数据存取</p>
<ul>
<li><p><code>push(elem);</code>&#x2F;&#x2F;向栈顶添加数据</p>
</li>
<li><p><code>pop();</code>&#x2F;&#x2F;从栈顶移除一个数据</p>
</li>
<li><p><code>top();</code>&#x2F;&#x2F;返回栈顶元素</p>
</li>
</ul>
<p>大小操作</p>
<ul>
<li><p><code>empty();</code>&#x2F;&#x2F;判断堆栈是否为空</p>
</li>
<li><p><code>size();</code>&#x2F;&#x2F;返回栈的大小</p>
</li>
</ul>
<h2 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h2><h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><p>queue是一种先进先出的数据结构，它有两个出口。队列容器允许从一端新增元素，从另一端移除元素。队列中只允许队头和队尾才可以被外界使用，因此队列不允许有遍历行为。队列中进数据称为入队(push)，出数据称为出队(pop)。</p>
<p>构造函数</p>
<ul>
<li><p><code>queue&lt;T&gt; que;</code></p>
</li>
<li><p><code>queue(const queue&amp; que);</code>&#x2F;&#x2F;拷贝构造</p>
</li>
</ul>
<p>赋值操作</p>
<ul>
<li><code>queue&amp; operator=(const queue&amp; que);</code></li>
</ul>
<p>数据存取</p>
<ul>
<li><p><code>push(elem);</code>&#x2F;&#x2F;往队尾添加元素</p>
</li>
<li><p><code>pop();</code>&#x2F;&#x2F;删除队头第一个元素</p>
</li>
<li><p><code>back();</code>&#x2F;&#x2F;返回最后一个元素</p>
</li>
<li><p><code>front();</code>&#x2F;&#x2F;返回第一个元素</p>
</li>
</ul>
<p>大小操作</p>
<ul>
<li><p><code>empty();</code>&#x2F;&#x2F;判断堆栈是否为空</p>
</li>
<li><p><code>size();</code>&#x2F;&#x2F;返回栈的大小</p>
</li>
</ul>
<h2 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h2><h3 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>链表是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针连接实现的。链表由一系列结点组成。结点有数据域和下一个结点地点的指针域组成。STL的链表是一个双向循环链表。由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器。</p>
</li>
<li><p>list的优点是采用动态存储分配，不会造成内存浪费和溢出；链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素。</p>
</li>
<li><p>list的缺点是链表灵活，但是空间（指针域）和时间（遍历）额外耗费较大。</p>
</li>
<li><p>list有一个重要的性质，插入和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p>
</li>
</ul>
<h3 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li><p><code>list&lt;T&gt; lst;</code></p>
</li>
<li><p><code>list(beg, end);</code>&#x2F;&#x2F;将[beg, end)区间中的元素拷贝给本身</p>
</li>
<li><p><code>list(n, elem);</code>&#x2F;&#x2F;将n个elem拷贝给本身</p>
</li>
<li><p><code>list(const list&amp; lst);</code>&#x2F;&#x2F;拷贝构造函数</p>
</li>
</ul>
<h3 id="赋值与交换"><a href="#赋值与交换" class="headerlink" title="赋值与交换"></a>赋值与交换</h3><ul>
<li><p><code>assign(beg, end);</code>&#x2F;&#x2F;将[beg, end)区间中的元素拷贝给本身</p>
</li>
<li><p><code>asign(n, elem);</code>&#x2F;&#x2F;将n个elem拷贝给本身</p>
</li>
<li><p><code>list&amp; operator = (const list&amp; lst);</code></p>
</li>
<li><p><code>swap(lst);</code>&#x2F;&#x2F;将lst于本身的元素互换</p>
</li>
</ul>
<h3 id="大小操作-1"><a href="#大小操作-1" class="headerlink" title="大小操作"></a>大小操作</h3><ul>
<li><p><code>size();</code>&#x2F;&#x2F;返回容器中元素的个数</p>
</li>
<li><p><code>empty();</code>&#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>resize();</code>&#x2F;&#x2F;重新指定容器的长度为num。若容器变长，则以默认值填充新位置；若容器变短，则多出的元素将被删除。</p>
</li>
<li><p><code>resize(int num, elem);</code>&#x2F;&#x2F;重新指定容器的长度为num。若容器变长，则以elem填充新位置；若容器变短，则多出的元素将被删除。</p>
</li>
</ul>
<h3 id="插入和删除-3"><a href="#插入和删除-3" class="headerlink" title="插入和删除"></a>插入和删除</h3><ul>
<li><p><code>push_back(elem);</code>&#x2F;&#x2F;尾插一个元素</p>
</li>
<li><p><code>pop_back();</code>&#x2F;&#x2F;删除最后一个元素</p>
</li>
<li><p><code>push_front(elem);</code>&#x2F;&#x2F;在容器开头插入一个元素</p>
</li>
<li><p><code>pop_front();</code>&#x2F;&#x2F;删除第一个元素</p>
</li>
<li><p><code>insert(pos, elem);</code>&#x2F;&#x2F;在pos位置插elem元素的拷贝</p>
</li>
<li><p><code>insert(pos, n, elem);</code>&#x2F;&#x2F;在pos位置插入n个elem</p>
</li>
<li><p><code>insert(pos, beg, end);</code>&#x2F;&#x2F;在pos位置插入[beg, end)区间的数据，无返回值</p>
</li>
<li><p><code>clear();</code>&#x2F;&#x2F;删除容器所有元素</p>
</li>
<li><p><code>erase(beg, end);</code>&#x2F;&#x2F;删除[beg, end)区间的数据，返回下一个元素的位置</p>
</li>
<li><p><code>erase(pos);</code>&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置</p>
</li>
<li><p><code>remove(elem);</code>&#x2F;&#x2F;删除容器中所有与elem值匹配的元素</p>
</li>
</ul>
<h3 id="数据存取-2"><a href="#数据存取-2" class="headerlink" title="数据存取"></a>数据存取</h3><ul>
<li><p><code>front();</code>&#x2F;&#x2F;返回第一个元素</p>
</li>
<li><p><code>back();</code>&#x2F;&#x2F;返回最后一个元素</p>
</li>
<li><p>list容器中不可以通过[]或者at方式访问数据。</p>
</li>
</ul>
<h3 id="反转和排序"><a href="#反转和排序" class="headerlink" title="反转和排序"></a>反转和排序</h3><ul>
<li><p><code>reverse();</code>&#x2F;&#x2F;反转链表</p>
</li>
<li><p><code>sort();</code>&#x2F;&#x2F;链表排序</p>
</li>
</ul>
<h2 id="set-x2F-multiset容器"><a href="#set-x2F-multiset容器" class="headerlink" title="set&#x2F; multiset容器"></a>set&#x2F; multiset容器</h2><h3 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>所有元素都会在插入时自动排序。</p>
</li>
<li><p>set&#x2F; multiset属于关联式容器，底层结构由二叉树实现。</p>
</li>
<li><p>区别：set不允许容器中有重复的元素；multiset允许容器中有重复元素。</p>
</li>
</ul>
<h3 id="构造和赋值"><a href="#构造和赋值" class="headerlink" title="构造和赋值"></a>构造和赋值</h3><ul>
<li><p><code>set&lt;T&gt; st;</code></p>
</li>
<li><p><code>set(const set&amp; st);</code>&#x2F;&#x2F;拷贝构造函数</p>
</li>
<li><p><code>set&amp; operator=(const set&amp; st);</code></p>
</li>
</ul>
<h3 id="大小和交换"><a href="#大小和交换" class="headerlink" title="大小和交换"></a>大小和交换</h3><ul>
<li><p><code>size();</code>&#x2F;&#x2F;返回容器中元素的个数</p>
</li>
<li><p><code>empty();</code>&#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>swap();</code>&#x2F;&#x2F;交换两个容器</p>
</li>
</ul>
<h3 id="插入和删除-4"><a href="#插入和删除-4" class="headerlink" title="插入和删除"></a>插入和删除</h3><ul>
<li><p><code>insert(elem);</code>&#x2F;&#x2F;插入元素elem</p>
</li>
<li><p><code>clear();</code>&#x2F;&#x2F;清空容器</p>
</li>
<li><p><code>erase(pos);</code>&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器</p>
</li>
<li><p><code>erase(beg, end);</code>&#x2F;&#x2F;删除区间[beg, end)的所有元素，返回下一个元素的迭代器</p>
</li>
<li><p><code>erase(elem);</code>&#x2F;&#x2F;删除容器中所有与elem值匹配的元素</p>
</li>
</ul>
<h3 id="查找和统计"><a href="#查找和统计" class="headerlink" title="查找和统计"></a>查找和统计</h3><ul>
<li><p><code>find(key);</code>&#x2F;&#x2F;查找key是否存在，若存在返回该元素的迭代器；若不存在返回set.end()</p>
</li>
<li><p><code>count(key);</code>&#x2F;&#x2F;统计key的元素个数（对于set，结果为0或1）</p>
</li>
</ul>
<h3 id="set和multiset的区别"><a href="#set和multiset的区别" class="headerlink" title="set和multiset的区别"></a>set和multiset的区别</h3><ul>
<li><p>set不可以插入重复数据，而multiset可以。</p>
</li>
<li><p>set插入数据的同时会返回插入结果，表示插入是否成功。返回的内容为对组，first为迭代器，second为bool。</p>
</li>
<li><p>multiset不会检测数据，因此可以插入重复数据。</p>
</li>
</ul>
<h3 id="pair对组创建"><a href="#pair对组创建" class="headerlink" title="pair对组创建"></a>pair对组创建</h3><ul>
<li><p><code>pair&lt;type, type&gt; p ( value1, value2 );</code></p>
</li>
<li><p><code>pair&lt;type, type&gt; p = make_pair( value, value2 );</code></p>
</li>
</ul>
<h3 id="容器排序"><a href="#容器排序" class="headerlink" title="容器排序"></a>容器排序</h3><p>set&#x2F; multiset容器容器默认排序规则为从小到大，可利用仿函数改变排序规则。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">comparePerson</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person &amp;p2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line">        <span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">insert</span>(p1);</span><br><span class="line">    s.<span class="built_in">insert</span>(p2);</span><br><span class="line">    s.<span class="built_in">insert</span>(p3);</span><br><span class="line">    s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map-x2F-multimap容器"><a href="#map-x2F-multimap容器" class="headerlink" title="map&#x2F; multimap容器"></a>map&#x2F; multimap容器</h2><h3 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>map&#x2F; multimap容器中所有容器都是pair。</p>
</li>
<li><p>pair中第一个元素为key，起到索引作用，第二个元素为value。</p>
</li>
<li><p>所有元素都会根据元素的key自动排序。</p>
</li>
<li><p>map&#x2F; multimap容器数据关联式容器，底层结构由二叉树实现。</p>
</li>
<li><p>可以根据key值快速找到value值。</p>
</li>
<li><p>区别：map不允许容器中有重复key值元素；multimap允许容器中有重复key值元素。</p>
</li>
</ul>
<h3 id="构造和赋值-1"><a href="#构造和赋值-1" class="headerlink" title="构造和赋值"></a>构造和赋值</h3><ul>
<li><p><code>map&lt;T1, T2&gt; mp;</code></p>
</li>
<li><p><code>map(const map&amp; mp);</code>&#x2F;&#x2F;拷贝构造函数</p>
</li>
<li><p><code>map&amp; operator=(const map&amp; mp);</code></p>
</li>
</ul>
<h3 id="大小和交换-1"><a href="#大小和交换-1" class="headerlink" title="大小和交换"></a>大小和交换</h3><ul>
<li><p><code>size();</code>&#x2F;&#x2F;返回容器中元素的数目</p>
</li>
<li><p><code>empty();</code>&#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>swap(st);</code>&#x2F;&#x2F;交换两个容器</p>
</li>
</ul>
<h3 id="插入和删除-5"><a href="#插入和删除-5" class="headerlink" title="插入和删除"></a>插入和删除</h3><ul>
<li><p>map中所有元素都是成对出现，插入数据时候要使用对组</p>
</li>
<li><p><code>insert(elem);</code>&#x2F;&#x2F;插入元素elem</p>
</li>
<li><p><code>clear();</code>&#x2F;&#x2F;清除所有元素</p>
</li>
<li><p><code>erase(pos);</code>&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器</p>
</li>
<li><p><code>erase(beg, end);</code>&#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器</p>
</li>
<li><p><code>erakey(key);</code>&#x2F;&#x2F;删除容器中值为key的元素</p>
</li>
</ul>
<h3 id="查找和统计-1"><a href="#查找和统计-1" class="headerlink" title="查找和统计"></a>查找和统计</h3><ul>
<li><p><code>find(key);</code>&#x2F;&#x2F;查找key是否存在，若存在返回该元素的迭代器；若不存在返回map.end()</p>
</li>
<li><p><code>count(key);</code>&#x2F;&#x2F;统计key的元素个数（对于map，结果为0或1）</p>
</li>
</ul>
<h3 id="容器排序-1"><a href="#容器排序-1" class="headerlink" title="容器排序"></a>容器排序</h3><p>map&#x2F; multimap容器容器默认排序规则为从小到大，可利用仿函数改变排序规则。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认从小到大排序</span></span><br><span class="line">    <span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><ul>
<li><p>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code> 组成。</p>
</li>
<li><p><algorithm>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</p>
</li>
<li><p><numeric>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</p>
</li>
<li><p><functional>定义了一些模板类,用以声明函数对象。</p>
</li>
</ul>
<h2 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h2><h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h3><ul>
<li><p><code>for_each(iterator beg, iterator end, _func);</code>&#x2F;&#x2F; beg 开始迭代器; end 结束迭代器; _func 函数或者函数对象</p>
</li>
<li><p>实现容器的遍历</p>
</li>
</ul>
<h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><ul>
<li><p><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code>&#x2F;&#x2F;beg1 源容器开始迭代器; end1 源容器结束迭代器; beg2 目标容器开始迭代器; _func 函数或者函数对象</p>
</li>
<li><p>搬运容器到另一个容器中</p>
</li>
<li><p>搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
</li>
</ul>
<h2 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul>
<li><p><code>find(iterator beg, iterator end, value);</code>&#x2F;&#x2F;beg 开始迭代器; end 结束迭代器; value 查找的元素</p>
</li>
<li><p>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
</li>
</ul>
<h3 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h3><ul>
<li><p><code>find_if(iterator beg, iterator end, _Pred);</code>&#x2F;&#x2F; beg 开始迭代器; end 结束迭代器; _Pred 函数或者谓词（返回bool类型的仿函数）</p>
</li>
<li><p>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
</li>
</ul>
<h3 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h3><ul>
<li><p><code>adjacent_find(iterator beg, iterator end);</code>&#x2F;&#x2F;beg 开始迭代器; end 结束迭代器</p>
</li>
<li><p>查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p>
</li>
</ul>
<h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><ul>
<li><p><code>bool binary_search(iterator beg, iterator end, value);</code>&#x2F;&#x2F; beg 开始迭代器;end 结束迭代器;value 查找的元素</p>
</li>
<li><p>查找指定的元素，查到 返回true 否则false</p>
</li>
<li><p>在无序序列中不可用</p>
</li>
</ul>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><ul>
<li><p><code>count(iterator beg, iterator end, value);</code>&#x2F;&#x2F; beg 开始迭代器; end 结束迭代器; value 统计的元素</p>
</li>
<li><p>统计元素出现次数</p>
</li>
<li><p>统计自定义数据类型时，需要配合重载 operator&#x3D;&#x3D;</p>
</li>
</ul>
<h3 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h3><ul>
<li><p><code>count_if(iterator beg, iterator end, _Pred);</code>&#x2F;&#x2F; beg 开始迭代器; end 结束迭代器; _Pred 谓词</p>
</li>
<li><p>按条件统计元素出现次数</p>
</li>
</ul>
<h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><ul>
<li><p><code>sort(iterator beg, iterator end, _Pred);</code>&#x2F;&#x2F;beg 开始迭代器; end 结束迭代器; _Pred 谓词</p>
</li>
<li><p>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
</li>
</ul>
<h3 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h3><ul>
<li><p><code>random_shuffle(iterator beg, iterator end);</code>&#x2F;&#x2F;beg 开始迭代器; end 结束迭代器</p>
</li>
<li><p>指定范围内的元素随机调整次序</p>
</li>
<li><p>使用时需要添加随机数种子</p>
</li>
</ul>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><ul>
<li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code>&#x2F;&#x2F;beg1 容器1开始迭代器; end1 容器1结束迭代器; beg2 容器2开始迭代器; end2 容器2结束迭代器; dest 目标容器开始迭代器</p>
</li>
<li><p>容器元素合并，并存储到另一容器中</p>
</li>
<li><p>两个容器必须是有序的</p>
</li>
</ul>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><ul>
<li><p><code>reverse(iterator beg, iterator end);</code>&#x2F;&#x2F;beg 开始迭代器; end 结束迭代器</p>
</li>
<li><p>反转指定范围的元素</p>
</li>
</ul>
<h2 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h2><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><ul>
<li><p><code>copy(iterator beg, iterator end, iterator dest);</code> &#x2F;&#x2F;beg 开始迭代器; end 结束迭代器; dest 目标起始迭代器</p>
</li>
<li><p>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
</li>
</ul>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><ul>
<li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code>&#x2F;&#x2F;beg 开始迭代器; end 结束迭代器; oldvalue 旧元素; newvalue 新元素</p>
</li>
<li><p>将区间内旧元素 替换成 新元素</p>
</li>
</ul>
<h3 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if"></a>replace_if</h3><ul>
<li><p><code>replace_if(iterator beg, iterator end, _Pred, newvalue);</code>&#x2F;&#x2F;beg 开始迭代器; end 结束迭代器; _pred 谓词; newvalue 替换的新元素</p>
</li>
<li><p>按条件替换元素，满足条件的替换成指定元素</p>
</li>
</ul>
<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><ul>
<li><p><code>swap(container c1, container c2);</code>&#x2F;&#x2F;c1容器1; c2容器2</p>
</li>
<li><p>互换两个容器的元素，两个容器要同种类型</p>
</li>
</ul>
<h2 id="常用算术生成算法"><a href="#常用算术生成算法" class="headerlink" title="常用算术生成算法"></a>常用算术生成算法</h2><ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为#include <numeric></li>
</ul>
<h3 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h3><ul>
<li><p><code>accumulate(iterator beg, iterator end, value);</code>&#x2F;&#x2F;beg 开始迭代器； end 结束迭代器； value 起始值</p>
</li>
<li><p>计算容器元素累计总和</p>
</li>
</ul>
<h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><ul>
<li><p><code>fill(iterator beg, iterator end, value);</code> &#x2F;&#x2F;beg 开始迭代器; end 结束迭代器; value 填充的值</p>
</li>
<li><p>向容器中填充指定元素</p>
</li>
</ul>
<h2 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h2><h3 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h3><ul>
<li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code>&#x2F;&#x2F; beg1 容器1开始迭代器; end1 容器1结束迭代器; beg2 容器2开始迭代器; end2 容器2结束迭代器; dest 目标容器开始迭代器</p>
</li>
<li><p>求两个集合的交集</p>
</li>
<li><p>两个集合必须是有序序列</p>
</li>
<li><p>目标容器开辟空间需要从两个容器中取小值</p>
</li>
<li><p>set_intersection返回值既是交集中最后一个元素的位置</p>
</li>
</ul>
<h3 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h3><ul>
<li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code>&#x2F;&#x2F;beg1 容器1开始迭代器; end1 容器1结束迭代器; beg2 容器2开始迭代器; end2 容器2结束迭代器; dest 目标容器开始迭代器</p>
</li>
<li><p>求两个集合的并集</p>
</li>
<li><p>两个集合必须是有序序列</p>
</li>
<li><p>目标容器开辟空间需要两个容器相加</p>
</li>
<li><p>set_union返回值既是并集中最后一个元素的位置</p>
</li>
</ul>
<h3 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h3><ul>
<li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code>&#x2F;&#x2F;beg1 容器1开始迭代器; end1 容器1结束迭代器; beg2 容器2开始迭代器; end2 容器2结束迭代器; dest 目标容器开始迭代器</p>
</li>
<li><p>求两个集合的差集</p>
</li>
<li><p>两个集合必须是有序序列</p>
</li>
<li><p>目标容器开辟空间需要从两个容器取较大值</p>
</li>
<li><p>set_difference返回值是差集中最后一个元素的位置</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>连续删除链表结点</title>
    <url>/2022/04/21/C++%E5%AD%A6%E4%B9%A0/%E8%BF%9E%E7%BB%AD%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p>struct定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Linklist</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	Linklist *next;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>函数实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(LinkList *list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value;<span class="comment">//要删除的结点数据</span></span><br><span class="line">    cin&gt;&gt;value;</span><br><span class="line">    Linklist *t = list-&gt;next,*in = list;</span><br><span class="line">    <span class="keyword">while</span>(t != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		Linklist *t = list -&gt;next,* in = list;</span><br><span class="line">        <span class="keyword">while</span>(t != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> is = <span class="number">1</span>;<span class="comment">//判断是否查找到对象</span></span><br><span class="line">            <span class="keyword">if</span>(t-&gt;date != age)is = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(is == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                in -&gt;next = t-&gt;next;</span><br><span class="line">                <span class="built_in">delete</span>(t);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">            in = in-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Linux常用命令总结</title>
    <url>/2023/03/18/Linux%E5%AD%A6%E4%B9%A0/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="文件和目录命令"><a href="#文件和目录命令" class="headerlink" title="文件和目录命令"></a>文件和目录命令</h1><ul>
<li><p>ls</p>
<ul>
<li><p><code>-a</code>显示指定目录下所有子目录和文件，包括隐藏文件</p>
</li>
<li><p><code>-l</code>纵向显示文件列表和详细信息</p>
</li>
<li><p><code>-h</code>以KB显示文件大小</p>
</li>
<li><p>通配符的使用</p>
<ul>
<li><blockquote>
<p><code>*</code>表示任意个数字符</p>
<p><code>？</code>表示任意一个字符</p>
<p><code>[]</code>表示可以匹配字符组中的任意一个</p>
<p><code>[abc]</code>匹配a，b，c中任意一个</p>
<p><code>[a-f]</code>匹配a到f范围中任意一个字符</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>cd </p>
<ul>
<li><code>cd</code> 切换到当前用户主目录&#x2F;home&#x2F;用户目录</li>
<li><code>cd ～</code> 切换到当前用户主目录&#x2F;home&#x2F;用户目录</li>
<li><code>cd . </code>保持当前目录不变</li>
<li><code>cd ..</code> 切换到上级目录</li>
<li><code>cd -</code> 可以在最近两次工作目录之间来回切换</li>
<li>绝对路径：在输入路径时最前面不是&#x2F;或～，表示相对当前目录所在的目录位置</li>
<li>相对路径：在输入路径时，最前面是&#x2F;或者～，表示从根目录&#x2F;家目录开始的具体位置</li>
</ul>
</li>
<li><p>touch</p>
<ul>
<li>文件不存在，创建文件</li>
<li>文件存在，修改末次修改时间</li>
</ul>
</li>
<li><p>mkdir</p>
<ul>
<li>创建目录，同一个目录下目录和文件都不能同名</li>
<li><code>-p</code>创建多级目录</li>
</ul>
</li>
<li><p>rm</p>
<ul>
<li>删除后无法恢复</li>
<li><code>-f</code>强制删除，忽略不存在的文件</li>
<li><code>-r</code>递归删除目录下内容，删除文件夹时使用</li>
</ul>
</li>
<li><p>tree</p>
<ul>
<li>以树状图列出文件目录结构</li>
<li><code>-d</code>只显示目录</li>
</ul>
</li>
</ul>
<h1 id="拷贝和移动命令"><a href="#拷贝和移动命令" class="headerlink" title="拷贝和移动命令"></a>拷贝和移动命令</h1><ul>
<li><p>cp</p>
<ul>
<li><code>cp 源文件 目标文件</code>复制文件或目录到另一个文件或目录中</li>
<li><code>-i</code>覆盖文件前提示</li>
<li><code>-r</code>若给出源文件是目录文件，则cp将递归复制该目录下所有子目录和文件，目标文件必须为一个目录名</li>
</ul>
</li>
<li><p>mv</p>
<ul>
<li>mv 源文件 目标文件：移动或重命名文件或目录</li>
<li><code>-i</code>覆盖前提示</li>
</ul>
</li>
</ul>
<h1 id="文件内容命令"><a href="#文件内容命令" class="headerlink" title="文件内容命令"></a>文件内容命令</h1><ul>
<li><p>cat</p>
<ul>
<li>显示文件全部内容</li>
<li><code>-b</code>为文件标行号</li>
<li><code>-n</code>为所有行标行号（包括空行）</li>
</ul>
</li>
<li><p>more</p>
<ul>
<li>分屏显示文件</li>
<li><code>Space</code>显示下一页</li>
<li><code>Enter</code>一次滚动一行</li>
<li><code>b</code>回滚一屏</li>
<li><code>f</code>前滚一屏</li>
<li><code>q</code>退出</li>
</ul>
</li>
<li><p>grep</p>
<ul>
<li>文本搜索工具</li>
<li><code>-n</code>显示匹配行及行号</li>
<li><code>-v</code>显示不含不包含目标文本的行</li>
<li><code>-i</code>忽略大小写</li>
<li><code>^a</code>行首，搜索以a开始的行</li>
<li><code>ke$</code>行尾，搜索以ke为结尾的行</li>
</ul>
</li>
<li><p>echo</p>
<ul>
<li>显示参数指定的文字</li>
<li><code>&gt;</code>表示输出，会覆盖文件原有内容</li>
<li><code>&gt;&gt;</code>表示输入，会将内容追加到已有文件的</li>
</ul>
</li>
<li><p>管道<code>|</code></p>
<ul>
<li>将一个命令的输出通过管道作为另一个命令的输入</li>
<li>more</li>
<li>grep</li>
</ul>
</li>
</ul>
<h1 id="远程操作命令"><a href="#远程操作命令" class="headerlink" title="远程操作命令"></a>远程操作命令</h1><ul>
<li><p>shutdown</p>
<ul>
<li><code>shutdown</code> 选项 时间</li>
<li><code>-r</code>重新启动</li>
<li><code>-c</code>取消关机计划</li>
</ul>
</li>
<li><p>ifconfig</p>
<ul>
<li>查看配置网卡设置信息</li>
<li><code>127.0.0.1</code>本地回环地址</li>
</ul>
</li>
<li><p>ping</p>
<ul>
<li>检测计算机到计算机网络连接是否正常，数值越大，速度越慢</li>
</ul>
</li>
<li><p>scp</p>
<ul>
<li>远程拷贝命令</li>
<li><code>scp -P port  filename user@remote:Desktop/filename</code><ul>
<li>复制当前目录下文件到远程文件夹</li>
</ul>
</li>
<li><code>scp -P port  user@remote:Desktop/filename filename</code><ul>
<li>从远程文件夹复制文件到当前目录</li>
</ul>
</li>
<li>WIN scp command<ul>
<li><code>scp -rp .\Desktop\Notes logo@192.168.142.128:Desktop/</code></li>
<li>复制当前目录下文件夹到远程目录</li>
<li><code>scp -p logo@192.168.142.128:Desktop/linuxNotes/Command.md C:\Users\admin\Desktop</code><ul>
<li>从远程文件夹复制文件到当前目录</li>
</ul>
</li>
</ul>
</li>
<li><code>-r</code>复制文件夹</li>
</ul>
</li>
<li><p>ssh</p>
<ul>
<li><p><code>ssh -p 22 user@remote</code></p>
</li>
<li><p><code>ssh-keygen</code>生成ssh钥匙</p>
</li>
<li><p><code>ssh-copy-id -p port user@remote</code>让远程服务器记住公匙</p>
</li>
<li><p>添加别名：在<code>~/.ssh/config</code>中追加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host logo_ubuntu</span><br><span class="line">	Hostname 192.168.142.128</span><br><span class="line">	User logo</span><br><span class="line">	Port 22</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="用户权限命令"><a href="#用户权限命令" class="headerlink" title="用户权限命令"></a>用户权限命令</h1><ul>
<li><p>ls -l 拓展</p>
<ul>
<li><blockquote>
<p>r 可读 4</p>
<p>w 可写 2</p>
<p>x 可执行 1</p>
</blockquote>
</li>
<li><blockquote>
<p>第一列（一个字符）：是否是文件夹标记</p>
<p>第二列（三个字符）：文件拥有者权限</p>
<p>第三列（三个字符）：组权限</p>
<p>第四列（三个字符）：其他用户权限</p>
<p>第五列（数字）：硬连接数</p>
<ul>
<li>硬连接数：有多少种方式可以访问当前目录&#x2F;文件</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>chmod</p>
<ul>
<li>修改用户&#x2F;组对文件&#x2F;目录权限</li>
<li><code>chmod +/- rwx 文件|目录名</code><ul>
<li>执行文件：<code>./文件名</code></li>
</ul>
</li>
</ul>
</li>
<li><p>sudo</p>
<ul>
<li>以其他身份来执行命令，预设的身份为root</li>
</ul>
</li>
</ul>
<h1 id="组管理命令"><a href="#组管理命令" class="headerlink" title="组管理命令"></a>组管理命令</h1><ul>
<li>创建组&#x2F;删除组都需要<code>sudo</code></li>
<li><code>groupadd 组名</code>添加组</li>
<li><code>groupdel 组名</code>删除组</li>
<li><code>cat/etc/group</code>确认组信息</li>
<li>组信息保存在<code>/etc/group</code>文件中</li>
<li><code>/etc</code>目录是专门用来保存系统配置信息的目录</li>
<li><code>chgrp -R 组名 文件/目录名</code>递归修改文件&#x2F;目录的所属组</li>
</ul>
<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><ul>
<li><p><code>useradd -m -g 组</code>添加新用户</p>
<ul>
<li>-m 自动建立用户家目录</li>
<li>-g 指定用户所在的组，否则会建立一个和用户同名的组</li>
</ul>
</li>
<li><p><code>passwd 用户名</code>设置用户密码</p>
</li>
<li><p><code>userdel -r 用户名</code>删除信息</p>
<ul>
<li>-r 删除用户家目录</li>
</ul>
</li>
<li><p><code>cat /etc/passwd | grep 用户名</code>确认用户信息，新建用户后，用户信息会保存在&#x2F;etc&#x2F;passwd中</p>
</li>
<li><p><code>id 用户名</code>查看用户UID（用户标识）和GID（组标识）信息</p>
</li>
<li><p><code>who</code>查看当前所有登陆的用户列表</p>
</li>
<li><p><code>whoami</code>查看当前登陆用户的账户名</p>
</li>
<li><p>passwd文件：<code>/etc/passwd</code>文件保存的是用户的信息，由6个分号组成的7个信息</p>
<ul>
<li><blockquote>
<p>用户名</p>
<p>密码（x，表示加密的密码）</p>
<p>UID</p>
<p>GID</p>
<p>用户全名或本地账号</p>
<p>家目录</p>
<p>登陆使用的Shell，就是登陆之后使用的终端命令，ubuntu默认的是dash</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>usermod -g 组 用户名</code>修改用户主组</p>
</li>
<li><p><code>usermod -G 组 用户名</code>修改用户附加组</p>
<ul>
<li><code>usermod -G sudo 用户名</code>给用户添加sudo权限</li>
</ul>
</li>
<li><p><code>usermod -s /bin/bash</code>修改用户登陆Shell为bash，XShell下dash存在缺陷</p>
</li>
<li><p>which</p>
<ul>
<li><code>which 命令</code>查看执行命令所在位置<ul>
<li><blockquote>
<p><code>/user/passwd</code>用于保存用户信息的文件</p>
<p><code>/user/bin/passwd</code>用于修改用户密码的程序</p>
<p><code>/bin</code>二进制执行文件目录，主要用于具体应用</p>
<p><code>/sbin</code>系统管理员专用的二进制代码存放目录，主要用于系统管理</p>
<p><code>/usr/bin</code>后期安装的一些软件</p>
<p><code>/usr/sbin</code>超级用户的一些管理程序</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>su</p>
<ul>
<li><code>su - 用户名</code>切换用户和目录</li>
<li><code>exit</code>退出当前登陆目录</li>
<li><code>su</code>切换到root，但不安全</li>
</ul>
</li>
<li><p>修改文件权限</p>
<ul>
<li><code>chown 用户名 文件名|目录名</code>修改文件的拥有者</li>
<li><code>chgrp -R 组名 文件名|目录名</code>递归修改文件的组</li>
<li><code>chmod -R 755</code>递归修改文件权限，三个数字分别代表拥有者&#x2F;组&#x2F;其他用户的权限</li>
<li>r -&gt; 4  w -&gt; 2  x -&gt; 1,例如755-&gt;rwx r-x r-x</li>
</ul>
</li>
</ul>
<h1 id="系统信息相关命令"><a href="#系统信息相关命令" class="headerlink" title="系统信息相关命令"></a>系统信息相关命令</h1><ul>
<li><p><code>date</code>查看当前系统时间</p>
</li>
<li><p><code>cal </code>查看日历</p>
<ul>
<li><code>-y</code>查看一年的日历</li>
</ul>
</li>
<li><p><code>df -h</code>显示磁盘剩余空间</p>
</li>
<li><p><code>du -h[目录名]</code>显示目录下文件大小</p>
</li>
<li><p><code>ps aux</code>查看进程的详细状况</p>
<ul>
<li><p><code>ps</code>默认只会显示当前用户通过终端启动的应用程序</p>
</li>
<li><blockquote>
<p>a 显示终端上的所有进程，包括其他用户的进程</p>
<p>u 显示进程的详细状态</p>
<p>x 显示没有控制终端的进程</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>top</code>动态显示运行中的进程并排序</p>
</li>
<li><p><code>kill [-9] 进程代号</code>终止指定代号的进程，-9表示强行终止</p>
<ul>
<li>使用<code>kill</code>时不要终止root身份开启的进程</li>
</ul>
</li>
</ul>
<h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ul>
<li><p>find</p>
<ul>
<li><code>find[路径] -name &quot;*.py&quot;</code>查找文件</li>
</ul>
</li>
<li><p>ln</p>
<ul>
<li><code>ln -s 被链接的源文件 链接文件</code>建立文件的软链接</li>
<li>无<code>-s</code>建立的是硬链接文件（两个文件占用相同大小的硬盘空间）</li>
<li>源文件要使用绝对路经，方便移动链接文件后仍能正常使用</li>
<li>在Linux中文件名和文件数据是分开存储的</li>
</ul>
</li>
</ul>
<h1 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h1><ul>
<li><p><code>tar -cvf 打包文件.tar</code>打包文件</p>
</li>
<li><p><code>tar -xvf 打包文件.tar</code>解包文件</p>
</li>
<li><blockquote>
<p>c 生成档案文件，创建打包文件</p>
<p>x 解开档案文件</p>
<p>v 列出归档解档的详细过程，显示进度</p>
<p>f 指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后</p>
</blockquote>
</li>
<li><p>gzip</p>
<ul>
<li><p>tar只负责打包文件，但不压缩</p>
</li>
<li><p>用gzip压缩打包后文件扩展名为<code>filename.tar.gz</code></p>
</li>
<li><p><code>tar -zcvf 打包文件.tar.gz 被压缩的文件/路径...</code>压缩文件</p>
</li>
<li><p><code>tar -zxvf 打包文件.tar.gz </code>解压缩文件</p>
</li>
<li><p><code>tar -zxvf 打包文件.tar.gz -C 目标路径</code>解压缩文件到指定路径（指定路径必须存在）</p>
</li>
</ul>
</li>
<li><p>bzip2</p>
<ul>
<li><code>tar -jcvf 打包文件.tar.gz 被压缩的文件/路径...</code>压缩文件</li>
<li><code>tar -jxvf 打包文件.tar.gz </code>解压缩文件</li>
</ul>
</li>
</ul>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><ul>
<li><p><code>sudo apt install 软件包</code></p>
</li>
<li><p><code>sudo apt remove 软件包</code></p>
</li>
<li><p><code>sudo apt upgrade</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>C语言学习笔记</title>
    <url>/2021/06/15/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="程序设计与C语言"><a href="#程序设计与C语言" class="headerlink" title="程序设计与C语言"></a>程序设计与C语言</h1><h2 id="计算机与编程语言"><a href="#计算机与编程语言" class="headerlink" title="计算机与编程语言"></a>计算机与编程语言</h2><ul>
<li><p>编程语言不是人与计算机交谈的语言，而是以计算机可理解方式对解决问题的步骤进行描述</p>
</li>
<li><p>不同算法可以影响计算机运算速度（如限定条件）</p>
</li>
<li><p>执行方式：</p>
<ul>
<li>解释：借助一个程序，此程序指导计算机进行操作运行“目的程序”（可以理解“目的程序”）</li>
<li>编译：借助一个程序，此程序对目的程序进行翻译，来让计算机执行</li>
<li><strong>有的程序语言既可以编译执行也可以解释执行</strong></li>
</ul>
</li>
</ul>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><ul>
<li>程序框架</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&quot;&quot;</code>里面的内容叫做<code>&quot;字符串&quot;</code>，<code>printf</code>会把其中的内容原封不动地输出</p>
</li>
<li><p><code>\n</code>表示再输出的结果后面换一行</p>
</li>
</ul>
<h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>在按下回车键前，程序不会得到输入</p>
</li>
<li><p>定义变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  price = <span class="number">0</span>；</span><br><span class="line"><span class="comment">// 类型 名字  赋值 初始值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>变量是一个保存数据的地方，变量只有保存数据才能参与计算</p>
</li>
<li><p>变量定义的一般形式：&lt;类型名称&gt;&lt;变量名称&gt;</p>
</li>
<li><p>变量名称（标识符）：只能由字母、数字、下划线组成。数字不可以出现在第一个位置。C语言关键字（保留字）不可作标识符。</p>
</li>
<li><p>C语言保留字：</p>
</li>
</ul>
<blockquote>
<p>auto; break; case; char; const; continue; default; double; do; else; enum; extern; float; for; goto; if; int; long; register; return; short; signed; sizeof; static; struct; switch; typedef; union; unsigned; void; volatile; while; inline; restrict</p>
</blockquote>
<ul>
<li>变量在被使用之前应当初始化（被赋值）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化：&lt;类型名称&gt;&lt;变量名称&gt;=&lt;初始化&gt;</span></span><br><span class="line"><span class="type">int</span> price = <span class="number">0</span>；</span><br><span class="line"><span class="type">int</span> price = <span class="number">0</span>，amount = <span class="number">100</span>；</span><br></pre></td></tr></table></figure>

<ul>
<li><p>C语言是一种有类型的语言。且程序执行过程中变量类型不可改变。</p>
</li>
<li><p><code>printf</code>输出函数</p>
<p><code>scanf</code>输入函数：</p>
<ul>
<li><strong>加&amp;在变量名称前</strong></li>
<li>出现在<code>scanf</code>的格式字符串里面的东西是它一定要输出的东西（空格、回车、制表符均指空白字符）</li>
</ul>
</li>
<li><p>固定不变的数是常数，直接写在程序里称为直接量。</p>
</li>
<li><p><code>const</code>为修饰符，在<code>int</code>之前，表示不变的属性，表示这变量的值一旦初始化无法修改（全大写）</p>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>10和10.0不同</p>
<p>10为整数 10.0为浮点数</p>
</li>
<li><p>两个整数的计算结果只能是整数（去尾法保留），整数与浮点数运算时整数将变为浮点数</p>
</li>
</ul>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><ul>
<li><p>一个表达式是一系列运算符和算子的组合，用来计算一个值。</p>
<p><code>count = count + 1</code></p>
</li>
<li><p>运算符指进行运算的动作；算子指参与运算的值。</p>
<p>+；-；sizes &#x3D; 7</p>
<p>%表示取两个数相除以后的余数</p>
</li>
<li><p>运算符优先级</p>
</li>
</ul>
<blockquote>
<p>1 	+ - 	单目（只有一个算子）不变 自右向左 	a*-b a*+b</p>
<p>2 	* &#x2F; % </p>
<p>3 	+ -</p>
<p>4 	&#x3D;       赋值       自右向左  	a &#x3D; b</p>
</blockquote>
<ul>
<li><p>断点：让程序运行过程中暂停</p>
</li>
<li><p><code>total += 5</code>；等价于 <code>total = total + 5</code></p>
</li>
<li><p>两个运算符之间不留空格</p>
</li>
<li><p>符合赋值：+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;</p>
</li>
<li><p><code>total /= a + b</code> 等价于<code>total = total /（a + b）</code></p>
</li>
<li><p>++和–是单目运算符，且算子必须是变量（不能5++或++5），称作递增和递减，作用为为变量+1或-1，<strong>后缀a++<strong>代表a加1以</strong>前</strong>的值，<strong>前缀++a</strong>代表a加1以<strong>后</strong>的值。若a &#x3D; 10则<code>a++</code> &#x3D; 10，<code>++a</code> &#x3D; 11，a&#x3D;11</p>
</li>
<li><p><code>INC</code>：递增</p>
<p><code>DEC</code>：递减</p>
</li>
</ul>
<h1 id="判断与循环"><a href="#判断与循环" class="headerlink" title="判断与循环"></a>判断与循环</h1><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><ul>
<li><p>if常用框架</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>if</code>语句中条件的逻辑表达式若为<code>true</code>，则执行大括号中的语句，反之不执行</p>
</li>
<li><p>&#x3D;&#x3D;相等；!&#x3D;不相等 ；&gt;大于； &gt;&#x3D;大于或等于；&lt;小于；&lt;&#x3D;小于或等于</p>
</li>
<li><p>关系运算的结果成立为1，否则为0；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="number">5</span> == <span class="number">3</span>))<span class="comment">// 输出0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关系运算符优先级小于算术运算，大于赋值运算</p>
</li>
<li><p>判断是否相等关系运算低于其他关系运算</p>
</li>
<li><p><code>a  == b == c</code>：0&#x2F;1与c比较</p>
</li>
<li><p>以&#x2F;&#x2F;开头的语句将程序分开进行注释，为人类读者提供解释信息，对程序无影响，或以&#x2F;*到*&#x2F;</p>
</li>
<li><p><code>else</code>：否则的话 <code>else&#123;&#125;</code></p>
</li>
<li><p><code>if()</code>后不加<code>;</code>因为语句并没与结束</p>
</li>
<li><p><code>if</code>、<code>else</code>后若没有{}则只读其后一个语句</p>
</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul>
<li><p>计算机内最高能输入的整数为10位数</p>
</li>
<li><p><code>while</code>：当条件满足时，不断重复循环体内的语句。循环可能执行一次，也可能不执行</p>
</li>
<li><p><code>do-while</code>：进入循环时不检查，执行完一轮循环代码之后再判断循环条件</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">&lt;循环体语句&gt;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(&lt;循环条件&gt;)；<span class="comment">// 注意分号</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>for（初始条件；循环继续的条件（判断式）；循环每轮要进行的动作（累加器））</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (count = <span class="number">10</span>; count &gt; <span class="number">0</span>; count--)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于一开始的<code>count = 10</code>，当<code>count &gt; 0</code>时，重复做循环体，每一轮循环在做完循环体内语句后，使得<code>count--</code></p>
</li>
<li><p>做求和的程序时，记录结果变量初始化为0，而做求积变量时，记录结果变量初始化为1</p>
</li>
<li><p>循环的控制变量i是选择从0开始还是从1开始是判断<code>i &lt; n</code>还是判断<code>i &lt;= n</code>，对循环的次数，循环结束后变量的值都有影响。</p>
</li>
<li><p><code>for</code> &#x3D;&#x3D; <code>while</code></p>
</li>
<li><p><code>for(int i=1; i&lt;=n; i++)&#123;fact *= i&#125;</code></p>
<p>先<code>fact *= i</code>后<code>i++</code></p>
</li>
<li><p>固定次数 <code>for</code></p>
<p>必须执行一次 <code>do-while</code></p>
<p>其他情况 <code>while</code></p>
</li>
<li><p>省略循环的条件表示循环总是满足的</p>
</li>
</ul>
<h1 id="进一步判断与运算"><a href="#进一步判断与运算" class="headerlink" title="进一步判断与运算"></a>进一步判断与运算</h1><h2 id="逻辑类型和运算"><a href="#逻辑类型和运算" class="headerlink" title="逻辑类型和运算"></a>逻辑类型和运算</h2><ul>
<li><p>#include&lt;stdio.h&gt; 可用<code>bool</code>，<code>true</code>，<code>false</code></p>
</li>
<li><p>逻辑运算是对逻辑量进行的运算，结果只有0或1</p>
</li>
<li><p>逻辑量是关系运算或逻辑运算的结果</p>
</li>
<li><table>
<thead>
<tr>
<th>符号</th>
<th>逻辑关系</th>
<th>表达式</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>！</td>
<td>逻辑非</td>
<td>!a</td>
<td>a true 则  !a false</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>a &amp;&amp; b</td>
<td>a、b均true为true否则false</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
<td>a || b</td>
<td>a、b均false为false否则true</td>
</tr>
</tbody></table>
</li>
<li><p>x∈(4, 6)等价于<code>x &gt; 4 &amp;&amp; x &lt; 6</code></p>
</li>
<li><p>判断字符 c是否为大&#x2F;小写字母：<code>c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;</code></p>
</li>
<li><p>逻辑运算符优先级普遍低于比较运算符，单目运算符优先级高于双目运算符（<code>!age &lt; 20</code>代表0&#x2F;1与20比较）</p>
<ol>
<li>()													自左向右（结合性） </li>
<li>！	+ - 	++ 	–						自右向左（单目+或-）</li>
<li>* &#x2F; 	%</li>
<li>+ -</li>
<li>&lt; 	&lt;&#x3D; 	&gt;	 &gt;&#x3D;</li>
<li>&#x3D;&#x3D; 	!&#x3D;</li>
<li>&amp;&amp;</li>
<li>||</li>
<li>&#x3D; 	+&#x3D; 	-&#x3D;	*&#x3D; 	&#x2F;&#x3D;	 %&#x3D;  	自右向左（结合性）</li>
</ol>
</li>
<li><p>逻辑运算自左向右进行，如果左边结果可以决定运算结果，就不会做右边的计算（短路）</p>
<p><code>a == 6 &amp;&amp; b == 1</code> <code>a == 6 &amp;&amp; b += 1</code></p>
<p>对于&amp;&amp;：左边为false则右边不做；对于||：左边为true则不做右边</p>
<p><strong>不要把赋值，包括复合赋值组合进表达式</strong></p>
</li>
<li><p>条件运算符 <code>count = (count &gt; 20) ? count - 10 : count+10</code></p>
<p>表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(count &gt; <span class="number">20</span>)</span><br><span class="line">    count = count<span class="number">-10</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    count = count+<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>条件满足时的值和条件不满足时的值</p>
</li>
<li><p>“表达式”主要在for中使用，赋予不同变量值</p>
</li>
</ul>
<h2 id="级联和嵌套的判断"><a href="#级联和嵌套的判断" class="headerlink" title="级联和嵌套的判断"></a>级联和嵌套的判断</h2><ul>
<li><p>若<code>if</code>条件判断后语句仍为<code>if</code>或<code>if - else</code>语句，则为嵌套<code>if</code>语句</p>
</li>
<li><p><code>else</code>总是与<strong>最近</strong>的<code>if</code>匹配（<strong>大括号存在时可能特殊</strong>），在<code>if</code>或<code>else</code>后面总是用<code>&#123;&#125;</code></p>
</li>
<li><p>级联的<code>if- else if</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(exp1)</span><br><span class="line">    stl1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(exp2)</span><br><span class="line">    stl2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    stl3；</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="多路分支"><a href="#多路分支" class="headerlink" title="多路分支"></a>多路分支</h2><ul>
<li><p>switch - case</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">swich(控制表达式) &#123;          </span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 常量:  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">break</span>;                </span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 常量:   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量只能是<strong>整数型</strong>结果</p>
<ul>
<li><code>int type</code>（正确）</li>
<li><code>double type</code>（错误）</li>
</ul>
</li>
<li><p>常量可为常数，或常数计算表达式（编译知道结果）</p>
</li>
<li><p><code>switch</code>可视作跳转，若<code>case后无break</code>，则执行下一个<code>case</code>，<code>case</code>不会让语句停止</p>
</li>
</ul>
<h2 id="循环的例子"><a href="#循环的例子" class="headerlink" title="循环的例子"></a>循环的例子</h2><ul>
<li><p>计算之前先保存原始的值，后面可能有用</p>
</li>
<li><p>可以用模拟较少的循环次数来推断很大次数的循环</p>
</li>
<li><p>随机数<code>rand()</code>，得到一个随机的整数函数</p>
</li>
</ul>
<h2 id="判断和循环常见的错误"><a href="#判断和循环常见的错误" class="headerlink" title="判断和循环常见的错误"></a>判断和循环常见的错误</h2><p><code>if</code>常见错误：</p>
<ul>
<li><p>忘了<code>&#123;&#125;</code></p>
</li>
<li><p><code>if</code>后面错加<code>;</code></p>
</li>
<li><p>错误地使用<code>==</code>和<code>=</code></p>
</li>
<li><p>令人困惑的<code>else</code>：</p>
<ul>
<li><code>if</code>和<code>else</code>之后加大括号</li>
<li>大括号内语句缩进一个<code>tab</code></li>
</ul>
</li>
</ul>
<h1 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h1><h2 id="循环控制-1"><a href="#循环控制-1" class="headerlink" title="循环控制"></a>循环控制</h2><ul>
<li><p>循环中可用<code>break</code>跳出循环</p>
</li>
<li><p>循环中可用<code>continue</code>跳过循环这一轮剩下语句进入下一轮</p>
</li>
</ul>
<h2 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h2><ul>
<li><p>嵌套的循环：循环里面还是循环</p>
</li>
<li><p><code>break</code>和<code>continue</code>只能对它所在的那层循环做</p>
</li>
<li><p>接力<code>break</code></p>
</li>
<li><p><code>goto</code>：<code>goto xx(符号) -&gt; xx(同上符号):</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">again:</span><br><span class="line">      语句;</span><br><span class="line">    <span class="keyword">goto</span> again;<span class="comment">//again可以替换成其他的，这里不要求一定是again</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="循环应用"><a href="#循环应用" class="headerlink" title="循环应用"></a>循环应用</h2><h1 id="数组和函数"><a href="#数组和函数" class="headerlink" title="数组和函数"></a>数组和函数</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>数组是长度固定的数据结构，用来存放指定类型的数据，所有数据的类型都相同</p>
</li>
<li><p>&lt;类型&gt;变量名称[元素类型];</p>
<p><code> int  grades  [100]</code>;  <code>double weight [20]</code>;</p>
</li>
<li><p>元素数量必须是整数；C99之前，元素数量必须是编译时刻确定的字面量</p>
</li>
<li><p>数组是一种容器：</p>
<ul>
<li><p>类型相同</p>
</li>
<li><p>一旦创建，不可改变大小</p>
</li>
<li><p>数组元素在内存中是连续依次排列的</p>
<p><code>int a[10]</code>: <code>a[0]</code>, <code>a[1]</code>, <code>a[2]</code>, … <code>a[9]</code>（10个单元）</p>
</li>
</ul>
</li>
<li><p>可以在赋值左边或右边</p>
</li>
<li><p>使用数组时放在<code>[]</code>中的数字叫下边或索引，下标从0开始计数</p>
<p><code>a[100]</code> →0~99</p>
</li>
<li><p>编译器不会检查数组是否越界，但运用到程序中可能会崩溃</p>
</li>
<li><p>长度为0的数组：<code>int a[0]</code>; 可以存在但无用</p>
</li>
</ul>
<h2 id="函数的定义和使用"><a href="#函数的定义和使用" class="headerlink" title="函数的定义和使用"></a>函数的定义和使用</h2><ul>
<li><p>函数是一块代码，接受0个或多个参数，做一件事情，并返回一个或零个值</p>
</li>
<li><p>函数头 {函数体}</p>
<p><code>void + sum(int begin, int end)</code></p>
<p>返回类型  函数名  参数表（类型+名字）</p>
</li>
<li><p>调用函数 函数名<strong>（</strong>参数值<strong>）</strong> （即使不给参数依然需要<strong>（ ）</strong>），若有参数则需要正确数量和顺序</p>
</li>
<li><p><code>return</code> 停止函数的执行，并返回一个值</p>
<p><code>return；</code></p>
<p><code>return 表达式；</code></p>
</li>
<li><p>没有返回值的函数：</p>
<ul>
<li><code>void</code>函数名（参数表）</li>
<li>不能使用（无）<code>return</code></li>
<li>不能做返回值的赋值</li>
</ul>
</li>
</ul>
<h2 id="函数的参数和变量"><a href="#函数的参数和变量" class="headerlink" title="函数的参数和变量"></a>函数的参数和变量</h2><ul>
<li><p>在看到<code>sum(1, 10)</code>，它需要知道<code>sum()</code>的样子以检查对<code>sum()</code>的使用是否正确（C的编译器自上而下分析代码）</p>
</li>
<li><p>函数头()；（函数声明（函数原型）可用来判断函数的调用是否正确）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数头()（编译器会再次检查调用是否正确）（<strong>实际函数头</strong>）</p>
</li>
<li><p>调用函数必须传递给它数量、类型正确的值</p>
<p>字面量，变量，函数的返回值，计算结果</p>
</li>
<li><p>调用函数时给的值与参数的类型不匹配是C语言系统上最大的漏洞,编译器总是自己转换，但可能会产生错误 C++&#x2F;java却避免了</p>
</li>
<li><p>C语言在调用函数，永远只传值给函数</p>
</li>
<li><p>传值：每个函数有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系（<code>int main()</code>后a和b与调用函数中a和b无关系）</p>
</li>
<li><p>过去称函数参数表中的参数为形式参数，调用函数时给的值叫实际参数。但现代不再适用。现代称前者为参数，后者为值。</p>
</li>
<li><p>定义在函数内部的变量就是本地变量。参数也是本地变量。</p>
</li>
<li><p>生存期：变量出现的时间与消亡的时间。</p>
</li>
<li><p>作用域：在代码的什么范围内可以访问这个变量（变量起作用）对于本地变量这两个问题的答案是<code>&#123;&#125;</code>（块）</p>
</li>
<li><p>本地变量定义在块内，可以是函数块内，也可以是语句块内。程序进入块之前，变量不存在，离开这个块，其中的变量就消失了。</p>
</li>
<li><p>块外面定义变量在块里面依然有效，反之无效</p>
</li>
<li><p>若块里面定义了和外面同名的变量则掩盖了外面的，但不能在一个块内定义同名变量</p>
</li>
<li><p>本地变量不会被默认初始化，参数在进入函数时被初始化了</p>
</li>
<li><p>传统C中，<code>void f()</code> -&gt; 不代表无参数，表示f函数参数未知，当无参数时，最好写<code>void f(void)</code></p>
</li>
<li><p>C语言不允许函数嵌套定义</p>
</li>
</ul>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><ul>
<li><p><code>int a[3][5]</code>3行5列矩阵</p>
</li>
<li><p><code>a[i][j]</code>表示一个<code>int</code>，是i行j列上的单元</p>
</li>
<li><p>二维数组的初始化</p>
<ul>
<li>列必须给出，行数可由编译器数</li>
<li>每行一个<code>&#123;&#125;</code>，逗号分隔</li>
<li>如果省略表示补零</li>
<li>也可以用定位（C99only）</li>
</ul>
</li>
</ul>
<h1 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h1><h2 id="数组运算-1"><a href="#数组运算-1" class="headerlink" title="数组运算"></a>数组运算</h2><ul>
<li><p>数组的集成初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不需要给出数组大小，编译器替我们数</p>
</li>
<li><p>集成初始化的定位（C99only）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; [<span class="number">0</span>] = <span class="number">2</span>, [<span class="number">2</span>] = <span class="number">3</span>, <span class="number">6</span> &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>用<code>[n]</code>在初始化数据中给出定位</li>
<li>没有定位的数据接在前面的位置后面</li>
<li>其他位置补0</li>
<li>特别适合初始数据稀疏的数组</li>
</ul>
</li>
<li><p><code>sizeof</code>：给出整个数组所占据的内容的大小，单位是字节</p>
</li>
<li><p><code>sizeof(a) / sizeof(a[0])</code>为数组元素个数</p>
</li>
<li><p><strong>要把一个数组所有元素交给另一个数组，必须采用遍历</strong></p>
</li>
<li><p>遍历数组作为函数参数时：</p>
<ul>
<li>不能在<code>[]</code>中给出数组大小</li>
<li>不能利用<code>sizeof</code>来计算数组元素个数</li>
</ul>
</li>
</ul>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul>
<li><p>在一个数组中找到某个数的位置（确认是否存在）</p>
</li>
<li><p>基本方法：遍历</p>
</li>
<li><p>二分搜索</p>
</li>
</ul>
<h1 id="指针与字符串"><a href="#指针与字符串" class="headerlink" title="指针与字符串"></a>指针与字符串</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul>
<li><p><code>sizeof</code>：运算符，给出某个类型或变量在内存中所占据的字节数<code>sizeof(int)</code>；<code>sizeof(i)</code></p>
</li>
<li><p>&amp;：运算符，获得变量的地址，它的操作必须是<strong>变量</strong></p>
</li>
<li><p>地址的大小是否与int相同取决于编译器</p>
</li>
<li><p>指针：就是保存地址的变量 <code>int *p=&amp;i</code></p>
<p><code>int* p, q</code>和<code>int *p, q</code>都代表<code>p</code>为指针，<code>q</code>为<code>int</code></p>
</li>
<li><p>普通变量的值是实际的值；指针变量的值是具有实际值的变量的地址</p>
</li>
<li><p><code>void f(int *p)</code>；在被调用时得到了某个变量的地址，在函数里面可以通过这个指针访问外面这个<code>i</code></p>
</li>
<li><p><code>*</code>是单目运算符，用来访问指针的值所表示的地址上的变量，可以做左值也可以做右值</p>
</li>
<li><p>函数参数表中的数组实际上是指针，<code>sizeof(a) == sizeof(int*)</code>，但是可以用数组的运算符<code>[]</code>进行计算</p>
</li>
<li><p>参数表中以下四种函数原型是等价的：</p>
<ul>
<li><code>int sum(int *arr, int n)</code></li>
<li><code>int sum(int *, int)</code></li>
<li><code>int sum(int arr[], int n)</code></li>
<li><code>int sum(int[ ], int)</code></li>
</ul>
</li>
<li><p>数组变量是特殊的指针，数组变量本身表达地址，（<code>int a[10]</code>; <code>int *p = a</code>;无需用&amp;取地址）</p>
</li>
<li><p>但是数组的单元表达的是变量，需要用&amp;取地址，<code>a == &amp;a[0]</code></p>
</li>
<li><p><code>[]</code>运算符可以对数组做，也可以对指针做：<code>p[0]</code>等价于<code>a[0]</code></p>
</li>
<li><p><code>*</code>可以对指针做，也可以对数组做</p>
</li>
<li><p>数组变量是<code>const</code>的指针，所以不能被赋值（<code>int a[ ] =</code> 等价于<code>int *const a =</code>）</p>
</li>
</ul>
<h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><ul>
<li><p><code>char</code>是一种整数，也是一种特殊的类型字符。</p>
</li>
<li><p>用单引号表示的字符字面量：<code>&#39;a&#39;</code>，<code>&#39;1&#39;</code>，<code>&#39;&#39;</code>也是一个字符，<code>printf</code>和<code>scanf</code>里用<code>%c</code>来输出输入字符。</p>
</li>
<li><p>大小写转换：<code>&#39;a&#39; - &#39;A&#39;</code>得到<code>a</code>和<code>A</code>在<code>ASCII</code>上的距离，<code>a + &#39;a&#39; - &#39;A&#39;</code>可以将大写字母变为小写字母，而<code>a + &#39;A&#39; - &#39;a&#39;</code>可以将小写字母变为大写字母</p>
</li>
<li><p>逃逸字符：用来表达无法印出来的控制字符或特殊字符，它由一个反斜杠<code>\</code>开头，后面跟上另一个字符，这两个字符合起来，组成一个字符。</p>
</li>
<li><blockquote>
<p><code>\b</code>:回退一格</p>
<p><code>\t</code>：到下一个表格位</p>
<p><code>\n</code>:换行</p>
<p><code>\r</code>:回车</p>
<p><code>\&quot;</code>：双引号</p>
<p><code>\&#39;</code>：单引号</p>
<p><code>\\</code>：反斜杠本身</p>
</blockquote>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>字符串是以<code>\0</code>结尾的一串字符</p>
</li>
<li><p><code>0</code>或<code>\0</code>相同，但和<code>&#39;0&#39;</code>不同，0标志字符串的结束，但它不是字符串的一部分，计算字符串长度的时候不包括这个<code>0</code></p>
</li>
<li><p>字符串以数组的形式存在，以数组或指针的形式访问，更多以指针形式</p>
</li>
<li><p><code>string.h</code>里有很多处理字符串的函数</p>
</li>
<li><p>字符串变量：<code>char *str = &quot;Hello&quot;</code>; <code>char word[] = &quot;Hello&quot;</code>; <code>char line[10] = &quot;Hello&quot;</code></p>
</li>
<li><p>字符串常量：<code>&quot;Hello&quot;</code>，会被编译器编程一个字符数组放在某处，这个数组的长度是6（<strong>结尾还有表示结束的0</strong>）</p>
</li>
<li><p>两个相邻的字符串常量会被自动连接起来</p>
</li>
<li><p>C语言的字符串是以字符数组的形态存在的，不能用运算符对字符串做运算，通过数组的方式可以遍历字符串，唯一特殊的地方是字符串字面量可以用来初始化字符数组</p>
</li>
<li><p>如果要构造一个字符串-&gt;数组；</p>
<p>如果要处理一个字符串-&gt;指针</p>
</li>
<li><p>字符串可以表达为<code>char*</code>的形式，<code>char*</code>不一定是字符串，只有它所指的字符数组有结尾的0；才能说它所指的是字符串</p>
</li>
</ul>
<h2 id="字符串的计算"><a href="#字符串的计算" class="headerlink" title="字符串的计算"></a>字符串的计算</h2><ul>
<li><p>并没有产生新的字符串，只是让指针s指向了t所指的字符串，对s的任何操作就是对t做的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *t = <span class="string">&quot;title&quot;</span>;</span><br><span class="line"><span class="type">char</span> *s;</span><br><span class="line">s = t;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>scanf(“%7s”, string)</code>；在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的长度小</p>
</li>
<li><p><code>string.h</code>:</p>
<ul>
<li><code>strlen</code>：返回s的字符串长度（不包括结尾的\0）</li>
<li><code>strcmp</code>：比较两个字符串，返回：0：<code>s1 == s2</code>；正差值：<code>s1 &gt; s2</code>；负差值：<code>s1 &lt; s2</code></li>
<li><code>strcpy</code>：把第二个参数的字符串拷贝到第一个空间；<code>restrict</code>表明两个字符串不重叠（C99），返回第一个参数</li>
<li><code>strcat</code>：把第二个参数的字符串接到第一个参数的后面去接成一个长的字符串</li>
<li><code>strchr</code>：从字符串左边找字符；<code>strrchr</code>：从字符串右边找字符。返回<code>NULL</code>表示没有找到。</li>
</ul>
</li>
</ul>
<h1 id="指针与字符串（进阶）"><a href="#指针与字符串（进阶）" class="headerlink" title="指针与字符串（进阶）"></a>指针与字符串（进阶）</h1><h2 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h2><ul>
<li><p>比如：交换两个变量的值</p>
</li>
<li><p>函数返回多个值，某些值就只能通过指针返回，传入的参数实际上是需要保存带回的结果的变量</p>
</li>
<li><p>函数返回应用的状态，结果通过指针返回</p>
</li>
<li><p><strong>常见错误：</strong>定义了指针变量，还没有指向任何变量，就开始使用指针</p>
</li>
<li><p>函数参数表中的数组实际上是指针，<code>sizeof(a)== sizeof(int*)</code>，但是可 以用数组的运算符<code>[]</code>进行计算</p>
</li>
<li><p>数组变量是特殊的指针，数组变量本身表达地址，（<code>int a[10]</code>;<code>int *p = a</code>;）无需用&amp;取地址）</p>
</li>
<li><p><code>[]</code>运算符可以对数组做，也可以对指针做：<code>p[0]</code>等价于<code>a[0]</code> ，<code>*</code>可以对指针做，也可以对数组做</p>
</li>
<li><p>数组变量是<code>const</code>的指针，所以不能被赋值（<code>int a[]=</code>等价于int *const a&#x3D;）</p>
</li>
<li><p>指针是<code>const</code>：不能指向其他变量（声明时<code>*</code>在<code>const</code>前）</p>
<p>指针所指是<code>const</code>：不能通过指针修改变量（声明时<code>*</code>在<code>const</code>后）</p>
<p><code>const</code>数组：数组每个单元都是<code>const int</code>，必须通过初始化赋值</p>
</li>
</ul>
<h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><ul>
<li><p>指针加1表示指针指向下一个变量（地址加<code>sizeof(指针指向类型)</code>）</p>
</li>
<li><p>如果指针不是指向一片连续分布空间（如数组），“加1”运算毫无意义</p>
</li>
<li><p>指针计算：加减整数（+，+&#x3D;，-，-&#x3D;）；递增递减（++, –）；两个指针相减（结果为<code>地址差值/sizeof(指针指向类型)</code>）</p>
</li>
<li><p><code>*p++</code>：<strong>取出p所指的数据，再将p指向下一位置</strong>，++的优先级高于*，常用于数组类的连续空间操作，在某些CPU上可以直接被翻译成汇编指令</p>
</li>
<li><p>指针比较：比较在内存中的地址，数组中单元的地址递增排列</p>
</li>
<li><p>0地址：用NULL表示，不代表数值0</p>
</li>
<li><p>所有指针大小相同，指向不同类型指针无法赋值</p>
</li>
<li><p><code>void*</code>：不知道指向什么东西的指针，计算时与<code>char*</code>相同（但不相通）</p>
</li>
<li><p>指针的类型转换：<code>int *p = &amp;i</code>；<code>void *q = (void*)p</code>（<code>p</code>所指变量类型为<code>int</code>，但从<code>q</code>看所指变量类型未知）</p>
</li>
<li><p>指针的用处：</p>
<ul>
<li>需要传入较大的数据作参数</li>
<li>传入数组后对数组操作</li>
<li>函数返回不止一个结果</li>
<li>需要用函数修改不止一个变量</li>
<li>动态申请的内存</li>
</ul>
</li>
<li><p>动态内存分配：<code>malloc</code>函数（<code>&lt;stdlib.h&gt;</code>），申请以字节为单位的空间，返回的类型是</p>
<p><code>void* ( (int*)malloc(n*sizeof(int)))</code>结束后<code>free()</code>；申请失败则返回0（NULL）</p>
</li>
<li><p><code>free()</code>归还申请的空间给“系统”，只能还申请来的空间的首地址</p>
</li>
<li><p>申请了没<code>free</code>，长时间运行内存逐渐下降</p>
</li>
</ul>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><ul>
<li><p><code>putchar</code>：向标准输出写一个字符，返回输出了几个字符（<code>int</code>），<code>EOF</code>表示写失败</p>
</li>
<li><p><code>getchar</code>：从标准输入读入一个字符，返回类型是int是为了返回<code>EOF</code></p>
</li>
<li><p><code>char **a</code> ：a是指针，指向一个指向字符的指针</p>
</li>
<li><p><code>char[ ][n]</code> !&#x3D; <code>char *a[ ]</code></p>
</li>
</ul>
<h1 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul>
<li><p>定义：用户定义的数据类型，用关键字<code>enum</code>来声明<code>enum</code>枚举类型名字{名字0，…，名字n}；</p>
</li>
<li><p>枚举类型名字未必真的使用，要用的是大括号里面的名字，因为他们就是常量符号，类型为<code>int</code>，值从0到n</p>
</li>
<li><p>枚举量可以作为值，枚举类型可以跟上<code>enum</code>作为类型，实际上是以整数做内部计算和外部输入输出</p>
</li>
<li><p>枚举最后可以加<code>number</code>来代表代表枚举个数，方便遍历</p>
</li>
<li><p>枚举类型很少当做类型使用，排比有意义的名字比<code>const int</code>好用，枚举比宏好，因为枚举有<code>int</code>类型</p>
</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><p>定义：复合数据类型，包含多种类型，用一个变量表示</p>
</li>
<li><p>和本地变量一样，在函数内部声明的结构类型只能在函数内部使用</p>
</li>
<li><p><code>p1</code>和<code>p2</code>都是<code>point</code>里面有<code>x</code>和<code>y</code>的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1, p2;<span class="comment">//（注意分号）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>p1</code>和<code>p2</code>是一种无名结构，里面有<code>x</code>和<code>y</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1, p2;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>p1</code>和<code>p2</code>都是<code>point</code>里面有<code>x</code>和<code>y</code>的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1, p2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p1</span>,<span class="title">p2</span>;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结构用<code>.</code>运算符和名字访问其成员<code>p1.x</code></p>
</li>
<li><blockquote>
<p>对于整个结构，可以做赋值、取地址，也可以传值给函数参数 </p>
<p>p1 &#x3D; p2等价于p1.x&#x3D;p2.x，p1.y &#x3D; p2.y<strong>（数组不可以）</strong></p>
<p>p1 &#x3D; (struct point){5,10}等价于p1.x &#x3D; 5，p1.y &#x3D; 10</p>
</blockquote>
</li>
<li><p>和数组不同，结构变量的名字并不是结构变量的地址，必须用<code>&amp;</code>运算符</p>
</li>
<li><p>整个结构可以作为参数的值传入函数，在函数内新建一个结构变量，并复制调用者的结构的值，也可以返回一个结构（与数组完全不同）</p>
</li>
<li><p>用<code>-&gt;</code>表示指针所指的结构变量中的成员 <code>p-&gt;y = 10</code></p>
</li>
<li><p>结构数组：</p>
<p><code>struct date arr[100]</code>;</p>
</li>
</ul>
<p>​     <code>struct date arr[] = &#123; &#123; 4,52005 &#125;, &#123; 2,4,2005 &#125; &#125;</code>;</p>
<ul>
<li>结构中的变量也可以是结构</li>
</ul>
<h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><ul>
<li><p>自定义数据类型：<code>typedef</code>，声明一个已有的数据类型的新名字<code>typedef int Length</code>;使得<code>Length</code>成为<code>int</code>的别名<code>Length a</code>；等价于<code>int a</code>；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> x, y</span><br><span class="line"></span><br><span class="line">&#125;Date;<span class="comment">//表示Date可代替struct point</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义：<code>union</code>，所有成员共享一个空间，同一时间只有一个成员是有效的，union的大小是其最大的成员</p>
</li>
</ul>
<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><ul>
<li><p>定义：定义在函数外面的变量，具有全局的生存期和作用域，与任何函数无关，在任何函数内部都可以使用它们。</p>
</li>
<li><p>没有做初始化的全局变量会得到0值，指针会得到NULL，只能用编译时刻确定值来初始化全局变量，它们的初始化发生在<code>main</code>函数之前</p>
</li>
<li><p>在本地变量定义时加上<code>static</code>修饰就成为静态本地变量，当函数离开时，静态本地变量会继续存在并保存其值，静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数会保持上次离开时的值</p>
</li>
<li><p>静态本地变量实际是全局变量，它们位于相同的内存区域，它具有全局的生存期，函数内的局部作用域，<code>static</code>此处意为局部作用域（本地可访问）</p>
</li>
<li><p>返回本地变量的指针是危险的，返回全局变量或静态本地变量的指针是安全的，返回在函数内<code>malloc</code>的内存是安全的，但容易造成问题，最好的做法是返回传入的指针</p>
</li>
<li><p>不要使用全局变量在函数间传递参数和结果，尽量避免使用全局变量，使用全局变量和静态本地变量的函数是线程不安全的</p>
</li>
</ul>
<h2 id="编译预处理和宏"><a href="#编译预处理和宏" class="headerlink" title="编译预处理和宏"></a>编译预处理和宏</h2><ul>
<li><p><code>#</code>开头的是编译预处理指令，他们不是C的成分，但C语言离不开叫他们，<code>#define</code>用来定义一个宏</p>
</li>
<li><p><code>#define &lt;名字&gt;&lt;值&gt;</code> 注意结尾没有分号，名字必须是一个单词，值可以是各种东西，在C语言编译器编译之前，编译预处理程序（cpp）会把程序中的名字换成值</p>
</li>
<li><p>若宏中出现其他宏的名字，也是会被替换的，若一个宏的值超过一行，最后一行之前的行末需要加<code>\</code>，宏值后出现的注释不会被当做宏值的一部分</p>
</li>
<li><p>没有值的宏：<code>#define_DEBUG</code>，条件编译，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了</p>
</li>
<li><p>预定义的宏：<code>__LINE__</code>（源代码文件行号）；<code>__FILE__</code>（文件名）；<code>__DATE__</code>（编译日期）；<code>__TIME__</code>（编译时间）；<code>__STDC__</code>（如果编译器遵循ANSI C，其值为1，否则未定义 ）</p>
</li>
<li><p>像函数的宏：<code>#define cude(x) ((x)*(x)*(x))</code>，宏可以带参数，<strong>一切都要带括号</strong>，整个值要括号，参数出现的每个地方都要括号，也可以带多个参数，也可以组合（嵌套）使用其他宏</p>
</li>
<li><p>部分宏会被<code>inline</code>函数替代</p>
</li>
</ul>
<h2 id="大程序文件"><a href="#大程序文件" class="headerlink" title="大程序文件"></a>大程序文件</h2><ul>
<li><p>一个<code>.c</code>文件是一个编译单元，编译器每次只处理一个编译单元</p>
</li>
<li><p>把函数原型放进一个头文件当中（以<code>.h</code>结尾）中，在需要调用这个函数的源代码文件（<code>.c</code>文件）中<code>#include</code>这个头文件，就能让编译器在编译的时候知道函数的原型</p>
</li>
<li><p><code>#include</code>把那个文件的全部文本内容原封不动地插入到它所在的地方</p>
</li>
<li><p><code>#include“ ” </code>要求编译器首先在当前目录（<code>.c</code>所在的目录）寻找这个文件，如果没有，到编译器指定的目录去找。</p>
</li>
<li><p><code>#include&lt; &gt;</code>让编译器只在指定的目录去找</p>
</li>
<li><p>环境变量和编译器命令行参也可以指定寻找头文件的目录</p>
</li>
<li><p><code>#include</code>不是用来引入库的</p>
</li>
<li><p>在使用和定义这个函数的地方都应该<code>#include</code>这个头文件</p>
</li>
<li><p>一般的做法任何<code>.c</code>都有对应的同名<code>.h</code>，把所有对外公布的函数的原型和全局变量的声明都放进去</p>
</li>
<li><p>在函数前面加上<code>static</code>使得它成为只能在所在的编译单元中使用的函数</p>
</li>
<li><p>在全局变量前面加上<code>static</code>就使得它成为只能在所在的编译单元中被使用的全局变量</p>
</li>
<li><p><code>int i</code>; <code>extern int i</code>; 是变量的声明</p>
</li>
<li><p>声明是不产生代码的东西：函数原型；变量声明；结构声明；宏声明；枚举声明；类型声明；<code>inline</code>函数，定义是产生代码的东西：函数；全局变量</p>
</li>
<li><p>只有声明可以放在头文件当中否则会造成一个项目中多个编译单元有重名的实体，某些编译器允许几个编译单元中存在同名的函数或者用<code>weak</code>修饰符来强调这种存在。</p>
</li>
<li><p>同一个编译单元里同名的结构不能被重复声明，如果你的头文件里有结构的声明，很难这个头文件不会在一个编译单元里被<code>#include</code>多次</p>
</li>
<li><p>标准头文件结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LIST_HEAD__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LIST_HEAD__</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p> <code>#pragmam once</code>也能起到相同作用，但不是所有编译器都支持</p>
</li>
</ul>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h2><ul>
<li><p>格式化的输出：<code>%[flags][width][.prec][hlL]type</code></p>
<ul>
<li><code>flag</code><ul>
<li>- 左对齐</li>
<li>+：在前面放+或-</li>
<li>(space)：正数留空</li>
<li>0：0填充</li>
</ul>
</li>
<li><code>width</code>或<code>prec</code>：<ul>
<li><code>number</code>：最小字符数</li>
<li><code>*</code>：下一个参数是字符数</li>
<li><code>.number</code>：小数点后位数</li>
<li><code>.*</code>：下一个参数是小数点后位数</li>
</ul>
</li>
<li><code>hlL</code>（类型修饰）：<ul>
<li><code>hh</code>：单个字节</li>
<li><code>h</code>：short</li>
<li><code>l</code>：long</li>
<li><code>ll</code>：long long</li>
<li><code>L</code>：long double</li>
</ul>
</li>
</ul>
</li>
<li><p><code>%n</code>：读入或写入的个数</p>
</li>
<li><p>格式化输入：<code>%[flag]type</code></p>
</li>
<li><p><code>flag</code>：</p>
<ul>
<li><code>*</code>：跳过</li>
<li>数字：最大字符数；</li>
<li><code>hh</code>：<code>char</code>；<code>h</code>；<code>l</code>；<code>ll</code>；<code>L</code></li>
</ul>
</li>
<li><p><code>type</code>：[…]：所允许的字符</p>
</li>
<li><p><code>printf</code>和<code>scanf</code>的返回值是读入和输出的返回值</p>
</li>
<li><p>用<code>&gt;</code>和<code>&lt;</code>做重定向，<code>&lt;</code>指定输入，<code>&gt;</code>指定输出</p>
</li>
<li><p>打开文件的标准代码 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* fp=fope(“file”,”r”);</span><br><span class="line"><span class="keyword">if</span>(fp) &#123;</span><br><span class="line">	<span class="built_in">scanf</span>(fp,...);</span><br><span class="line">	fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>fopen</code>：</p>
<ul>
<li><code>r</code>：打开只读</li>
<li><code>r+</code>：打开读写，从文件头开始</li>
<li><code>w</code>：打开只写，如果不存在则新建，如果存在则清空</li>
<li><code>w+</code>：打开读写，如果不存在则新建，如果存在则清空</li>
<li><code>a</code>：打开追加，如果不存在则新建，如果存在则从文件尾开始</li>
<li><code>...x</code>（…加x结尾）：只新建，如果文件已新建则不能打开</li>
</ul>
</li>
<li><p>所有的文件最终都是二进制的，文本文件是用最简单的方法可以读写的文件，而二进制文件是需要专门的程序来读写的文件，文本文件的输入输出是格式化，可能经过转码</p>
</li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul>
<li><p>按位运算：</p>
<ul>
<li><code>&amp;</code>按位的与</li>
<li><code>|</code>按位的或</li>
<li><code>~</code>按位取反</li>
<li><code>^</code>按位的异或</li>
<li><code>&lt;&lt;</code>左移；</li>
<li><code>&gt;&gt;</code>右移</li>
</ul>
</li>
<li><p><code>&amp;</code>按位的与：二进制中若两个位对应均为1，则取&amp;结果为1，否则为0，</p>
<ul>
<li>让某一位或某些位为0：<code>x &amp; 0xFE</code>；</li>
<li>取一个数中间的一段：<code>x &amp; 0xFF</code></li>
</ul>
</li>
<li><p><code>|</code>按位的或：二进制中若两个位有1则|结果为1，否则为0</p>
</li>
<li><p><code>~</code>按位取反：把二进制数各位0变为1,1变为0</p>
</li>
<li><p>按位异或<code>^</code>：若两个位相等，则结果为1，不相等则为0</p>
</li>
<li><p><code>&lt;&lt;</code>左移：<code>i &lt;&lt; j</code>：i中所有的位向左移动j个位置，而右边填入0，所有小于<code>int</code>的类型，移位以<code>int</code>的方式来做，结果是int</p>
<p><code>x &lt;&lt;= 1</code>等价于<code>x *= 2</code>，<code>x &lt;&lt; n</code>等价于<code>x *= n * 2</code></p>
</li>
<li><p><code>&gt;&gt;</code>右移：i&gt;&gt;j：i中所有的位向右移动j个位置，而左边填入0，所有小于<code>int</code>的类型，移位以<code>int</code>的方式来做，结果是<code>int</code>，对于<code>unsigned</code>类型，左边填0，对于<code>signed</code>类型，左边填入原来的最高位（<strong>保持符号不变</strong>）</p>
<p><code>x &gt;&gt;= 1</code>等价于<code>x /= 2</code>，<code>x&gt;&gt;n</code>等价于<code>x /= 2 * n</code></p>
</li>
<li><p>可以认为逻辑运算相当于把所以非0值变成1，然后做按位运算</p>
</li>
<li><p>位段：把一个<code>int</code>的若干位组合成一个结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> leading : <span class="number">3</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> FLAG1 : <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> FLAG2 : <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> trailing : <span class="number">11</span>;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以直接用位段的成员名称来访问，比移位、与、或还方便，编译器会安排其中位的排列，不具有可移植性，当所需的位超过一个<code>int</code>时会采用多个<code>int</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>Python基本语法</title>
    <url>/2023/05/15/Python%E5%AD%A6%E4%B9%A0/Python%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h1><ul>
<li><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">加</td>
<td></td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减</td>
<td></td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘</td>
<td></td>
</tr>
<tr>
<td align="center">&#x2F;</td>
<td align="center">除</td>
<td>9 &#x2F; 2 &#x3D; 4.5</td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F;</td>
<td align="center">取整除</td>
<td>9 &#x2F;&#x2F; 2 &#x3D; 4</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">取余数</td>
<td>9 % 2 &#x3D; 1</td>
</tr>
<tr>
<td align="center">**</td>
<td align="center">幂</td>
<td>2 ** 3 &#x3D; 8</td>
</tr>
</tbody></table>
</li>
<li><p>在Python中<code>*</code>还可以用于字符串，计算结果就是字符串重复指定次数的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [1]:&quot;-&quot; * 5</span><br><span class="line">Out[1]&quot;-----&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><ul>
<li><p>数字型</p>
<ul>
<li><p>整型 int</p>
</li>
<li><p>浮点型 float</p>
</li>
<li><p>布尔型 bool</p>
</li>
<li><p>True</p>
</li>
<li><p>False</p>
</li>
<li><p>复数型 complex</p>
</li>
<li><p>主要用于科学计算，例如：平面场问题、波动问题、电容电感等问题</p>
</li>
</ul>
</li>
<li><p>非数字型</p>
<ul>
<li>字符串</li>
<li>列表</li>
<li>元组</li>
<li>字典</li>
</ul>
</li>
<li><p>提示：在Python2.x中，整数还可分为<code>int</code>和<code>long</code></p>
</li>
<li><p>使用<code>type</code>函数可以查看一个变量类型</p>
<ul>
<li>In [1]: type(name)</li>
</ul>
</li>
<li><blockquote>
<p>字符串之间可以用<code>+</code>进行拼接</p>
<p>字符串可以和整数使用*重复拼接相同的字符串</p>
<p>数字型变量和字符串之间不能进行其他运算</p>
</blockquote>
</li>
</ul>
<h1 id="变量的输入和输出"><a href="#变量的输入和输出" class="headerlink" title="变量的输入和输出"></a>变量的输入和输出</h1><ul>
<li><p><code>input()</code></p>
<ul>
<li><code>字符串变量 = input(&quot;提示信息：&quot;)</code></li>
<li><code>input()</code>输入的内容都认为是一个字符串</li>
</ul>
</li>
<li><p>类型转换函数</p>
<ul>
<li><code>int(x)</code>将x转换为一个整数</li>
<li><code>float(x)</code>将x装换为一个浮点数</li>
</ul>
</li>
<li><p>变量的格式化输出</p>
<ul>
<li><table>
<thead>
<tr>
<th>格式化字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%d</td>
<td>有符号十进制整数，<code>%06</code>表示输出的整数显示6位数，不足的地方用0补全</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数，<code>%.02f</code>表示小数点后只显示两位</td>
</tr>
<tr>
<td>%%</td>
<td>输出%</td>
</tr>
</tbody></table>
</li>
<li><p><code>print(&quot;Name:%s,Age:%d&quot;% (name, age))</code>，<code>name</code>变量中为姓名信息，<code>age</code>变量中为年龄信息</p>
</li>
<li><p><code>print(&quot;abc&quot;, end = &quot;a&quot;)</code>在默认情况下，print输出后会自动在末尾添加换行，利用end可用end内容替代换行</p>
</li>
<li><p><code>print(&quot;&quot;)</code>在一行输出后添加换行</p>
</li>
</ul>
</li>
</ul>
<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><ul>
<li><table>
<thead>
<tr>
<th>转义字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\\</td>
<td>反斜杠符号</td>
</tr>
<tr>
<td>\&#96;</td>
<td>单引号</td>
</tr>
<tr>
<td>\\“</td>
<td>双引号</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\t</td>
<td>横向制表符</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="函数的基本使用"><a href="#函数的基本使用" class="headerlink" title="函数的基本使用"></a>函数的基本使用</h1><ul>
<li><p>函数的定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>():</span><br><span class="line">    <span class="comment"># 函数内容</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义的函数只有被调用才会执行</p>
</li>
</ul>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><ul>
<li>每一个以扩展名<code>.py</code>为结尾的python源文件都是一个模块</li>
<li>导入模块需要<code>import</code></li>
<li>模块名也是标识符，需要遵循标识符命名规则</li>
<li><code>.pyc</code>表示编译过文件</li>
</ul>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ul>
<li><p>查看列表<code>List</code>能使用的功能</p>
<ul>
<li>在ipython3中操作：</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [1]:name_list.(+tab键)</span><br><span class="line">name_list.append  name_list.count等等</span><br></pre></td></tr></table></figure>

<ul>
<li><table>
<thead>
<tr>
<th>序号</th>
<th>分类</th>
<th>关键字&#x2F;函数&#x2F;方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>增加</td>
<td>列表.insert(索引,数据)</td>
<td>在指定位置插入数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.append(数据)</td>
<td>在末尾追加数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.extend(列表2)</td>
<td>将列表2的数据追加到列表</td>
</tr>
<tr>
<td>2</td>
<td>修改</td>
<td>列表[索引] &#x3D; 数据</td>
<td>修改指定索引的数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>del 列表[索引]</td>
<td>删除指定索引的数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.remove(数据)</td>
<td>删除第一个出现的指定数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.pop</td>
<td>删除末尾数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.pop(索引)</td>
<td>删除指定索引数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.clear</td>
<td>情空列表</td>
</tr>
<tr>
<td>4</td>
<td>统计</td>
<td>len(列表)</td>
<td>列表长度</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.count(数据)</td>
<td>数据在列表中出现次数</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.index(数据)</td>
<td>返回数据索引</td>
</tr>
<tr>
<td>5</td>
<td>排序</td>
<td>列表.sort()</td>
<td>升序排序</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.sort(reverse&#x3D;True)</td>
<td>降序排序</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.reverse()</td>
<td>逆转，反转</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>使用<code>del</code>关键字可以从内存中删除变量</p>
</li>
<li><p>关键字后面不需要使用括号，函数需要</p>
</li>
<li><p>迭代循环<code>for num in nums</code></p>
</li>
<li><p>列表中可以存储不同类型数据</p>
</li>
</ul>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><ul>
<li><p><code>Tuple</code>与列表类似，不同之处在于元组的元素不能修改</p>
<ul>
<li>元组表示多个元素组成的序列</li>
<li>元组在<code>Python</code>开发中有特定的应用场景</li>
</ul>
</li>
<li><p>用于存储一串信息，数据之间使用<code>,</code>分隔</p>
</li>
<li><p>元组用<code>()</code>定义</p>
</li>
<li><p>元组的索引从0开始</p>
</li>
<li><p>创建空元组<code>()</code></p>
</li>
<li><p>查看元组能使用的功能方法如列表</p>
</li>
<li><p>可用<code>for in</code>遍历元组</p>
</li>
<li><p>应用场景</p>
<ul>
<li>函数的参数和返回值</li>
<li>格式化字符串</li>
<li>让列表不可被修改，以保护列表安全</li>
</ul>
</li>
<li><blockquote>
<p>list(元组)# 元组转换为列表</p>
<p>tuple(列表)# 列表转换为元组</p>
</blockquote>
</li>
</ul>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><ul>
<li><p><code>dictionary</code>（字典）可用于存储多个数据</p>
</li>
<li><p>字典是无序对象合集，列表是有序对象合集</p>
</li>
<li><p>字典用<code>&#123;&#125;</code>定义</p>
</li>
<li><p>字典使用<strong>键值对</strong>存储数据，键值之间使用<code>，</code>分隔</p>
<ul>
<li>键<code>key</code>是索引</li>
<li>值<code>value</code>是数据</li>
<li>键和值之间使用<code>:</code>分隔</li>
<li>键必须是唯一的</li>
<li>值可以取任何数据类型，但键只能使用字符串、数字和元组</li>
</ul>
</li>
<li><p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xiaoming = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">            <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">            <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&quot;height&quot;</span>: <span class="number">1.75</span>&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>小明</td>
</tr>
<tr>
<td>age</td>
<td>18</td>
</tr>
<tr>
<td>gender</td>
<td>True</td>
</tr>
<tr>
<td>height</td>
<td>1.75</td>
</tr>
</tbody></table>
</li>
<li><p>字典取值使用<code>[]</code></p>
<ul>
<li>例如：<code>pirnt([&quot;name&quot;])</code></li>
</ul>
</li>
<li><p><code>xiaoming[&quot;GPA&quot;] = 3.5</code>若key不存在则会新增键值对</p>
</li>
<li><p>查看元组能使用的功能方法如列表</p>
</li>
<li><p><code>for k in xiaoming</code>变量<code>k</code>是键值</p>
</li>
<li><p>使用场景</p>
<ul>
<li>使用多个键值对存储描述一个物体的相关信息</li>
<li>将多个字典放在一个列表中再进行遍历，再循环体内部针对每一个字典进行相同的处理</li>
</ul>
</li>
</ul>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li><p>可以用<code>&quot;&quot;</code> 或<code>&#39;&#39;</code>定义字符串，使用<code>&#39;&#39;</code>往往用于定义字符串内有<code>&quot;&quot;</code>的情况</p>
<ul>
<li><code>str2 = &#39;my name is &quot;logo&quot;&#39;</code></li>
</ul>
</li>
<li><p><code>index(&quot;substring&quot;)</code>查询子字符串<code>substring</code>不存在代码会报错</p>
</li>
<li><p>判断类型</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>string.isspace()</code></td>
<td>若string只包含空格，返回True</td>
</tr>
<tr>
<td><code>sting.isalnum()</code></td>
<td>若string至少有一个字符并且所以字符或数字返回True</td>
</tr>
<tr>
<td><code>string.isalpha()</code></td>
<td>若string至少有一个并且所有字符都是字母返回True</td>
</tr>
<tr>
<td><code>string.isdecimal()</code></td>
<td>若string只包含数字则返回True（全角数字）</td>
</tr>
<tr>
<td><code>string.isdigit()</code></td>
<td>若string只包含数字则返回True（全角数字，（1），<code>\u00b2</code>）</td>
</tr>
<tr>
<td><code>string.isnumeric()</code></td>
<td>若string只包含数字则返回True（全角数字，汉字数字）</td>
</tr>
<tr>
<td><code>string.istitle()</code></td>
<td>若string是标题化的（每个单词首字母大写）则返回True</td>
</tr>
<tr>
<td><code>string.islower()</code></td>
<td>若string中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是小写，则返回True</td>
</tr>
<tr>
<td><code>string.isupper()</code></td>
<td>若string中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是大写，则返回True</td>
</tr>
</tbody></table>
<ul>
<li>查找和替换</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>string.startswith(str)</code></td>
<td>若string以<code>str</code>开头则返回True</td>
</tr>
<tr>
<td><code>string.endwith(str)</code></td>
<td>若string以<code>str</code>结尾则返回True</td>
</tr>
<tr>
<td><code>string.find(str,start=0,end=len(string))</code></td>
<td>若<code>str</code>在 string的start到end中则返回索引值，否则返回-1</td>
</tr>
<tr>
<td><code>string.rfind(str,start=0,end=len(string))</code></td>
<td>类似<code>find()</code>函数，从右边开始</td>
</tr>
<tr>
<td><code>string.index(str,start=0,end=len(string))</code></td>
<td>与<code>find()</code>类似，但是<code>str</code>不在string中会报错</td>
</tr>
<tr>
<td><code>string.rindex(str,start=0,end=len(string))</code></td>
<td>类似于<code>index()</code>，从右边开始</td>
</tr>
<tr>
<td><code>string.replace(old_str,new_str,num=string.count(old))</code></td>
<td>把string中<code>old_str</code>替换为<code>new_str</code>，若<code>num</code>指定，则替换不超过<code>num</code>次</td>
</tr>
</tbody></table>
<ul>
<li>大小写转换</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>string.capitalize()</code></td>
<td>把字符串第一个字符大写</td>
</tr>
<tr>
<td><code>string.title()</code></td>
<td>把字符串每个单词首字母大写</td>
</tr>
<tr>
<td><code>string.lower()</code></td>
<td>转换string所有大写字母为小写</td>
</tr>
<tr>
<td><code>string.upper()</code></td>
<td>转换string所有小写字母为大写</td>
</tr>
<tr>
<td><code>string.swapcase()</code></td>
<td>翻转string中的大小写</td>
</tr>
</tbody></table>
<ul>
<li>去除空白字符</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>string.lstrip()</code></td>
<td>截掉 string 左边（开始）的空白字符</td>
</tr>
<tr>
<td><code>string.rstrip()</code></td>
<td>截掉 string 右边（末尾）的空白字符</td>
</tr>
<tr>
<td><code>string.strip()</code></td>
<td>截掉 string 左右两边的空白字符</td>
</tr>
</tbody></table>
<ul>
<li>拆分和连接</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>string.partition(str)</code></td>
<td>把字符串 string 分成一个 3 元素的元组 (<code>str</code>前面, <code>str</code>, <code>str</code>后面)</td>
</tr>
<tr>
<td><code>string.rpartition(str)</code></td>
<td>类似于 partition() 方法，不过是从右边开始查找</td>
</tr>
<tr>
<td><code>string.split(str=&quot;&quot;, num)</code></td>
<td>以 <code>str</code> 为分隔符拆分 string，如果 <code>num</code> 有指定值，则仅分隔 <code>num + 1</code> 个子字符串，<code>str</code> 默认包含 ‘\r’, ‘\t’, ‘\n’ 和空格</td>
</tr>
<tr>
<td><code>string.splitlines()</code></td>
<td>按照行(‘\r’, ‘\n’, ‘\r\n’)分隔，返回一个包含各行作为元素的列表</td>
</tr>
<tr>
<td><code>string.join(seq)</code></td>
<td>以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串</td>
</tr>
</tbody></table>
<ul>
<li><strong>切片</strong> 方法适用于 <strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong><ul>
<li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li>
<li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li>
<li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li>
<li><code>nums_str[开始索引:结束索引:步长]</code></li>
<li><strong>注意</strong>：<ul>
<li>指定的区间属于 <strong>左闭右开</strong> 型 <code>[开始索引,  结束索引)</code> &#x3D;&gt; <code>开始索引 &gt;= 范围 &lt; 结束索引</code></li>
<li>从 <code>起始</code> 位开始，到 <strong><code>结束</code>位的前一位</strong> 结束（<strong>不包含结束位本身</strong>)</li>
<li>从头开始，<strong>开始索引</strong> <strong>数字可以省略，冒号不能省略</strong></li>
<li>到末尾结束，<strong>结束索引</strong> <strong>数字可以省略，冒号不能省略</strong></li>
<li>步长默认为 <code>1</code>，如果连续切片，<strong>数字和冒号都可以省略</strong></li>
</ul>
</li>
<li>索引的顺序和倒序<ul>
<li>在 Python 中不仅支持 <strong>顺序索引</strong>，同时还支持 <strong>倒序索引</strong>，步长为-1</li>
<li>所谓倒序索引就是 <strong>从右向左</strong> 计算索引<ul>
<li>最右边的索引值是 <strong>-1</strong>，依次递减</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h1><ul>
<li>内置函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>len(item)</td>
<td>计算容器中元素个数</td>
<td></td>
</tr>
<tr>
<td>del(item)</td>
<td>删除变量</td>
<td>del 有两种方式</td>
</tr>
<tr>
<td>max(item)</td>
<td>返回容器中元素最大值</td>
<td>如果是字典，只针对 key 比较</td>
</tr>
<tr>
<td>min(item)</td>
<td>返回容器中元素最小值</td>
<td>如果是字典，只针对 key 比较</td>
</tr>
<tr>
<td><code>cmp(item1, item2)</code></td>
<td>比较两个值，-1 小于&#x2F;0 相等&#x2F;1 大于</td>
<td><code>Python 3.x </code>取消了 <code>cmp </code>函数</td>
</tr>
</tbody></table>
<p>  <strong>注意</strong></p>
<ul>
<li><strong>字符串</strong> 比较符合以下规则： “0” &lt; “A” &lt; “a”</li>
</ul>
<ul>
<li><p>切片</p>
<table>
<thead>
<tr>
<th align="center">描述</th>
<th>Python 表达式</th>
<th>结果</th>
<th>支持的数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">切片</td>
<td>“0123456789”[::-2]</td>
<td>“97531”</td>
<td>字符串、列表、元组</td>
</tr>
</tbody></table>
<ul>
<li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li>
<li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li>
<li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li>
</ul>
</li>
<li><p>运算符</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
<th>支持的数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td>[1, 2] + [3, 4]</td>
<td>[1, 2, 3, 4]</td>
<td>合并</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td align="center">*</td>
<td>[“Hi!”] * 4</td>
<td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td>重复</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td align="center">in</td>
<td>3 in (1, 2, 3)</td>
<td>True</td>
<td>元素是否存在</td>
<td>字符串、列表、元组、字典</td>
</tr>
<tr>
<td align="center">not in</td>
<td>4 not in (1, 2, 3)</td>
<td>True</td>
<td>元素是否不存在</td>
<td>字符串、列表、元组、字典</td>
</tr>
<tr>
<td align="center"><code>&gt;</code> <code>&gt;=</code> <code> ==</code> <code>&lt;</code> <code>&lt;=</code></td>
<td>(1, 2, 3) &lt; (2, 2, 3)</td>
<td>True</td>
<td>元素比较</td>
<td>字符串、列表、元组</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<ul>
<li><code>in</code> 在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></li>
<li><code>in</code> 和 <code>not in</code> 被称为 <strong>成员运算符</strong></li>
</ul>
</li>
<li><p>成员运算符</p>
<p>成员运算符用于 <strong>测试</strong> 序列中是否包含指定的 <strong>成员</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>如果在指定的序列中找到值返回 True，否则返回 False</td>
<td><code>3 in (1, 2, 3)</code> 返回 <code>True</code></td>
</tr>
<tr>
<td>not in</td>
<td>如果在指定的序列中没有找到值返回 True，否则返回 False</td>
<td><code>3 not in (1, 2, 3)</code> 返回 <code>False</code></td>
</tr>
</tbody></table>
<p>注意：在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></p>
</li>
<li><p>完整的 for 循环语法</p>
<ul>
<li>在 <code>Python</code> 中完整的 <code>for 循环</code> 的语法如下：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 集合:</span><br><span class="line">    </span><br><span class="line">    循环体代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    没有通过 <span class="keyword">break</span> 退出循环，循环结束后，会执行的代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用场景</p>
<ul>
<li><p>在 <strong>迭代遍历</strong> 嵌套的数据类型时，例如 <strong>一个列表包含了多个字典</strong></p>
</li>
<li><p>需求：要判断 某一个字典中 是否存在 指定的 值 </p>
<ul>
<li><p>如果 <strong>存在</strong>，提示并且退出循环</p>
</li>
<li><p>如果 <strong>不存在</strong>，在 <strong>循环整体结束</strong> 后，希望 <strong>得到一个统一的提示</strong></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="LINUX-上的-Shebang-符号"><a href="#LINUX-上的-Shebang-符号" class="headerlink" title="LINUX 上的 Shebang 符号(#!)"></a>LINUX 上的 <code>Shebang</code> 符号(<code>#!</code>)</h1><ul>
<li><code>#!</code>这个符号叫做 <code>Shebang</code> 或者 <code>Sha-bang</code></li>
<li><code>Shebang</code> 通常在 <code>Unix</code> 系统脚本的中 <strong>第一行开头</strong> 使用</li>
<li>指明 <strong>执行这个脚本文件</strong> 的 <strong>解释程序</strong></li>
<li><strong>使用 Shebang 的步骤</strong></li>
</ul>
<ol>
<li>使用 <code>which</code> 查询 <code>python3</code> 解释器所在路径</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> python3</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改要运行的 <strong>主 python 文件</strong>，在第一行增加以下内容</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改 <strong>主 python 文件</strong> 的文件权限，增加执行权限</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x cards_main.py</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在需要时执行程序即可</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./cards_main.py</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>auto_login</title>
    <url>/2023/05/25/Python%E5%AD%A6%E4%B9%A0/auto_login/</url>
    <content><![CDATA[<p>每次电脑连接校园网都需要输入密码。甚至有时电脑无法自动弹出上网登录界面。因而希望做一个脚本来实现自动登录。</p>
<h1 id="校园网上网原理"><a href="#校园网上网原理" class="headerlink" title="校园网上网原理"></a>校园网上网原理</h1><p>设备模仿目标服务器向客户端发送HTTP Redirect，将客户浏览器重定向到一个预先指定的Web服务器。在这个Web服务器的页面上，用户输入账号密码等信息，后台认证通过后，该服务器会向前述设备发送认证通过消息，该设备会建立认证通过表项。下一次客户Internet（不仅仅HTTP，所有）请求过来的时候，查表找到表项后，正常转发。客户即可正常上网了。</p>
<h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><ul>
<li><p>request库</p>
<ul>
<li><p>Python中可以实现简单的HTTP的模块</p>
</li>
<li><p>基本GET请求</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&quot;http://httpbin.org/get&quot;</span>)</span><br><span class="line"><span class="comment"># text输出文本内容</span></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>POST请求和GET请求</p>
<ul>
<li>GET请求和POST请求区别在于前者通常是通过url地址，而后者常见的则是form表单请求</li>
</ul>
</li>
<li><p>Tkinter库</p>
<ul>
<li><p>Python中可以实现简单窗口视窗设计的模块</p>
</li>
<li><p>创建并显示视窗基本写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk  <span class="comment"># 在代码里面导入库，起一个别名，以后代码里面就用这个别名</span></span><br><span class="line">root = tk.Tk()  <span class="comment"># 这个库里面有Tk()这个方法，这个方法的作用就是创建一个窗口</span></span><br><span class="line">root.mainloop()  <span class="comment"># 加上这一句，就可以看见窗口了，循环显示窗口</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>安徽大学校园网登录方式为GET请求。IP会随着位置的不同而可能重新分配。</p>
<ul>
<li><p>方案一</p>
<ul>
<li><p>将下列代码写入html文件并加入开机自启动计划中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;meta name=&quot;viewport&quot; content=&quot;width=, initial-scale=1.0&quot;&gt;</span><br><span class="line">	&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;script&gt;</span><br><span class="line">		onload = function()&#123;</span><br><span class="line">			window.open(&quot;url&quot;, &quot;_self&quot;) # url为请求网址</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/script&gt;	</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不足：</p>
<ul>
<li>无法识别当前IP地址，不适用于因为校园内地理位置的改变而改变IP地址的情况。</li>
<li>仅开机时html文件会运行，仅适用于电脑开机时连接校园网情况，不满足连接WiFi时自动输入账号密码的实际需求。</li>
</ul>
</li>
</ul>
</li>
<li><p>方案二</p>
<ul>
<li><p>python代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">ip, url_cmcc, url</span>):</span><br><span class="line"></span><br><span class="line">    url = re.sub(<span class="string">r&#x27;\d+\.\d+\.\d+\.\d+&amp;&#x27;</span>, ip + <span class="string">&#x27;&amp;&#x27;</span>, url, <span class="number">1</span>)</span><br><span class="line">    url_cmcc = re.sub(<span class="string">r&#x27;\d+\.\d+\.\d+\.\d+&amp;&#x27;</span>, ip + <span class="string">&#x27;&amp;&#x27;</span>, url_cmcc, <span class="number">1</span>)</span><br><span class="line">    res_cmcc = requests.get(url_cmcc)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;&quot;msg&quot;:&quot;&quot;&#x27;</span> <span class="keyword">in</span> res_cmcc.text:</span><br><span class="line">        res = requests.get(url)</span><br><span class="line">        login_gui(ip, res.text, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        login_gui(ip, res_cmcc.text, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_ip</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">        s.connect((<span class="string">&#x27;8.8.8.8&#x27;</span>, <span class="number">80</span>))</span><br><span class="line">        ip = s.getsockname()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        s.close()</span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login_gui</span>(<span class="params">ip, text, model</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> model == <span class="number">1</span>:</span><br><span class="line">        mod = <span class="string">&#x27;cmcc登录&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mod = <span class="string">&#x27;普通登录&#x27;</span></span><br><span class="line"></span><br><span class="line">    root = tk.Tk()</span><br><span class="line">    root.title(<span class="string">&#x27;校园网登录&#x27;</span>)</span><br><span class="line">    var = tk.StringVar()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;&quot;msg&quot;:&quot;&quot;&#x27;</span> <span class="keyword">in</span> text:</span><br><span class="line">        var.<span class="built_in">set</span>(<span class="string">&#x27;当前设备已登录\nip地址:%s\n%s&#x27;</span> % (ip, mod))</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">r&#x27;\u8ba4\u8bc1\u6210\u529f&#x27;</span> <span class="keyword">in</span> text:</span><br><span class="line">        var.<span class="built_in">set</span>(<span class="string">&#x27;登录成功\nip地址:%s\n%s&#x27;</span> % (ip, mod))</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;bGRhcCBhdXRoIGVycm9y&#x27;</span> <span class="keyword">in</span> text:</span><br><span class="line">        var.<span class="built_in">set</span>(<span class="string">&#x27;密码错误\nip地址:%s\n%s&#x27;</span> % (ip, mod))</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;aW51c2UsIGxvZ2luIGFnYWluL&#x27;</span> <span class="keyword">in</span> text:</span><br><span class="line">        var.<span class="built_in">set</span>(<span class="string">&#x27;其他设备已登录\nip地址:%s\n%s&#x27;</span> % (ip, mod))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        var.<span class="built_in">set</span>(<span class="string">&#x27;您可能欠费停机\nip地址:%s\n%s&#x27;</span> % (ip, mod))</span><br><span class="line">    lab = tk.Label(root, textvariable=var, font=(<span class="string">&#x27;Courier&#x27;</span>, <span class="number">15</span>), width=<span class="number">20</span>, height=<span class="number">20</span>)</span><br><span class="line">    lab.pack()  <span class="comment"># 把标签置入root界面布局</span></span><br><span class="line">    root.geometry(<span class="string">&quot;300x200+600+300&quot;</span>)  <span class="comment"># 将窗口移动到新位置（宽度为400，高度为300，上边距为100，左边距为100）</span></span><br><span class="line">    root.mainloop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    url_cmcc = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    url = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    ip = get_ip()</span><br><span class="line">    login(ip, url_cmcc, url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以改进的地方：</p>
<ul>
<li><p>可设置自动获取url来保存各个位置的<code>wlan_ac_ip</code>进而便捷地在校园任何地方都能自动连接校园网</p>
</li>
<li><p>可以进一步完善代码关于账号和密码输入部分以便于校园内同学使用</p>
</li>
</ul>
</li>
<li><p>可利用pyinstaller对文件进行打包</p>
<ul>
<li><code>pyinstaller -F -w main.py</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ul>
<li><a href="https://blog.csdn.net/m0_43404934/article/details/122331463?ops_request_misc=%7B%22request_id%22:%22168852791816782425186970%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168852791816782425186970&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122331463-null-null.142%5Ev88%5Econtrol,239%5Ev2%5Einsert_chatgpt&utm_term=request%E5%BA%93&spm=1018.2226.3001.4187">request库</a></li>
<li><a href="https://blog.csdn.net/youtufeitu/article/details/124306915?ops_request_misc=%7B%22request_id%22:%22168852796316800197099041%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168852796316800197099041&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-124306915-null-null.142%5Ev88%5Econtrol,239%5Ev2%5Einsert_chatgpt&utm_term=POST%E8%AF%B7%E6%B1%82%E5%92%8CGET%E8%AF%B7%E6%B1%82&spm=1018.2226.3001.4187">POST请求和GET请求</a></li>
<li><a href="https://blog.csdn.net/qq_46018418/article/details/105927203?ops_request_misc=%7B%22request_id%22:%22168852799516800192292061%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168852799516800192292061&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105927203-null-null.142%5Ev88%5Econtrol,239%5Ev2%5Einsert_chatgpt&utm_term=Tkinter%E5%BA%93&spm=1018.2226.3001.4187">Tkinter库</a></li>
<li><a href="https://blog.csdn.net/qq_44579321/article/details/127960439">校园网自动登陆</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/364016452">校园网自动登录全平台解决方案</a></li>
<li><a href="https://blog.csdn.net/qq_38830593/article/details/123092015?ops_request_misc=%7B%22request_id%22:%22168852774716800182194125%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168852774716800182194125&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-123092015-null-null.142%5Ev88%5Econtrol,239%5Ev2%5Einsert_chatgpt&utm_term=pyinstaller%E5%AF%B9%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8C%85&spm=1018.2226.3001.4187">pyinstaller对文件进行打包</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Add Strings</title>
    <url>/2023/03/20/LeetCode/Add%20Strings/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/add-strings/description/">415.Add Strings</a></p>
<p>Given two non-negative integers, <code>num1</code> and <code>num2</code> represented as string, return <em>the sum of</em> <code>num1</code> <em>and</em> <code>num2</code> <em>as a string</em>.</p>
<p>You must solve the problem without using any built-in library for handling large integers (such as <code>BigInteger</code>). You must also not convert the inputs to integers directly.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num1 = &quot;11&quot;, num2 = &quot;123&quot;</span><br><span class="line">Output: &quot;134&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num1 = &quot;456&quot;, num2 = &quot;77&quot;</span><br><span class="line">Output: &quot;533&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num1 = &quot;0&quot;, num2 = &quot;0&quot;</span><br><span class="line">Output: &quot;0&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(max(len1,len2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = num1.<span class="built_in">length</span>() - <span class="number">1</span>, j = num2.<span class="built_in">length</span>() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x = i &gt;= <span class="number">0</span> ? num1[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> y = j &gt;= <span class="number">0</span> ? num2[j] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> result = x + y + add;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span> + result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i -= <span class="number">1</span>;</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Add Digits</title>
    <url>/2023/02/12/LeetCode/Add%20Digits/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/add-digits/description/">258.Add Digits</a></p>
<p>Given an integer <code>num</code>, repeatedly add all its digits until the result has only one digit, and return it.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num = 38</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The process is</span><br><span class="line">38 --&gt; 3 + 8 --&gt; 11</span><br><span class="line">11 --&gt; 1 + 1 --&gt; 2 </span><br><span class="line">Since 2 has only one digit, return it.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num = 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(log <em>num</em>)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">addDigits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += num%<span class="number">10</span>;</span><br><span class="line">                num/=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = sum;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(num &gt; <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/add-digits/solutions/1301157/ge-wei-xiang-jia-by-leetcode-solution-u4kj/">进阶：</a></p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">addDigits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Add Binary</title>
    <url>/2022/11/10/LeetCode/Add%20Binary/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/add-binary/description/">67.Add Binary</a></p>
<p>Given two binary strings <code>a</code> and <code>b</code>, return <em>their sum as a binary string</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">Output: &quot;100&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">Output: &quot;10101&quot;</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    string ans_str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> a_size = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> b_size = b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (a_size &lt; b_size) &#123;</span><br><span class="line">        <span class="type">int</span> temp = b_size - a_size;</span><br><span class="line">        <span class="keyword">while</span> (temp--)a += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> temp = a_size - b_size;</span><br><span class="line">        <span class="keyword">while</span> (temp--)b += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> carry = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a_size || i&lt;b_size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] + b[i] + carry == <span class="number">144</span>) &#123;<span class="comment">//&#x27;0&#x27;+&#x27;0&#x27;+&#x27;0&#x27; ASCII</span></span><br><span class="line">            ans_str += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            carry = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] + b[i] + carry == <span class="number">145</span>) &#123;<span class="comment">//&#x27;1&#x27;+&#x27;0&#x27;+&#x27;0&#x27; ASCII</span></span><br><span class="line">            ans_str += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            carry = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] + b[i] + carry == <span class="number">146</span>) &#123;<span class="comment">//&#x27;1&#x27;+&#x27;1&#x27;+&#x27;0&#x27; ASCII</span></span><br><span class="line">            ans_str += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            carry = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] + b[i] + carry == <span class="number">147</span>) &#123;<span class="comment">//&#x27;1&#x27;+&#x27;1&#x27;+&#x27;1&#x27; ASCII</span></span><br><span class="line">            ans_str += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            carry = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;mistake&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="string">&#x27;1&#x27;</span>)ans_str += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(ans_str.<span class="built_in">begin</span>(), ans_str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans_str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">empty</span>()) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (b.<span class="built_in">empty</span>()) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="type">int</span> index_a = a.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> index_b = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bit_a = <span class="number">0</span>, bit_b = <span class="number">0</span>;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> radix = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (index_a &gt;= <span class="number">0</span> || index_b &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        bit_a = <span class="number">0</span>, bit_b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (index_a &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            bit_a = a[index_a] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index_b &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            bit_b = b[index_b] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> sum = bit_a + bit_b + carry;</span><br><span class="line">        <span class="keyword">auto</span> bit = sum % radix;</span><br><span class="line">        carry = sum / radix;</span><br><span class="line">        result += bit + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        --index_a;</span><br><span class="line">        --index_b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        result += carry + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">begin</span>(result), <span class="built_in">end</span>(result));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Assign Cookies</title>
    <url>/2023/03/23/LeetCode/Assign%20Cookies/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/assign-cookies/">455.Assign Cookies</a></p>
<p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p>
<p>Each child <code>i</code> has a greed factor <code>g[i]</code>, which is the minimum size of a cookie that the child will be content with; and each cookie <code>j</code> has a size <code>s[j]</code>. If <code>s[j] &gt;= g[i]</code>, we can assign the cookie <code>j</code> to the child <code>i</code>, and the child <code>i</code> will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: g = [1,2,3], s = [1,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. </span><br><span class="line">And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.</span><br><span class="line">You need to output 1.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: g = [1,2], s = [1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. </span><br><span class="line">You have 3 cookies and their sizes are big enough to gratify all of the children, </span><br><span class="line">You need to output 2.</span><br></pre></td></tr></table></figure>

<p>排序法：</p>
<p>时间复杂度：O(nlogn+mlogm)<br>空间复杂度：O(logn+logm)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> j = g.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] &gt;= g[j]) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    g[j] = INT_MAX;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> m = g.<span class="built_in">size</span>(), n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n; i++, j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; g[i] &gt; s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Balanced Binary Tree</title>
    <url>/2022/12/24/LeetCode/Balanced%20Binary%20Tree/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/balanced-binary-tree/">110.Balanced Binary Tree</a></p>
<p>Given a binary tree, determine if it is <strong>height-balanced</strong></p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,2,3,3,null,null,4,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">height</span>(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left_height = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right_height = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (left_height == <span class="number">-1</span> || right_height == <span class="number">-1</span> || <span class="built_in">abs</span>(left_height - right_height) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Binary Tree In order Traversal</title>
    <url>/2022/11/15/LeetCode/Binary%20Tree%20In%20order%20Traversal/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">94.Binary Tree In order Traversal</a></p>
<p>Given the <code>root</code> of a binary tree, return <em>the in order traversal of its nodes’ values</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,null,2,3]</span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left, res);</span><br><span class="line">    res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">inorder</span>(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/same-tree/solutions/363636/xiang-tong-de-shu-by-leetcode-solution/">Morris 中序遍历：</a></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    TreeNode *predecessor = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">            predecessor = root-&gt;left;</span><br><span class="line">            <span class="keyword">while</span> (predecessor-&gt;right != <span class="literal">nullptr</span> &amp;&amp; predecessor-&gt;right != root) &#123;</span><br><span class="line">                predecessor = predecessor-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">            <span class="keyword">if</span> (predecessor-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                predecessor-&gt;right = root;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                predecessor-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Best Time to Buy and Sell Stock</title>
    <url>/2022/12/29/LeetCode/Best%20Time%20to%20Buy%20and%20Sell%20Stock/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121.Best Time to Buy and Sell Stock</a></p>
<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p>
<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>
<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</span><br><span class="line">Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transactions are done and the max profit = 0.</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (price &lt; min) &#123;</span><br><span class="line">                min = price;</span><br><span class="line">                max = price;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (price &gt; max)max = price;</span><br><span class="line">            <span class="keyword">if</span> (ans &lt; (max - min))ans = max - min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Binary Tree Paths</title>
    <url>/2023/02/11/LeetCode/Binary%20Tree%20Paths/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-paths/description/">257.Binary Tree Paths</a></p>
<p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p>
<p>A <strong>leaf</strong> is a node with no children.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3,null,5]</span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [&quot;1&quot;]</span><br></pre></td></tr></table></figure>

<p>深度优先遍历：</p>
<p>时间复杂度：O(n2)</p>
<p>空间复杂度：O(n2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ret;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* root, string path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            path += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> || root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">                <span class="built_in">next</span>(root-&gt;left, path);</span><br><span class="line">                <span class="built_in">next</span>(root-&gt;right, path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">next</span>(root,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>广度优先遍历：</p>
<p>时间复杂度：O(n2)</p>
<p>空间复杂度：O(n2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; paths;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> paths;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; node_queue;</span><br><span class="line">        queue&lt;string&gt; path_queue;</span><br><span class="line"></span><br><span class="line">        node_queue.<span class="built_in">push</span>(root);</span><br><span class="line">        path_queue.<span class="built_in">push</span>(<span class="built_in">to_string</span>(root-&gt;val));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!node_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = node_queue.<span class="built_in">front</span>(); </span><br><span class="line">            string path = path_queue.<span class="built_in">front</span>();</span><br><span class="line">            node_queue.<span class="built_in">pop</span>();</span><br><span class="line">            path_queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                paths.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    node_queue.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                    path_queue.<span class="built_in">push</span>(path + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(node-&gt;left-&gt;val));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    node_queue.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                    path_queue.<span class="built_in">push</span>(path + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(node-&gt;right-&gt;val));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Binary Tree Postorder Traversal</title>
    <url>/2023/01/11/LeetCode/Binary%20Tree%20Postorder%20Traversal/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">145.Binary Tree Postorder Traversal</a></p>
<p>Given the <code>root</code> of a binary tree, return <em>the postorder traversal of its nodes’ values</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,null,2,3]</span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;ans_v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">postorder</span>(root-&gt;left,ans_v);</span><br><span class="line">            <span class="built_in">postorder</span>(root-&gt;right,ans_v);</span><br><span class="line">            ans_v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans_v;</span><br><span class="line">        <span class="built_in">postorder</span>(root,ans_v);</span><br><span class="line">        <span class="keyword">return</span> ans_v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == prev) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/solutions/431066/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/">Morris遍历：</a></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addPath</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec, TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(vec.<span class="built_in">end</span>() - count, vec.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *p1 = root, *p2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p2 = p1-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p2-&gt;right != <span class="literal">nullptr</span> &amp;&amp; p2-&gt;right != p1) &#123;</span><br><span class="line">                    p2 = p2-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p2-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    p2-&gt;right = p1;</span><br><span class="line">                    p1 = p1-&gt;left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p2-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="built_in">addPath</span>(res, p1-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addPath</span>(res, root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Binary Watch</title>
    <url>/2023/03/14/LeetCode/Binary%20Watch/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-watch/">401.Binary Watch</a></p>
<p>A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.</p>
<ul>
<li>For example, the below binary watch reads <code>&quot;4:51&quot;</code>.</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2021/04/08/binarywatch.jpg" alt="img"></p>
<p>Given an integer <code>turnedOn</code> which represents the number of LEDs that are currently on (ignoring the PM), return <em>all possible times the watch could represent</em>. You may return the answer in <strong>any order</strong>.</p>
<p>The hour must not contain a leading zero.</p>
<ul>
<li>For example, <code>&quot;01:00&quot;</code> is not valid. It should be <code>&quot;1:00&quot;</code>.</li>
</ul>
<p>The minute must be consist of two digits and may contain a leading zero.</p>
<ul>
<li>For example, <code>&quot;10:2&quot;</code> is not valid. It should be <code>&quot;10:02&quot;</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: turnedOn = 1</span><br><span class="line">Output: [&quot;0:01&quot;,&quot;0:02&quot;,&quot;0:04&quot;,&quot;0:08&quot;,&quot;0:16&quot;,&quot;0:32&quot;,&quot;1:00&quot;,&quot;2:00&quot;,&quot;4:00&quot;,&quot;8:00&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: turnedOn = 9</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p>枚举法：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="type">int</span> turnedOn)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>; h &lt; <span class="number">12</span>; ++h) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">60</span>; ++m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (__builtin_popcount(h) + __builtin_popcount(m) == turnedOn) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(h) + <span class="string">&quot;:&quot;</span> + (m &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;&quot;</span>) + <span class="built_in">to_string</span>(m));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二进制枚举：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="type">int</span> turnedOn)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> h = i &gt;&gt; <span class="number">6</span>, m = i &amp; <span class="number">63</span>; <span class="comment">// 用位运算取出高 4 位和低 6 位</span></span><br><span class="line">            <span class="keyword">if</span> (h &lt; <span class="number">12</span> &amp;&amp; m &lt; <span class="number">60</span> &amp;&amp; __builtin_popcount(i) == turnedOn) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(h) + <span class="string">&quot;:&quot;</span> + (m &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;&quot;</span>) + <span class="built_in">to_string</span>(m));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Binary Tree Preorder Traversal</title>
    <url>/2023/01/10/LeetCode/Binary%20Tree%20Preorder%20Traversal/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144.Binary Tree Preorder Traversal</a></p>
<p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes’ values</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,null,2,3]</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;ans_v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans_v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">preorder</span>(root-&gt;left,ans_v);</span><br><span class="line">            <span class="built_in">preorder</span>(root-&gt;right,ans_v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans_v;</span><br><span class="line">        <span class="built_in">preorder</span>(root,ans_v);</span><br><span class="line">        <span class="keyword">return</span> ans_v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() || node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">                stk.<span class="built_in">emplace</span>(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/solutions/461821/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/">Morris 遍历：</a></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *p1 = root, *p2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p2 = p1-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p2-&gt;right != <span class="literal">nullptr</span> &amp;&amp; p2-&gt;right != p1) &#123;</span><br><span class="line">                    p2 = p2-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p2-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(p1-&gt;val);</span><br><span class="line">                    p2-&gt;right = p1;</span><br><span class="line">                    p1 = p1-&gt;left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p2-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(p1-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Climbing Stairs</title>
    <url>/2022/11/12/LeetCode/Climbing%20Stairs/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/climbing-stairs/description/">70.Climbing Stairs</a></p>
<p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p>
<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure>

<p>动态规划：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p = q; </span><br><span class="line">        q = r; </span><br><span class="line">        r = p + q;<span class="comment">//爬到第r阶楼梯可能用1步或2步故第r阶楼梯等于第r-1阶加第r-2阶</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/">快速矩阵幂：</a></p>
<ul>
<li>时间复杂度：O(log ⁡n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">multiply</span>(vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; &amp;a, vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; &amp;b) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">c</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">matrixPow</span>(vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; a, <span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; ret = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = <span class="built_in">multiply</span>(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = <span class="built_in">multiply</span>(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; ret = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; res = <span class="built_in">matrixPow</span>(ret, n);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Contains Duplicate II</title>
    <url>/2023/02/03/LeetCode/Contains%20Duplicate%20II/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/contains-duplicate-ii/description/">219.Contains Duplicate II</a></p>
<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> <em>if there are two <strong>distinct indices</strong></em> <code>i</code> <em>and</em> <code>j</code> <em>in the array such that</em> <code>nums[i] == nums[j]</code> <em>and</em> <code>abs(i - j) &lt;= k</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,1], k = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,0,1,1], k = 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,1,2,3], k = 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums_size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(num) &amp;&amp; i - hash[num] &lt;= k)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            hash[num] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>滑动窗口：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(k+1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums_size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; k)hash.<span class="built_in">erase</span>(nums[i - k - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(nums[i]))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            hash.<span class="built_in">emplace</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Contains Duplicate</title>
    <url>/2023/02/02/LeetCode/Contains%20Duplicate/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/contains-duplicate/">217.Contains Duplicate</a></p>
<p>Given an integer array <code>nums</code>, return <code>true</code> if any value appears <strong>at least twice</strong> in the array, and return <code>false</code> if every element is distinct.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>排序法：</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums_size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(num))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> hash.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Convert Sorted Array to Binary Search Tree</title>
    <url>/2022/12/23/LeetCode/Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108. Convert Sorted Array to Binary Search Tree</a></p>
<p>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a</em> </p>
<p><strong>height-balanced</strong> binary search tree.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line">Explanation: [0,-10,5,null,-3,null,9] is also accepted:</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,3]</span><br><span class="line">Output: [3,1]</span><br><span class="line">Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/solutions/312607/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-33/">中序遍历：</a></p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(log⁡ n)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总是选择中间位置左边的数字作为根节点</span></span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">helper</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">helper</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Convert a Number to Hexadecimal</title>
    <url>/2023/03/16/LeetCode/Convert%20a%20Number%20to%20Hexadecimal/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/convert-a-number-to-hexadecimal/">405.Convert a Number to Hexadecimal</a></p>
<p>Given an integer <code>num</code>, return <em>a string representing its hexadecimal representation</em>. For negative integers, <a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fr=aladdin">two’s complement</a> method is used.</p>
<p>All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.</p>
<p><strong>Note:</strong> You are not allowed to use any built-in library method to directly solve this problem.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num = 26</span><br><span class="line">Output: &quot;1a&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num = -1</span><br><span class="line">Output: &quot;ffffffff&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">toHex</span><span class="params">(<span class="type">int</span> num )</span> </span>&#123;</span><br><span class="line">        string pos = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> _num = num;</span><br><span class="line">        <span class="keyword">while</span> (_num)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += pos[_num % <span class="number">16</span>];</span><br><span class="line">            _num = _num / <span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>位运算：</p>
<p>时间复杂度：O(k)，k是整数的十六进制数的位数</p>
<p>空间复杂度：O(k)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">toHex</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string sb;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="type">int</span> val = (num &gt;&gt; (<span class="number">4</span> * i)) &amp; <span class="number">0xf</span>;</span><br><span class="line">            <span class="keyword">if</span> (sb.<span class="built_in">length</span>() &gt; <span class="number">0</span> || val &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">char</span> digit = val &lt; <span class="number">10</span> ? (<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + val) : (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + val - <span class="number">10</span>);</span><br><span class="line">                sb.<span class="built_in">push_back</span>(digit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Excel Sheet Column Title</title>
    <url>/2023/01/13/LeetCode/Excel%20Sheet%20Column%20Title/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/excel-sheet-column-title/description/">168.Excel Sheet Column Title</a></p>
<p>Given an integer <code>columnNumber</code>, return <em>its corresponding column title as it appears in an Excel sheet</em>.</p>
<p>For example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: columnNumber = 1</span><br><span class="line">Output: &quot;A&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: columnNumber = 28</span><br><span class="line">Output: &quot;AB&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: columnNumber = 701</span><br><span class="line">Output: &quot;ZY&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(log26<em>columnNumber</em>)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        string ans_s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (columnNumber != <span class="number">0</span>) &#123;</span><br><span class="line">            ans_s += (columnNumber - <span class="number">1</span>) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            columnNumber = (columnNumber - (columnNumber - <span class="number">1</span>) % <span class="number">26</span> - <span class="number">1</span>) / <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans_s.<span class="built_in">begin</span>(), ans_s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans_s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码优化：</p>
<p>时间复杂度：O(log26<em>columnNumber</em>)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (columnNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            --columnNumber;</span><br><span class="line">            ans += columnNumber % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            columnNumber /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Counting Bits</title>
    <url>/2023/02/21/LeetCode/Counting%20Bits/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/counting-bits/description/">338.Counting Bits</a></p>
<p>Given an integer <code>n</code>, return <em>an array</em> <code>ans</code> <em>of length</em> <code>n + 1</code> <em>such that for each</em> <code>i</code> (<code>0 &lt;= i &lt;= n</code>)<em>,</em> <code>ans[i]</code> <em>is the <strong>number of</strong></em> <code>1</code><em><strong>‘s</strong> in the binary representation of</em> <code>i</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: [0,1,1]</span><br><span class="line">Explanation:</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 5</span><br><span class="line">Output: [0,1,1,2,1,2]</span><br><span class="line">Explanation:</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br><span class="line">3 --&gt; 11</span><br><span class="line">4 --&gt; 100</span><br><span class="line">5 --&gt; 101</span><br></pre></td></tr></table></figure>

<p>Brian Kernighan 算法：</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countOnes</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x &amp;= (x - <span class="number">1</span>);</span><br><span class="line">            ones++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = <span class="built_in">countOnes</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/counting-bits/solutions/627418/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/">动态规划：</a></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                highBit = i;</span><br><span class="line">            &#125;</span><br><span class="line">            bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Excel Sheet Column Number</title>
    <url>/2023/01/15/LeetCode/Excel%20Sheet%20Column%20Number/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/excel-sheet-column-number/description/">171.Excel Sheet Column Number</a></p>
<p>Given a string <code>columnTitle</code> that represents the column title as appears in an Excel sheet, return <em>its corresponding column number</em>.</p>
<p>For example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: columnTitle = &quot;A&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: columnTitle = &quot;AB&quot;</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: columnTitle = &quot;ZY&quot;</span><br><span class="line">Output: 701</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">titleToNumber</span><span class="params">(string columnTitle)</span> </span>&#123;</span><br><span class="line">		<span class="type">long</span> n = <span class="built_in">pow</span>(<span class="number">26</span>, (columnTitle.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">char</span> c : columnTitle) &#123;</span><br><span class="line">			ans += (c - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>) * n;</span><br><span class="line">			n /= <span class="number">26</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Find the Difference</title>
    <url>/2023/03/11/LeetCode/Find%20the%20Difference/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/find-the-difference/description/">389.Find the Difference</a></p>
<p>You are given two strings <code>s</code> and <code>t</code>.</p>
<p>String <code>t</code> is generated by random shuffling string <code>s</code> and then add one more letter at a random position.</p>
<p>Return the letter that was added to <code>t</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abcd&quot;, t = &quot;abcde&quot;</span><br><span class="line">Output: &quot;e&quot;</span><br><span class="line">Explanation: &#x27;e&#x27; is the letter that was added.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;&quot;, t = &quot;y&quot;</span><br><span class="line">Output: &quot;y&quot;</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(S)，S表示字符集大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s)set[ch]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set[ch])set[ch]--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>求和：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> as = <span class="number">0</span>, at = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            as += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: t) &#123;</span><br><span class="line">            at += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> at - as;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>位运算：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            ret ^= ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: t) &#123;</span><br><span class="line">            ret ^= ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Find All Numbers Disappeared in an Array</title>
    <url>/2023/03/22/LeetCode/Find%20All%20Numbers%20Disappeared%20in%20an%20Array/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/">448.Find All Numbers Disappeared in an Array</a></p>
<p>Given an array <code>nums</code> of <code>n</code> integers where <code>nums[i]</code> is in the range <code>[1, n]</code>, return <em>an array of all the integers in the range</em> <code>[1, n]</code> <em>that do not appear in</em> <code>nums</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,3,2,7,8,2,3,1]</span><br><span class="line">Output: [5,6]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nlogn)<br>空间复杂度：O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans_vec;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; count)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">while</span>(num &gt; count) &#123;</span><br><span class="line">                ans_vec.<span class="built_in">push_back</span>(count);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (count &lt;= nums_size) &#123;</span><br><span class="line">            ans_vec.<span class="built_in">push_back</span>(count);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原地修改：</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> x = (num - <span class="number">1</span>) % n;</span><br><span class="line">            nums[x] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= n) &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>First Bad Version</title>
    <url>/2023/02/15/LeetCode/First%20Bad%20Version/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/first-bad-version/description/">278.First Bad Version</a></p>
<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>
<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API <code>bool isBadVersion(version)</code> which returns whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 5, bad = 4</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line">Then 4 is the first bad version.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 1, bad = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>二分法：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The API isBadVersion is defined for you.</span></span><br><span class="line"><span class="comment">// bool isBadVersion(int version);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; </span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isBadVersion</span>(mid)) &#123;</span><br><span class="line">                right = mid; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Fizz Buzz</title>
    <url>/2023/03/18/LeetCode/Fizz%20Buzz/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/fizz-buzz/description/">412.Fizz Buzz</a></p>
<p>Given an integer <code>n</code>, return <em>a string array</em> <code>answer</code> <em>(<strong>1-indexed</strong>) where</em>:</p>
<ul>
<li><code>answer[i] == &quot;FizzBuzz&quot;</code> if <code>i</code> is divisible by <code>3</code> and <code>5</code>.</li>
<li><code>answer[i] == &quot;Fizz&quot;</code> if <code>i</code> is divisible by <code>3</code>.</li>
<li><code>answer[i] == &quot;Buzz&quot;</code> if <code>i</code> is divisible by <code>5</code>.</li>
<li><code>answer[i] == i</code> (as a string) if none of the above conditions are true.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 5</span><br><span class="line">Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 15</span><br><span class="line">Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;7&quot;,&quot;8&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;11&quot;,&quot;Fizz&quot;,&quot;13&quot;,&quot;14&quot;,&quot;FizzBuzz&quot;]</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans_vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> == <span class="number">0</span>)ans_vec.<span class="built_in">push_back</span>(<span class="string">&quot;FizzBuzz&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)ans_vec.<span class="built_in">push_back</span>(<span class="string">&quot;Fizz&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>)ans_vec.<span class="built_in">push_back</span>(<span class="string">&quot;Buzz&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> ans_vec.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Guess Number Higher or Lower</title>
    <url>/2023/03/08/LeetCode/Guess%20Number%20Higher%20or%20Lower/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/guess-number-higher-or-lower/description/">374.Guess Number Higher or Lower</a></p>
<p>We are playing the Guess Game. The game is as follows:</p>
<p>I pick a number from <code>1</code> to <code>n</code>. You have to guess which number I picked.</p>
<p>Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.</p>
<p>You call a pre-defined API <code>int guess(int num)</code>, which returns three possible results:</p>
<ul>
<li><code>-1</code>: Your guess is higher than the number I picked (i.e. <code>num &gt; pick</code>).</li>
<li><code>1</code>: Your guess is lower than the number I picked (i.e. <code>num &lt; pick</code>).</li>
<li><code>0</code>: your guess is equal to the number I picked (i.e. <code>num == pick</code>).</li>
</ul>
<p>Return <em>the number that I picked</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 10, pick = 6</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 1, pick = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 2, pick = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>二分法：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">guessNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">guess</span>(mid) == <span class="number">1</span>)left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">guess</span>(mid) == <span class="number">-1</span>) right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Hamming Distance</title>
    <url>/2023/03/29/LeetCode/Hamming%20Distance/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/hamming-distance/description/">461.Hamming Distance</a></p>
<p>The <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>
<p>Given two integers <code>x</code> and <code>y</code>, return <em>the <strong>Hamming distance</strong> between them</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = 1, y = 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line">The above arrows point to positions where the corresponding bits are different.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = 3, y = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>位运算：</p>
<p>时间复杂度：O(log⁡C)，本题中logC &#x3D; log2^31</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">0</span> || y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((x &amp; <span class="number">1</span>) != (y &amp; <span class="number">1</span>))ans++;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = x ^ y, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s) &#123;</span><br><span class="line">            ret += s &amp; <span class="number">1</span>;</span><br><span class="line">            s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内置位运算：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __builtin_popcount(x ^ y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Brian Kernighan 算法：</p>
<p>时间复杂度：O(log⁡C)，本题中logC &#x3D; log2^31</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = x ^ y, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s) &#123;</span><br><span class="line">            s &amp;= s - <span class="number">1</span>;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>First Unique Character in a String</title>
    <url>/2023/03/10/LeetCode/First%20Unique%20Character%20in%20a%20String/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/first-unique-character-in-a-string/description/">387.First Unique Character in a String</a></p>
<p>Given a string <code>s</code>, <em>find the first non-repeating character in it and return its index</em>. If it does not exist, return <code>-1</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;leetcode&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;loveleetcode&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aabb&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>

<p>哈希表存储频数：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(S)，S为字符集大小，本题中S不大于26。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; frequency;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            ++frequency[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (frequency[s[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表存储索引：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(S)，S为字符集大小，本题中S不大于26。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; position;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (position.<span class="built_in">count</span>(s[i])) &#123;</span><br><span class="line">                position[s[i]] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                position[s[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> first = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [_, pos]: position) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos != <span class="number">-1</span> &amp;&amp; pos &lt; first) &#123;</span><br><span class="line">                first = pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first == n) &#123;</span><br><span class="line">            first = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>队列：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(S)，S为字符集大小，本题中S不大于26。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; position;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!position.<span class="built_in">count</span>(s[i])) &#123;</span><br><span class="line">                position[s[i]] = i;</span><br><span class="line">                q.<span class="built_in">emplace</span>(s[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                position[s[i]] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; position[q.<span class="built_in">front</span>().first] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>() ? <span class="number">-1</span> : q.<span class="built_in">front</span>().second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Happy Number</title>
    <url>/2023/01/19/LeetCode/Happy%20Number/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/happy-number/description/">202.Happy Number</a></p>
<p>Write an algorithm to determine if a number <code>n</code> is happy.</p>
<p>A <strong>happy number</strong> is a number defined by the following process:</p>
<ul>
<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>
<li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li>
<li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li>
</ul>
<p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 19</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">                n /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(sum))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hash.<span class="built_in">insert</span>(sum);</span><br><span class="line">                n = sum;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>快慢指针：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_next</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (value) &#123;</span><br><span class="line">            sum += (value % <span class="number">10</span>) * (value % <span class="number">10</span>);</span><br><span class="line">            value /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = n;</span><br><span class="line">        <span class="type">int</span> fast = <span class="built_in">get_next</span>(n);</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="number">1</span> &amp;&amp; fast != slow) &#123;</span><br><span class="line">            slow = <span class="built_in">get_next</span>(slow);</span><br><span class="line">            fast = <span class="built_in">get_next</span>(<span class="built_in">get_next</span>(fast));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Implement Queue using Stacks</title>
    <url>/2023/02/08/LeetCode/Implement%20Queue%20using%20Stacks/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232.Implement Queue using Stacks</a></p>
<p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p>
<p>Implement the <code>MyQueue</code> class:</p>
<ul>
<li><code>void push(int x)</code> Pushes element x to the back of the queue.</li>
<li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li>
<li><code>int peek()</code> Returns the element at the front of the queue.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code> otherwise.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <strong>only</strong> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure>

<p>两个堆栈：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk2;</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stk1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            stk2.<span class="built_in">push</span>(stk1.<span class="built_in">top</span>());</span><br><span class="line">            stk1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        stk2.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(!stk2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            stk1.<span class="built_in">push</span>(stk2.<span class="built_in">top</span>());</span><br><span class="line">            stk2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> value = stk1.<span class="built_in">top</span>();</span><br><span class="line">        stk1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk1.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Intersection of Two Arrays II</title>
    <url>/2023/02/26/LeetCode/Intersection%20of%20Two%20Arrays%20II/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/">350.Intersection of Two Arrays II</a></p>
<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must appear as many times as it shows in both arrays and you may return the result in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2,2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">Output: [4,9]</span><br><span class="line">Explanation: [9,4] is also accepted.</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<p>时间复杂度：O(mlogm+nlogn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> length1 = nums1.<span class="built_in">size</span>(), length2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;</span><br><span class="line">            <span class="type">int</span> num1 = nums1[index1], num2 = nums2[index2];</span><br><span class="line">            <span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">                intersection.<span class="built_in">push_back</span>(num1);</span><br><span class="line">                index1++;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(m+n)</p>
<p>空间复杂度：O(min(m,n))</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.<span class="built_in">size</span>() &gt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">intersect</span>(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1) &#123;</span><br><span class="line">            ++m[num];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(num)) &#123;</span><br><span class="line">                intersection.<span class="built_in">push_back</span>(num);</span><br><span class="line">                --m[num];</span><br><span class="line">                <span class="keyword">if</span> (m[num] == <span class="number">0</span>) &#123;</span><br><span class="line">                    m.<span class="built_in">erase</span>(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Intersection of Two Arrays</title>
    <url>/2023/02/25/LeetCode/Intersection%20of%20Two%20Arrays/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349.Intersection of Two Arrays</a></p>
<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">Output: [9,4]</span><br><span class="line">Explanation: [4,9] is also accepted.</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n+m)</p>
<p>空间复杂度：O(n+m)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set1;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1)set1.<span class="built_in">insert</span>(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2)set2.<span class="built_in">insert</span>(num);</span><br><span class="line">        <span class="keyword">if</span> (set1.<span class="built_in">size</span>() &gt; set2.<span class="built_in">size</span>())<span class="built_in">swap</span>(set1, set2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : set1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set2.<span class="built_in">count</span>(num))ans.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<p>时间复杂度：O(nlogn+mlogm)</p>
<p>空间复杂度：O(nlogn+mlogm)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> length1 = nums1.<span class="built_in">size</span>(), length2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;</span><br><span class="line">            <span class="type">int</span> num1 = nums1[index1], num2 = nums2[index2];</span><br><span class="line">            <span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">                <span class="comment">// 保证加入元素的唯一性</span></span><br><span class="line">                <span class="keyword">if</span> (!intersection.<span class="built_in">size</span>() || num1 != intersection.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                    intersection.<span class="built_in">push_back</span>(num1);</span><br><span class="line">                &#125;</span><br><span class="line">                index1++;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Intersection of Two Linked Lists</title>
    <url>/2023/01/12/LeetCode/Intersection%20of%20Two%20Linked%20Lists/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">160.Intersection of Two Linked Lists</a></p>
<p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p>
<p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_statement.png" alt="img"></p>
<p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p>
<p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p>
<p><strong>Custom Judge:</strong></p>
<p>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):</p>
<ul>
<li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li>
<li><code>listA</code> - The first linked list.</li>
<li><code>listB</code> - The second linked list.</li>
<li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li>
<li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li>
</ul>
<p>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">Output: Intersected at &#x27;8&#x27;</span><br><span class="line">Explanation: The intersected node&#x27;s value is 8 (note that this must not be 0 if the two lists intersect).</span><br><span class="line">From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</span><br><span class="line">- Note that the intersected node&#x27;s value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">Output: Intersected at &#x27;2&#x27;</span><br><span class="line">Explanation: The intersected node&#x27;s value is 2 (note that this must not be 0 if the two lists intersect).</span><br><span class="line">From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">Output: No intersection</span><br><span class="line">Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.</span><br><span class="line">Explanation: The two lists do not intersect, so return null.</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n+m)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; hashtable;</span><br><span class="line">        <span class="keyword">while</span>(headA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            hashtable.<span class="built_in">insert</span>(headA);</span><br><span class="line">            headA = headA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(headB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashtable.<span class="built_in">count</span>(headB))<span class="keyword">return</span> headB;</span><br><span class="line">            headB = headB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solutions/811625/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/">双指针：</a></p>
<p>时间复杂度：O(n+m)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">nullptr</span> ? headB : pA-&gt;next;</span><br><span class="line">            pB = pB == <span class="literal">nullptr</span> ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Implement Stack using Queues</title>
    <url>/2023/02/04/LeetCode/Implement%20Stack%20using%20Queues/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225.Implement Stack using Queues</a></p>
<p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p>
<p>Implement the <code>MyStack</code> class:</p>
<ul>
<li><code>void push(int x)</code> Pushes element x to the top of the stack.</li>
<li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li>
<li><code>int top()</code> Returns the element on the top of the stack.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <strong>only</strong> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // return 2</span><br><span class="line">myStack.pop(); // return 2</span><br><span class="line">myStack.empty(); // return False</span><br></pre></td></tr></table></figure>

<p>两个队列：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que2;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que2.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(!que1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(que1,que2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r = que1.<span class="built_in">front</span>();</span><br><span class="line">        que1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>一个队列：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> que_size = que.<span class="built_in">size</span>();</span><br><span class="line">        que.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(que_size--) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Invert Binary Tree</title>
    <url>/2023/02/05/LeetCode/Invert%20Binary%20Tree/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/invert-binary-tree/description/">226.Invert Binary Tree</a></p>
<p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [4,2,7,1,3,6,9]</span><br><span class="line">Output: [4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: [2,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tree_next</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">tree_next</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">tree_next</span>(root-&gt;right);</span><br><span class="line">        TreeNode* temp;</span><br><span class="line">        temp = root-&gt;right;</span><br><span class="line">        root-&gt;right = root-&gt;left;</span><br><span class="line">        root-&gt;left = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">tree_next</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* left = <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        TreeNode* right = <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Is Subsequence</title>
    <url>/2023/03/13/LeetCode/Is%20Subsequence/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/is-subsequence/description/">392.Is Subsequence</a></p>
<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>s</code> <em>is a <strong>subsequence</strong> of</em> <code>t</code><em>, or</em> <code>false</code> <em>otherwise</em>.</p>
<p>A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<p>时间复杂度：O(n+m)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>(), m = t.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/is-subsequence/solutions/346539/pan-duan-zi-xu-lie-by-leetcode-solution/">动态规划：</a></p>
<p>时间复杂度：O(m*S+n)，S为字符集大小</p>
<p>空间复杂度：O(m*s)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">f</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            f[m][i] = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i] == j + <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                    f[i][j] = i;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i][j] = f[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[add][s[i] - <span class="string">&#x27;a&#x27;</span>] == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            add = f[add][s[i] - <span class="string">&#x27;a&#x27;</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Isomorphic Strings</title>
    <url>/2023/01/31/LeetCode/Isomorphic%20Strings/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/isomorphic-strings/">205.Isomorphic Strings</a></p>
<p>Given two strings <code>s</code> and <code>t</code>, <em>determine if they are isomorphic</em>.</p>
<p>Two strings <code>s</code> and <code>t</code> are isomorphic if the characters in <code>s</code> can be replaced to get <code>t</code>.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;egg&quot;, t = &quot;add&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;foo&quot;, t = &quot;bar&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;paper&quot;, t = &quot;title&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(m)，m为字符串字符集数目</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">		unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt;<span class="type">s_t</span>;</span><br><span class="line">		unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt;t_s; </span><br><span class="line">		<span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="type">char</span> x = s[i];</span><br><span class="line">			<span class="type">char</span> y = t[i];</span><br><span class="line">			<span class="keyword">if</span> ((<span class="type">s_t</span>.<span class="built_in">count</span>(x) &amp;&amp; <span class="type">s_t</span>[x] != y) </span><br><span class="line">                || (t_s.<span class="built_in">count</span>(y) &amp;&amp; t_s[y] != x))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="type">s_t</span>[x] = y;</span><br><span class="line">			t_s[y] = x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Linked List Cycle</title>
    <url>/2023/01/09/LeetCode/Linked%20List%20Cycle/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/linked-list-cycle/description/">141.Linked List Cycle</a></p>
<p>Given head, the head of a linked list, determine if the linked list has a cycle in it.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s next pointer is connected to. Note that <code>pos</code> is not passed as a parameter.</p>
<p>Return true if there is a cycle in the linked list. Otherwise, return false.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2], pos = 0</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1], pos = -1</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; hashtable;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashtable.<span class="built_in">count</span>(head))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            hashtable.<span class="built_in">insert</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/linked-list-cycle/solutions/440042/huan-xing-lian-biao-by-leetcode-solution/">快慢指针：</a></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Longest Common Prefix</title>
    <url>/2022/11/02/LeetCode/Longest%20Common%20Prefix/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/longest-common-prefix/description/">14.Longest Common Prefix</a></p>
<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string “”.</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    string ans_string = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> nums_string = <span class="built_in">size</span>(strs);<span class="comment">//字符串的数目</span></span><br><span class="line">    <span class="type">int</span> min_lenth_string = strs[<span class="number">0</span>].<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums_string; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs[i].<span class="built_in">length</span>() &lt; min_lenth_string)min_lenth_string = strs[i].<span class="built_in">length</span>();<span class="comment">//找到最短的字符串的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; min_lenth_string; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums_string; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[<span class="number">0</span>][i] != strs[j][i])<span class="keyword">return</span> ans_string;</span><br><span class="line">        &#125;</span><br><span class="line">        ans_string += strs[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans_string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestCommonPerfix</span><span class="params">(vector&lt;string&gt; strs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">begin</span>(strs), <span class="built_in">end</span>(strs));</span><br><span class="line">    <span class="type">int</span> size = strs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">min</span>(strs[<span class="number">0</span>].<span class="built_in">size</span>(), strs[size<span class="number">-1</span>].<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs[<span class="number">0</span>][index] == strs[size<span class="number">-1</span>][index]) ++index;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Length of Last Word</title>
    <url>/2022/11/08/LeetCode/Length%20of%20Last%20Word/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/length-of-last-word/description/">58.Length of Last Word</a></p>
<p>Given a string <code>s</code> consisting of words and spaces, return <em>the length of the <strong>last</strong> word in the string.</em></p>
<p>A <strong>word</strong> is a maximal substring consisting of non-space characters only.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;Hello World&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The last word is &quot;World&quot; with length 5.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;   fly me   to   the moon  &quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The last word is &quot;moon&quot; with length 4.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;luffy is still joyboy&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The last word is &quot;joyboy&quot; with length 6.</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s_size = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s_size; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[i]))</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;<span class="comment">//单词前不存在空格的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Longest Palindrome</title>
    <url>/2023/03/17/LeetCode/Longest%20Palindrome/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/longest-palindrome/description/">409.Longest Palindrome</a></p>
<p>Given a string <code>s</code> which consists of lowercase or uppercase letters, return <em>the length of the <strong>longest palindrome</strong></em> that can be built with those letters.</p>
<p>Letters are <strong>case sensitive</strong>, for example, <code>&quot;Aa&quot;</code> is not considered a palindrome here.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abccccdd&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;a&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The longest palindrome that can be built is &quot;a&quot;, whose length is 1.</span><br></pre></td></tr></table></figure>

<p>贪心：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(S)，S为字符集大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s)</span><br><span class="line">            ++count[c];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : count) &#123;</span><br><span class="line">            <span class="type">int</span> v = p.second;</span><br><span class="line">            ans += v / <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (v % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; ans % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Majority Element</title>
    <url>/2023/01/14/LeetCode/Majority%20Element/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/majority-element/description/">169.Majority Element</a></p>
<p>Given an array <code>nums</code> of size <code>n</code>, return <em>the majority element</em>.</p>
<p>The majority element is the element that appears more than <code>⌊n / 2⌋</code> times. You may assume that the majority element always exists in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>排序法：</p>
<p>时间复杂度：<em>O</em>(<em>n</em>log<em>n</em>)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> times = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums_size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                times++;</span><br><span class="line">                <span class="keyword">if</span> (times &gt; nums_size / <span class="number">2</span>)<span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> times = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：<em>O</em>(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">        <span class="type">int</span> majority = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            ++counts[num];</span><br><span class="line">            <span class="keyword">if</span> (counts[num] &gt; cnt) &#123;</span><br><span class="line">                majority = num;</span><br><span class="line">                cnt = counts[num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>随机法：</p>
<p>时间复杂度：<em>O</em>(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> candidate = nums[<span class="built_in">rand</span>() % nums_size];</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">                <span class="keyword">if</span> (num == candidate)</span><br><span class="line">                    ++count;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; nums_size / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>分治：</p>
<p>时间复杂度：<em>O</em>(<em>n</em>log<em>n</em>)</p>
<p>空间复杂度：O(log<em>n</em>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count_in_range</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lo; i &lt;= hi; ++i)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target)</span><br><span class="line">                ++count;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majority_element_rec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi)</span><br><span class="line">            <span class="keyword">return</span> nums[lo];</span><br><span class="line">        <span class="type">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> left_majority = <span class="built_in">majority_element_rec</span>(nums, lo, mid);</span><br><span class="line">        <span class="type">int</span> right_majority = <span class="built_in">majority_element_rec</span>(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">count_in_range</span>(nums, left_majority, lo, hi) &gt; (hi - lo + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> left_majority;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">count_in_range</span>(nums, right_majority, lo, hi) &gt; (hi - lo + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> right_majority;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">majority_element_rec</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/">Boyer-Moore 投票算法：</a></p>
<p>时间复杂度：<em>O</em>(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> candidate = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == candidate)</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (--count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Maximum Depth of Binary Tree</title>
    <url>/2022/11/18/LeetCode/Maximum%20Depth%20of%20Binary%20Tree/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104.Maximum Depth of Binary Tree</a></p>
<p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>
<p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,null,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>深度优选搜索：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：<em>O</em>(<em>height</em>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>广度优先搜索：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：<em>O</em>(<em>n</em>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> sz = Q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (sz &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode* node = Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            sz -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Merge Two Sorted Lists</title>
    <url>/2022/11/04/LeetCode/Merge%20Two%20Sorted%20Lists/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">21.Merge Two Sorted Lists</a></p>
<p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p>
<p>Merge the two lists in a one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p>
<p>Return <em>the head of the merged linked list</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: list1 = [1,2,4], list2 = [1,3,4]</span><br><span class="line">Output: [1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: list1 = [], list2 = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: list1 = [], list2 = [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    ListNode* ans_list = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode* node = ans_list;</span><br><span class="line">    <span class="keyword">while</span> (list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">            node-&gt;next = list1;</span><br><span class="line">            list1 = list1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;next = list2;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;next = list1 == <span class="literal">nullptr</span> ? list2 : list1;<span class="comment">//将未合并完的一个链表直接接在ans_list之后</span></span><br><span class="line">    <span class="keyword">return</span> ans_list-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">        l1-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Merge Sorted Array</title>
    <url>/2022/11/14/LeetCode/Merge%20Sorted%20Array/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/merge-sorted-array/description/">88.Merge Sorted Array</a></p>
<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p>
<p><strong>Merge</strong> <code>nums1</code> and <code>nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.</p>
<p>The final sorted array should not be returned by the function, but instead be <em>stored inside the array</em> <code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">Output: [1,2,2,3,5,6]</span><br><span class="line">Explanation: The arrays we are merging are [1,2,3] and [2,5,6].</span><br><span class="line">The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The arrays we are merging are [1] and [].</span><br><span class="line">The result of the merge is [1].</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The arrays we are merging are [] and [1].</span><br><span class="line">The result of the merge is [1].</span><br><span class="line">Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：<em>O</em>((<em>m</em>+<em>n</em>)log(<em>m</em>+<em>n</em>))（套用快速排序）</p>
<p>空间复杂度：<em>O</em>(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">        nums1[m + i] = nums2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逆向双指针：</p>
<p>时间复杂度：O(m+n)。</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p1 = m - <span class="number">1</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> tail = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="number">-1</span>) &#123;</span><br><span class="line">            cur = nums2[p2--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == <span class="number">-1</span>) &#123;</span><br><span class="line">            cur = nums1[p1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">            cur = nums1[p1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = nums2[p2--];</span><br><span class="line">        &#125;</span><br><span class="line">        nums1[tail--] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Minimum Depth of Binary Tree</title>
    <url>/2022/12/25/LeetCode/Minimum%20Depth%20of%20Binary%20Tree/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111.Minimum Depth of Binary Tree</a></p>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,null,3,null,4,null,5,null,6]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p>深度优先遍历：</p>
<p>时间复杂度：O(N)，N为节点数</p>
<p>空间复杂度：O(H)，H为树高度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> min_depth = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            min_depth = <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            min_depth = <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;right), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/solutions/382646/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/">广度优先遍历：</a></p>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(N)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;pair&lt;TreeNode *, <span class="type">int</span>&gt; &gt; que;</span><br><span class="line">        que.<span class="built_in">emplace</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *node = que.<span class="built_in">front</span>().first;</span><br><span class="line">            <span class="type">int</span> depth = que.<span class="built_in">front</span>().second;</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> depth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que.<span class="built_in">emplace</span>(node-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que.<span class="built_in">emplace</span>(node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Move Zeroes</title>
    <url>/2023/02/16/LeetCode/Move%20Zeroes/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/move-zeroes/description/">283.Move Zeroes</a></p>
<p>Given an integer array <code>nums</code>, move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Note</strong> that you must do this in-place without making a copy of the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[left], nums[right]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Missing Number</title>
    <url>/2023/02/14/LeetCode/Missing%20Number/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/missing-number/description/">268.Missing Number</a></p>
<p>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3,0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure>

<p>排序法：</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums_size<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i + <span class="number">1</span>] - <span class="number">1</span>)<span class="keyword">return</span> nums[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] != <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> nums_size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums_size; i++) &#123;</span><br><span class="line">            hash.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> missing = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nums_size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hash.<span class="built_in">count</span>(i)) &#123;</span><br><span class="line">                missing = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> missing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>数学：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> total = n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> arrSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arrSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total - arrSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>位运算：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Number of Segments in a String</title>
    <url>/2023/03/21/LeetCode/Number%20of%20Segments%20in%20a%20String/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/number-of-segments-in-a-string/">434.Number of Segments in a String</a></p>
<p>Given a string <code>s</code>, return <em>the number of segments in the string</em>.</p>
<p>A <strong>segment</strong> is defined to be a contiguous sequence of <strong>non-space characters</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;Hello, my name is John&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The five segments are [&quot;Hello,&quot;, &quot;my&quot;, &quot;name&quot;, &quot;is&quot;, &quot;John&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;Hello&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>上锁：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSegments</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch != <span class="string">&#x27; &#x27;</span> &amp;&amp; flag) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>)flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原地法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSegments</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> segmentCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i == <span class="number">0</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                segmentCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> segmentCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Number of 1 Bits</title>
    <url>/2023/01/17/LeetCode/Number%20of%201%20Bits/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/number-of-1-bits/">191.Number of 1 Bits</a></p>
<p>Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F">Hamming weight</a>.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</li>
<li>In Java, the compiler represents the signed integers using <a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fromtitle=%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81&fromid=5295284">2’s complement notation</a>. Therefore, in <strong>Example 3</strong>, the input represents the signed integer. <code>-3</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 00000000000000000000000000001011</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The input binary string 00000000000000000000000000001011 has a total of three &#x27;1&#x27; bits.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 00000000000000000000000010000000</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The input binary string 00000000000000000000000010000000 has a total of one &#x27;1&#x27; bit.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 11111111111111111111111111111101</span><br><span class="line">Output: 31</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &#x27;1&#x27; bits.</span><br></pre></td></tr></table></figure>

<p>位操作：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>)sum += <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Nim Game</title>
    <url>/2023/02/18/LeetCode/Nim%20Game/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/nim-game/description/">292.Nim Game</a></p>
<p>You are playing the following <a href="https://baike.baidu.com/item/Nim%E6%B8%B8%E6%88%8F/6737105">Nim</a> Game with your friend:</p>
<ul>
<li>Initially, there is a heap of stones on the table.</li>
<li>You and your friend will alternate taking turns, and <strong>you go first</strong>.</li>
<li>On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.</li>
<li>The one who removes the last stone is the winner.</li>
</ul>
<p>Given <code>n</code>, the number of stones in the heap, return <code>true</code> <em>if you can win the game assuming both you and your friend play optimally, otherwise return</em> <code>false</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 4</span><br><span class="line">Output: false</span><br><span class="line">Explanation: These are the possible outcomes:</span><br><span class="line">1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.</span><br><span class="line">2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.</span><br><span class="line">3. You remove 3 stones. Your friend removes the last stone. Your friend wins.</span><br><span class="line">In all outcomes, your friend wins.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)<br>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Palindrome Number</title>
    <url>/2022/10/31/LeetCode/Palindrome%20Number/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/palindrome-number/description/">9.Palindrome Number</a></p>
<p>Given an integer x, return true if x is palindrome integer.</p>
<p>An integer is a palindrome when it reads the same backward as forward.</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = 121</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 121 reads as 121 from left to right and from right to left.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//x位数</span></span><br><span class="line">	<span class="type">int</span> temp = x;</span><br><span class="line">	<span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">		temp /= <span class="number">10</span>;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> first = <span class="built_in">pow</span>(<span class="number">10</span>, count<span class="number">-1</span>);<span class="comment">//选中首位时所需除数</span></span><br><span class="line">	count /= <span class="number">2</span>;<span class="comment">//只需遍历数字一半</span></span><br><span class="line">	<span class="keyword">while</span> (count--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x / first != x % <span class="number">10</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			x %= first;</span><br><span class="line">			x /= <span class="number">10</span>;</span><br><span class="line">			first /= <span class="number">100</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_palindrome</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> divdend = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (divdend &lt; value) &#123;</span><br><span class="line">            divdend *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        divdend /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> first = value / divdend;</span><br><span class="line">            <span class="type">int</span> last = value % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (first != last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            value = (value % divdend) / <span class="number">10</span>;</span><br><span class="line">            divdend /= <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_palindrome_str</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(value);</span><br><span class="line">        string backup = s;</span><br><span class="line">        <span class="built_in">reverse</span>(<span class="built_in">begin</span>(s), <span class="built_in">end</span>(s));</span><br><span class="line">        <span class="keyword">return</span> s == backup;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; value) &#123;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">&quot; is palindrome: &quot;</span> &lt;&lt; boolalpha &lt;&lt; sol.<span class="built_in">is_palindrome_str</span>(value) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Palindrome Linked List</title>
    <url>/2023/02/09/LeetCode/Palindrome%20Linked%20List/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/palindrome-linked-list/description/">234.Palindrome Linked List</a></p>
<p>Given the <code>head</code> of a singly linked list, return <code>true</code> if it is a <em>palindrome</em> <em>or</em> <code>false</code> <em>otherwise</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* frontPointer;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recursivelyCheck</span><span class="params">(ListNode* currentNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">recursivelyCheck</span>(currentNode-&gt;next)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currentNode-&gt;val != frontPointer-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            frontPointer = frontPointer-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        frontPointer = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursivelyCheck</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方法不仅使用了 O(n)的空间，且比将链表复制到数组方法更差，因为在许多语言中，堆栈帧的开销很大（如 Python），并且最大的运行时堆栈深度为 1000（可以增加，但是有可能导致底层解释程序内存出错）。为每个节点创建堆栈帧极大的限制了算法能够处理的最大链表大小。</p>
<p><a href="https://leetcode.cn/problems/palindrome-linked-list/solutions/457059/hui-wen-lian-biao-by-leetcode-solution/">快慢指针：</a></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        ListNode* firstHalfEnd = <span class="built_in">endOfFirstHalf</span>(head);</span><br><span class="line">        ListNode* secondHalfStart = <span class="built_in">reverseList</span>(firstHalfEnd-&gt;next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否回文</span></span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        ListNode* p2 = secondHalfStart;</span><br><span class="line">        <span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val) &#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">        firstHalfEnd-&gt;next = <span class="built_in">reverseList</span>(secondHalfStart);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* nextTemp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">endOfFirstHalf</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Pascal&#39;s Triangle II</title>
    <url>/2022/12/28/LeetCode/Pascal&#39;s%20Triangle%20II/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/pascals-triangle-ii/description/">119. Pascal’s Triangle II</a></p>
<p>Given an integer <code>rowIndex</code>, return the <code>rowIndexth</code> (<strong>0-indexed</strong>) row of the <strong>Pascal’s triangle</strong>.</p>
<p>In <strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>
<p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: rowIndex = 3</span><br><span class="line">Output: [1,3,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: rowIndex = 0</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: rowIndex = 1</span><br><span class="line">Output: [1,1]</span><br></pre></td></tr></table></figure>
<p>个人解答：</p>
<p>时间复杂度：O(rowIndex)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans_v</span><span class="params">(rowIndex+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class="line">            ans_v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            ans_v[i] = <span class="number">1</span>;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;temp_v = ans_v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                ans_v[j] = temp_v[j] + temp_v[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>进一步优化（一个数组）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(rowIndex + <span class="number">1</span>)</span></span>;</span><br><span class="line">        row[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">                row[j] += row[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> row;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Pascal&#39;s Triangle</title>
    <url>/2022/12/27/LeetCode/Pascal&#39;s%20Triangle/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/pascals-triangle/description/">118.Pascal’s Triangle</a></p>
<p>Given an integer <code>numRows</code>, return the first <code>numRows</code> of <strong>Pascal’s triangle</strong>.</p>
<p>In <strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: numRows = 5</span><br><span class="line">Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: numRows = 1</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(numRows^2^)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans_v</span>(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">            ans_v[i].<span class="built_in">resize</span>(i + <span class="number">1</span>);</span><br><span class="line">            ans_v[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            ans_v[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                ans_v[i][j] = ans_v[i - <span class="number">1</span>][j] + ans_v[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Path Sum</title>
    <url>/2022/12/26/LeetCode/Path%20Sum/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/path-sum/description/">112.Path Sum</a></p>
<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>
<p>A <strong>leaf</strong> is a node with no children.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The root-to-leaf path with the target sum is shown.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3], targetSum = 5</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There two root-to-leaf paths in the tree:</span><br><span class="line">(1 --&gt; 2): The sum is 3.</span><br><span class="line">(1 --&gt; 3): The sum is 4.</span><br><span class="line">There is no root-to-leaf path with sum = 5.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [], targetSum = 0</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Since the tree is empty, there are no root-to-leaf paths.</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：<em>O</em>(<em>N</em>),其中N是树的节点数</p>
<p>空间复杂度：O(H),其中H是树的高度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetSum == root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) ||</span><br><span class="line">               <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/path-sum/solutions/318487/lu-jing-zong-he-by-leetcode-solution/">广度优先遍历：</a></p>
<p>时间复杂度：<em>O</em>(<em>N</em>)</p>
<p>空间复杂度：O(N)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode *&gt; que_node;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que_val;</span><br><span class="line">        que_node.<span class="built_in">push</span>(root);</span><br><span class="line">        que_val.<span class="built_in">push</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">while</span> (!que_node.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *now = que_node.<span class="built_in">front</span>();</span><br><span class="line">            <span class="type">int</span> temp = que_val.<span class="built_in">front</span>();</span><br><span class="line">            que_node.<span class="built_in">pop</span>();</span><br><span class="line">            que_val.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;left == <span class="literal">nullptr</span> &amp;&amp; now-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp == sum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que_node.<span class="built_in">push</span>(now-&gt;left);</span><br><span class="line">                que_val.<span class="built_in">push</span>(now-&gt;left-&gt;val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que_node.<span class="built_in">push</span>(now-&gt;right);</span><br><span class="line">                que_val.<span class="built_in">push</span>(now-&gt;right-&gt;val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Plus One</title>
    <url>/2022/11/09/LeetCode/Plus%20One/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/plus-one/description/description/">66.Plus One</a></p>
<p>You are given a <strong>large integer</strong> represented as an integer array <code>digits</code>, where each <code>digits[i]</code> is the <code>ith</code> digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading <code>0</code>‘s.</p>
<p>Increment the large integer by one and return <em>the resulting array of digits</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: digits = [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br><span class="line">Incrementing by one gives 123 + 1 = 124.</span><br><span class="line">Thus, the result should be [1,2,4].</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: digits = [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br><span class="line">Incrementing by one gives 4321 + 1 = 4322.</span><br><span class="line">Thus, the result should be [4,3,2,2].</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: digits = [9]</span><br><span class="line">Output: [1,0]</span><br><span class="line">Explanation: The array represents the integer 9.</span><br><span class="line">Incrementing by one gives 9 + 1 = 10.</span><br><span class="line">Thus, the result should be [1,0].</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> digits_size = digits.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (digits[digits_size - <span class="number">1</span>] != <span class="number">9</span>) &#123;</span><br><span class="line">        digits[digits_size - <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits_size == <span class="number">1</span>)<span class="keyword">return</span>&#123; <span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">int</span> index = digits_size - <span class="number">2</span>;</span><br><span class="line">        digits[digits_size - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (digits[index] == <span class="number">9</span>) &#123;</span><br><span class="line">            digits[index] = <span class="number">0</span>;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">digits</span><span class="params">(digits_size + <span class="number">1</span>)</span></span>;</span><br><span class="line">                digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (digits_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    digits[digits_size] = <span class="number">0</span>;</span><br><span class="line">                    digits_size--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits[index] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Power of Four</title>
    <url>/2023/02/22/LeetCode/Power%20of%20Four/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/power-of-four/description/">342.Power of Four</a></p>
<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of four. Otherwise, return <code>false</code></em>.</p>
<p>An integer <code>n</code> is a power of four, if there exists an integer <code>x</code> such that <code>n == 4x</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 5</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n &amp;&amp; n % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二进制中1的位置：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; (n &amp; <span class="number">0xaaaaaaaa</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>取模性质：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; n % <span class="number">3</span> == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Power of Two</title>
    <url>/2023/02/07/LeetCode/Power%20of%20Two/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/power-of-two/description/">231.Power of Two</a></p>
<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of two. Otherwise, return <code>false</code></em>.</p>
<p>An integer <code>n</code> is a power of two, if there exists an integer <code>x</code> such that <code>n == 2x</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 20 = 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 16</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 24 = 16</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            num *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>位运算：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; -n) == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>约数法：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> BIG = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; BIG % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Range Sum Query - Immutable</title>
    <url>/2023/02/19/LeetCode/Range%20Sum%20Query%20-%20Immutable/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/range-sum-query-immutable/description/">303.Range Sum Query - Immutable</a></p>
<p>Given an integer array <code>nums</code>, handle multiple queries of the following type:</p>
<ol>
<li>Calculate the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> where <code>left &lt;= right</code>.</li>
</ol>
<p>Implement the <code>NumArray</code> class:</p>
<ul>
<li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>
<li><code>int sumRange(int left, int right)</code> Returns the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> (i.e. <code>nums[left] + nums[left + 1] + ... + nums[right]</code>).</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</span><br><span class="line">[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</span><br><span class="line">Output</span><br><span class="line">[null, 1, -1, -3]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);</span><br><span class="line">numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1</span><br><span class="line">numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1</span><br><span class="line">numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n2)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        arr = nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right) &#123;</span><br><span class="line">            sum += arr[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前缀和：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sums;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        sums.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j + <span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Ransom Note</title>
    <url>/2023/03/09/LeetCode/Ransom%20Note/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/ransom-note/description/">383.Ransom Note</a></p>
<p>Given two strings <code>ransomNote</code> and <code>magazine</code>, return <code>true</code> <em>if</em> <code>ransomNote</code> <em>can be constructed by using the letters from</em> <code>magazine</code> <em>and</em> <code>false</code> <em>otherwise</em>.</p>
<p>Each letter in <code>magazine</code> can only be used once in <code>ransomNote</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)<br>空间复杂度：O(S)，S为字符集大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; c : magazine) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; c : ransomNote) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Power of Three</title>
    <url>/2023/02/20/LeetCode/Power%20of%20Three/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/power-of-three/">326.Power of Three</a></p>
<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of three. Otherwise, return <code>false</code></em>.</p>
<p>An integer <code>n</code> is a power of three, if there exists an integer <code>x</code> such that <code>n == 3x</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 27</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 27 = 33</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 0</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no x where 3x = 0.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = -1</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no x where 3x = (-1).</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (n &amp;&amp; n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最大约数法：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Remove Element</title>
    <url>/2022/11/06/LeetCode/Remove%20Element/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/remove-element/description/">27.Remove Element</a></p>
<p>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"><strong>in-place</strong></a>. The relative order of the elements may be changed.</p>
<p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the <strong>first part</strong> of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code> should hold the final result. It does not matter what you leave beyond the first <code>k</code> elements.</p>
<p>Return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p>
<p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3,2,2,3], val = 3</span><br><span class="line">Output: 2, nums = [2,2,_,_]</span><br><span class="line">Explanation: Your function should return k = 2, with the first two elements of nums being 2.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">Output: 5, nums = [0,1,4,0,3,_,_,_]</span><br><span class="line">Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.</span><br><span class="line">Note that the five elements can be returned in any order.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator pos = <span class="built_in">find</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), val);</span><br><span class="line">    <span class="keyword">while</span> (pos != nums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        nums.<span class="built_in">erase</span>(pos);</span><br><span class="line">        pos = <span class="built_in">find</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">            nums[left] = nums[right - <span class="number">1</span>];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left++;<span class="comment">//直到right指针指向数据不等于val,left左移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Remove Duplicates from Sorted Array</title>
    <url>/2022/11/05/LeetCode/Remove%20Duplicates%20from%20Sorted%20Array/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">26.Remove Duplicates from Sorted Array</a></p>
<p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates <a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"><strong>in-place</strong></a> such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>.</p>
<p>return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p>
<p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1,2]</span><br><span class="line">Output: 2, nums = [1,2,_]</span><br><span class="line">Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]</span><br><span class="line">Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (nums_size == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums_size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[right] != nums[left]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left &gt; <span class="number">1</span>) &#123;<span class="comment">//right和left相邻不用复制</span></span><br><span class="line">                nums[left + <span class="number">1</span>] = nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val != arr[index]) &#123;</span><br><span class="line">            arr[++index] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Remove Duplicates from Sorted List</title>
    <url>/2022/11/13/LeetCode/Remove%20Duplicates%20from%20Sorted%20List/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/description/">83.Remove Duplicates from Sorted List</a></p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,1,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,1,2,3,3]</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>双指针</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* node1 = head;</span><br><span class="line">    ListNode* node2 = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (node2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node2-&gt;val == node1-&gt;val) &#123;</span><br><span class="line">            node1-&gt;next = node2-&gt;next;</span><br><span class="line">            node2 = node2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node1 = node1-&gt;next;</span><br><span class="line">            node2 = node2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Repeated Substring Pattern</title>
    <url>/2023/03/27/LeetCode/Repeated%20Substring%20Pattern/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">459.Repeated Substring Pattern</a></p>
<p>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abab&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: It is the substring &quot;ab&quot; twice.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aba&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abcabcabcabc&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: It is the substring &quot;abc&quot; four times or the substring &quot;abcabc&quot; twice.</span><br></pre></td></tr></table></figure>

<p>枚举法：</p>
<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">bool</span> match = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[j] != s[j - i]) &#123;</span><br><span class="line">                        match = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>字符串匹配：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (s + s).<span class="built_in">find</span>(s, <span class="number">1</span>) != s.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/repeated-substring-pattern/solutions/386481/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/">KMP算法：</a></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string&amp; query, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = query.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fail</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> match = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (match != <span class="number">-1</span> &amp;&amp; pattern[match + <span class="number">1</span>] != query[i]) &#123;</span><br><span class="line">                match = fail[match];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[match + <span class="number">1</span>] == query[i]) &#123;</span><br><span class="line">                ++match;</span><br><span class="line">                <span class="keyword">if</span> (match == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kmp</span>(s + s, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = pattern.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fail</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fail[n - <span class="number">1</span>] != <span class="number">-1</span> &amp;&amp; n % (n - fail[n - <span class="number">1</span>] - <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kmp</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Remove Linked List Elements</title>
    <url>/2023/01/30/LeetCode/Remove%20Linked%20List%20Elements/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203.Remove Linked List Elements</a></p>
<p>Given the <code>head</code> of a linked list and an integer <code>val</code>, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return <em>the new head</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">Output: [1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [], val = 1</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [7,7,7,7], val = 7</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;val == val)head = head-&gt;next;</span><br><span class="line">        ListNode* t = head;</span><br><span class="line">        ListNode* in = head;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;val == val) &#123;</span><br><span class="line">                in-&gt;next = t-&gt;next;</span><br><span class="line">                t = t-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            in = t;</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* temp = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = <span class="built_in">removeElements</span>(head-&gt;next, val);</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Reverse Bits</title>
    <url>/2023/01/16/LeetCode/Reverse%20Bits/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/reverse-bits/description/">190.Reverse Bits</a></p>
<p>Reverse bits of a given 32 bits unsigned integer.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</li>
<li>In Java, the compiler represents the signed integers using <a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fromtitle=%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81&fromid=5295284">2’s complement notation</a>. Therefore, in <strong>Example 2</strong> above, the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 00000010100101000001111010011100</span><br><span class="line">Output:    964176192 (00111001011110000010100101000000)</span><br><span class="line">Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 11111111111111111111111111111101</span><br><span class="line">Output:   3221225471 (10111111111111111111111111111111)</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.</span><br></pre></td></tr></table></figure>

<p>位操作：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> r ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span> &amp;&amp; n &gt; <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            ans |= (n &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>分治：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M1 = <span class="number">0x55555555</span>; <span class="comment">// 01010101010101010101010101010101</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M2 = <span class="number">0x33333333</span>; <span class="comment">// 00110011001100110011001100110011</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M4 = <span class="number">0x0f0f0f0f</span>; <span class="comment">// 00001111000011110000111100001111</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M8 = <span class="number">0x00ff00ff</span>; <span class="comment">// 00000000111111110000000011111111</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span> &amp; M1 | (n &amp; M1) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        n = n &gt;&gt; <span class="number">2</span> &amp; M2 | (n &amp; M2) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        n = n &gt;&gt; <span class="number">4</span> &amp; M4 | (n &amp; M4) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">        n = n &gt;&gt; <span class="number">8</span> &amp; M8 | (n &amp; M8) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">return</span> n &gt;&gt; <span class="number">16</span> | n &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Reverse Linked List</title>
    <url>/2023/02/01/LeetCode/Reverse%20Linked%20List/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/reverse-linked-list/">206.Reverse Linked List</a></p>
<p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5]</span><br><span class="line">Output: [5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2]</span><br><span class="line">Output: [2,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)<span class="keyword">return</span> head;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">resize</span>(i);</span><br><span class="line">            vec.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ans_head, * node, * end;</span><br><span class="line">        i--;</span><br><span class="line">        ans_head = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ans_head-&gt;val = vec[i];</span><br><span class="line">        end = ans_head;</span><br><span class="line">        <span class="keyword">while</span>(--i) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> ListNode;</span><br><span class="line">            node-&gt;val = vec[i];</span><br><span class="line">            end-&gt;next = node;</span><br><span class="line">            end = node;</span><br><span class="line">        &#125;</span><br><span class="line">        end-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ans_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            ListNode* next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Reverse String</title>
    <url>/2023/02/23/LeetCode/Reverse%20String/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/reverse-string/description/">344.Reverse String</a></p>
<p>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p>
<p>You must do this by modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a> with <code>O(1)</code> extra memory.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n&#x2F;2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s_size = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s_size / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[s_size - i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Same Tree</title>
    <url>/2022/11/16/LeetCode/Same%20Tree/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/same-tree/description/">100.Same Tree</a></p>
<p>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: p = [1,2,3], q = [1,2,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: p = [1,2], q = [1,null,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<p><img src="/assets/ex3.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: p = [1,2,1], q = [1,1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p> 深度优先搜索：</p>
<p>时间复杂度：O(min⁡(m,n))</p>
<p>空间复杂度：O(min⁡(m,n))</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>广度优先搜索：</p>
<p>时间复杂度：O(min⁡(m,n))</p>
<p>空间复杂度：O(min⁡(m,n))</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue &lt;TreeNode*&gt; queue1, queue2;</span><br><span class="line">    queue1.<span class="built_in">push</span>(p);</span><br><span class="line">    queue2.<span class="built_in">push</span>(q);</span><br><span class="line">    <span class="keyword">while</span> (!queue1.<span class="built_in">empty</span>() &amp;&amp; !queue2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node1 = queue1.<span class="built_in">front</span>();</span><br><span class="line">        queue1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">auto</span> node2 = queue2.<span class="built_in">front</span>();</span><br><span class="line">        queue2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node1-&gt;val != node2-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> left1 = node1-&gt;left, right1 = node1-&gt;right, left2 = node2-&gt;left, right2 = node2-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> ((left1 == <span class="literal">nullptr</span>) ^ (left2 == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((right1 == <span class="literal">nullptr</span>) ^ (right2 == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            queue1.<span class="built_in">push</span>(left1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            queue1.<span class="built_in">push</span>(right1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            queue2.<span class="built_in">push</span>(left2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            queue2.<span class="built_in">push</span>(right2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue1.<span class="built_in">empty</span>() &amp;&amp; queue2.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Roman to Integer</title>
    <url>/2022/11/01/LeetCode/Roman%20to%20Integer/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/roman-to-integer/description/">13.Roman to Integer</a></p>
<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>


<p>For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<p><strong>I can be placed before V (5) and X (10) to make 4 and 9.</strong><br><strong>X can be placed before L (50) and C (100) to make 40 and 90.</strong><br><strong>C can be placed before D (500) and M (1000) to make 400 and 900.</strong><br>Given a roman numeral, convert it to an integer.</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;III&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: III = 3.</span><br></pre></td></tr></table></figure>


<p>Example 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure>


<p>Example 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum_int = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> is_double = <span class="literal">true</span>;<span class="comment">//两个字符转换</span></span><br><span class="line">    <span class="keyword">while</span> (is_double) &#123;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;IV&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">4</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;IX&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">9</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">40</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">90</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;CD&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">400</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;CM&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">900</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        is_double = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (s != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">5</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;L&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">50</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">500</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;M&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">1000</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;I&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">1</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">10</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">100</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum_int;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; romanToInt_table = &#123;</span><br><span class="line">        &#123; <span class="string">&#x27;I&#x27;</span>, <span class="number">1</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;V&#x27;</span>, <span class="number">5</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;X&#x27;</span>, <span class="number">10</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;L&#x27;</span>, <span class="number">50</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;C&#x27;</span>, <span class="number">100</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;D&#x27;</span>, <span class="number">500</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> sum_int = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> s_size = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s_size; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> value = romanToInt_table[s[i]];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; s_size - <span class="number">1</span> &amp;&amp; value &lt; romanToInt_table[s[i + <span class="number">1</span>]]) &#123;</span><br><span class="line">            sum_int -= value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sum_int += value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum_int;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Reverse Vowels of a String</title>
    <url>/2023/02/24/LeetCode/Reverse%20Vowels%20of%20a%20String/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/reverse-vowels-of-a-string/description/">345.Reverse Vowels of a String</a></p>
<p>Given a string <code>s</code>, reverse only all the vowels in the string and return it.</p>
<p>The vowels are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>, and they can appear in both lower and upper cases, more than once.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;hello&quot;</span><br><span class="line">Output: &quot;holle&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;leetcode&quot;</span><br><span class="line">Output: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(10)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseVowels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set = &#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;U&#x27;</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>; </span><br><span class="line">             left &lt; right; left++, right--) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!set.<span class="built_in">count</span>(s[left])&amp;&amp;(left &lt; right))left++;</span><br><span class="line">            <span class="keyword">while</span>(!set.<span class="built_in">count</span>(s[right])&amp;&amp;(left &lt; right))right--;</span><br><span class="line">            <span class="built_in">swap</span>(s[left], s[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Search Insert Position</title>
    <url>/2022/11/07/LeetCode/Search%20Insert%20Position/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/search-insert-position/description/">35.Search Insert Position</a></p>
<p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,3,5,6], target = 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,3,5,6], target = 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,3,5,6], target = 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度O(logn)；</p>
<p>空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, ans = n;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Single Number</title>
    <url>/2023/01/06/LeetCode/Single%20Number/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/single-number/description/">136.Single Number</a></p>
<p>Given a <strong>non-empty</strong> array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.</p>
<p>You must implement a solution with a linear runtime complexity and use only constant extra space.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = *it;</span><br><span class="line">            it++;</span><br><span class="line">            <span class="keyword">if</span> (it == nums.<span class="built_in">end</span>()||temp != *it)<span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>位运算：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e: nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Sqrt(x)</title>
    <url>/2022/11/11/LeetCode/Sqrt(x)/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/sqrtx/description/">69.Sqrt(x)</a></p>
<p>Given a non-negative integer <code>x</code>, return <em>the square root of</em> <code>x</code> <em>rounded down to the nearest integer</em>. The returned integer should be <strong>non-negative</strong> as well.</p>
<p>You <strong>must not use</strong> any built-in exponent function or operator.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 4 is 2, so we return 2.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i*i &lt;= x)i++;</span><br><span class="line">        <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>二分查找：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = x, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)mid * mid &lt;= x) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/sqrtx/solutions/238553/x-de-ping-fang-gen-by-leetcode-solution/">牛顿迭代：</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> C = x, x0 = x;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">double</span> xi = <span class="number">0.5</span> * (x0 + C / x0);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x0 - xi) &lt; <span class="number">1e-7</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x0 = xi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(x0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Summary Ranges</title>
    <url>/2023/02/06/LeetCode/Summary%20Ranges/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/summary-ranges/description/">228.Summary Ranges</a></p>
<p>You are given a <strong>sorted unique</strong> integer array <code>nums</code>.</p>
<p>A <strong>range</strong> <code>[a,b]</code> is the set of all integers from <code>a</code> to <code>b</code> (inclusive).</p>
<p>Return <em>the <strong>smallest sorted</strong> list of ranges that <strong>cover all the numbers in the array exactly</strong></em>. That is, each element of <code>nums</code> is covered by exactly one of the ranges, and there is no integer <code>x</code> such that <code>x</code> is in one of the ranges but not in <code>nums</code>.</p>
<p>Each range <code>[a,b]</code> in the list should be output as:</p>
<ul>
<li><code>&quot;a-&gt;b&quot;</code> if <code>a != b</code></li>
<li><code>&quot;a&quot;</code> if <code>a == b</code></li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,1,2,4,5,7]</span><br><span class="line">Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">Explanation: The ranges are:</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,2,3,4,6,8,9]</span><br><span class="line">Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">Explanation: The ranges are:</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(nums_size == <span class="number">0</span>)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span>(nums_size == <span class="number">1</span>)<span class="keyword">return</span> &#123;<span class="built_in">to_string</span>(nums[<span class="number">0</span>])&#125;;</span><br><span class="line">        vector&lt;string&gt; ans_vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums_size<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i + <span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">                ans_vec.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[i]));</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> temp = nums[i];</span><br><span class="line">                <span class="keyword">while</span> (i &lt; nums_size - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>] - <span class="number">1</span>)i++;</span><br><span class="line">                ans_vec.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(temp) + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(nums[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[nums_size<span class="number">-1</span>]!=nums[nums_size<span class="number">-2</span>]+<span class="number">1</span>)</span><br><span class="line">            ans_vec.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[nums_size<span class="number">-1</span>]));</span><br><span class="line">        <span class="keyword">return</span> ans_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ret;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> low = i;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">            string temp = <span class="built_in">to_string</span>(nums[low]);</span><br><span class="line">            <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">                temp.<span class="built_in">append</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                temp.<span class="built_in">append</span>(<span class="built_in">to_string</span>(nums[high]));</span><br><span class="line">            &#125;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(<span class="built_in">move</span>(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Sum of Left Leaves</title>
    <url>/2023/03/15/LeetCode/Sum%20of%20Left%20Leaves/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/sum-of-left-leaves/description/">404.Sum of Left Leaves</a></p>
<p>Given the <code>root</code> of a binary tree, return <em>the sum of all left leaves.</em></p>
<p>A <strong>leaf</strong> is a node with no children. A <strong>left leaf</strong> is a leaf that is the left child of another node.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: 24</span><br><span class="line">Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p>深度优先遍历：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isLeafNode</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !node-&gt;left &amp;&amp; !node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            ans += <span class="built_in">isLeafNode</span>(node-&gt;left) ? node-&gt;left-&gt;val : <span class="built_in">dfs</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right &amp;&amp; !<span class="built_in">isLeafNode</span>(node-&gt;right)) &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? <span class="built_in">dfs</span>(root) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>广度优先遍历：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isLeafNode</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !node-&gt;left &amp;&amp; !node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isLeafNode</span>(node-&gt;left)) &#123;</span><br><span class="line">                    ans += node-&gt;left-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isLeafNode</span>(node-&gt;right)) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Third Maximum Number</title>
    <url>/2023/03/19/LeetCode/Third%20Maximum%20Number/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/third-maximum-number/description/">414.Third Maximum Number</a></p>
<p>Given an integer array <code>nums</code>, return <em>the <strong>third distinct maximum</strong> number in this array. If the third maximum does not exist, return the <strong>maximum</strong> number</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3,2,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">The first distinct maximum is 3.</span><br><span class="line">The second distinct maximum is 2.</span><br><span class="line">The third distinct maximum is 1.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The first distinct maximum is 2.</span><br><span class="line">The second distinct maximum is 1.</span><br><span class="line">The third distinct maximum does not exist, so the maximum (2) is returned instead.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,2,3,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">The first distinct maximum is 3.</span><br><span class="line">The second distinct maximum is 2 (both 2&#x27;s are counted together since they have the same value).</span><br><span class="line">The third distinct maximum is 1.</span><br></pre></td></tr></table></figure>

<p>排序：</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), greater&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, diff = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i - <span class="number">1</span>] &amp;&amp; ++diff == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有序集合：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>() == <span class="number">3</span> ? *s.<span class="built_in">begin</span>() : *s.<span class="built_in">rbegin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一次遍历：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> a = LONG_MIN, b = LONG_MIN, c = LONG_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; a) &#123;</span><br><span class="line">                c = b;</span><br><span class="line">                b = a;</span><br><span class="line">                a = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; num &amp;&amp; num &gt; b) &#123;</span><br><span class="line">                c = b;</span><br><span class="line">                b = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &gt; num &amp;&amp; num &gt; c) &#123;</span><br><span class="line">                c = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c == LONG_MIN ? a : c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *a = <span class="literal">nullptr</span>, *b = <span class="literal">nullptr</span>, *c = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || num &gt; *a) &#123;</span><br><span class="line">                c = b;</span><br><span class="line">                b = a;</span><br><span class="line">                a = &amp;num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*a &gt; num &amp;&amp; (b == <span class="literal">nullptr</span> || num &gt; *b)) &#123;</span><br><span class="line">                c = b;</span><br><span class="line">                b = &amp;num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b != <span class="literal">nullptr</span> &amp;&amp; *b &gt; num &amp;&amp; (c == <span class="literal">nullptr</span> || num &gt; *c)) &#123;</span><br><span class="line">                c = &amp;num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c == <span class="literal">nullptr</span> ? *a : *c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Symmetric Tree</title>
    <url>/2022/11/17/LeetCode/Symmetric%20Tree/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/symmetric-tree/description/">101.Symmetric Tree</a></p>
<p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,2,null,3,null,3]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode *u, TreeNode *v)</span> </span>&#123;</span><br><span class="line">    queue &lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(u); q.<span class="built_in">push</span>(v);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        v = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!u &amp;&amp; !v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((!u || !v) || (u-&gt;val != v-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">push</span>(u-&gt;left); </span><br><span class="line">        q.<span class="built_in">push</span>(v-&gt;right);</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">push</span>(u-&gt;right); </span><br><span class="line">        q.<span class="built_in">push</span>(v-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">check</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">check</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Ugly Number</title>
    <url>/2023/02/13/LeetCode/Ugly%20Number/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/ugly-number/description/">263.Ugly Number</a></p>
<p>An <strong>ugly number</strong> is a positive integer whose prime factors are limited to <code>2</code>, <code>3</code>, and <code>5</code>.</p>
<p>Given an integer <code>n</code>, return <code>true</code> <em>if</em> <code>n</code> <em>is an <strong>ugly number</strong></em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 6</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 6 = 2 × 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 14</span><br><span class="line">Output: false</span><br><span class="line">Explanation: 14 is not ugly since it includes the prime factor 7.</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUgly</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)n /= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">3</span> == <span class="number">0</span>)n /= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">5</span> == <span class="number">0</span>)n /= <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUgly</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; factors = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> factor : factors) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n % factor == <span class="number">0</span>) &#123;</span><br><span class="line">                n /= factor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Valid Palindrome</title>
    <url>/2022/12/30/LeetCode/Valid%20Palindrome/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/valid-palindrome/description/">125.Valid Palindrome</a><br>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p>
<p>Given a string <code>s</code>, return <code>true</code> <em>if it is a <strong>palindrome</strong>, or</em> <code>false</code> <em>otherwise</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;amanaplanacanalpanama&quot; is a palindrome.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;race a car&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;raceacar&quot; is not a palindrome.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot; &quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: s is an empty string &quot;&quot; after removing non-alphanumeric characters.</span><br><span class="line">Since an empty string reads the same forward and backward, it is a palindrome.</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (string::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>();) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*it &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; *it &lt;= <span class="string">&#x27;Z&#x27;</span>)*it += <span class="number">32</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((*it &lt; <span class="string">&#x27;a&#x27;</span> || *it&gt;<span class="string">&#x27;z&#x27;</span>)  &amp;&amp; (*it &lt; <span class="string">&#x27;0&#x27;</span> || *it&gt;<span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">                s.<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        string backup = s;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> backup == s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string sgood;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalnum</span>(ch)) &#123;</span><br><span class="line">                sgood += <span class="built_in">tolower</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">sgood_rev</span><span class="params">(sgood.rbegin(), sgood.rend())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> sgood == sgood_rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[left])) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[right])) &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[left]) != <span class="built_in">tolower</span>(s[right])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Valid Parentheses</title>
    <url>/2022/11/03/LeetCode/Valid%20Parentheses/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/valid-parentheses/description/">20.Valid Parentheses</a></p>
<p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
<li>Every close bracket has a corresponding open bracket of the same type.</li>
</ol>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s_size = s.<span class="built_in">size</span>();</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; stack_char;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c:s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>)stack_char.<span class="built_in">push</span>(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!stack_char.<span class="built_in">empty</span>() &amp;&amp; c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stack_char.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>)stack_char.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!stack_char.<span class="built_in">empty</span>() &amp;&amp; c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; stack_char.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>)stack_char.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!stack_char.<span class="built_in">empty</span>() &amp;&amp; c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stack_char.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>)stack_char.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack_char.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; m&#123;&#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;, &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;, &#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: s) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || m[c] != st.<span class="built_in">top</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    st.<span class="built_in">push</span>(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Valid Anagram</title>
    <url>/2023/02/10/LeetCode/Valid%20Anagram/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/valid-anagram/">242.Valid Anagram</a></p>
<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code> <em>otherwise</em>.</p>
<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>排序法：</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(s)，s为字符集大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() != t.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">table</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch: s) &#123;</span><br><span class="line">            table[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch: t) &#123;</span><br><span class="line">            table[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (table[ch - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Valid Perfect Square</title>
    <url>/2023/02/27/LeetCode/Valid%20Perfect%20Square/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/valid-perfect-square/description/">367.Valid Perfect Square</a></p>
<p>Given a positive integer <code>num</code>, return <code>true</code> <em>if</em> <code>num</code> <em>is a perfect square or</em> <code>false</code> <em>otherwise</em>.</p>
<p>A <strong>perfect square</strong> is an integer that is the square of an integer. In other words, it is the product of some integer with itself.</p>
<p>You must not use any built-in library function, such as <code>sqrt</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num = 16</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We return true because 4 * 4 = 16 and 4 is an integer.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num = 14</span><br><span class="line">Output: false</span><br><span class="line">Explanation: We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer.</span><br></pre></td></tr></table></figure>

<p>暴力法：</p>
<p>时间复杂度：O(√n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n*n&lt;=num) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n*n == num)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内置函数法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = (<span class="type">int</span>) <span class="built_in">sqrt</span>(num);</span><br><span class="line">        <span class="keyword">return</span> x * x == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二分法：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = num;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="type">long</span> square = (<span class="type">long</span>) mid * mid;</span><br><span class="line">            <span class="keyword">if</span> (square &lt; num) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (square &gt; num) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>牛顿迭代法：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> x0 = num;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">double</span> x1 = (x0 + num / x0) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (x0 - x1 &lt; <span class="number">1e-6</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x0 = x1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = (<span class="type">int</span>) x0;</span><br><span class="line">        <span class="keyword">return</span> x * x == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Word Pattern</title>
    <url>/2023/02/17/LeetCode/Word%20Pattern/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/word-pattern/description/">290.Word Pattern</a></p>
<p>Given a <code>pattern</code> and a string <code>s</code>, find if <code>s</code> follows the same pattern.</p>
<p>Here <strong>follow</strong> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <strong>non-empty</strong> word in <code>s</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: pattern = &quot;abba&quot;, s = &quot;dog cat cat fish&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: pattern = &quot;aaaa&quot;, s = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n+m)，<code>n</code>为<code>pattern</code>长度，<code>m</code>为<code>s</code>长度</p>
<p>空间复杂度：O(n+m)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordPattern</span><span class="params">(string pattern, string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s_size = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, string&gt;pattern_s;</span><br><span class="line">        unordered_map&lt;string, <span class="type">char</span>&gt;s_pattern;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : pattern) &#123;</span><br><span class="line">            string str;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; s_size;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">                str += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(pattern_s.<span class="built_in">count</span>(ch)&amp;&amp;pattern_s[ch]!=str||</span><br><span class="line">               (s_pattern.<span class="built_in">count</span>(str))&amp;&amp;s_pattern[str]!=ch)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            pattern_s[ch] = str;</span><br><span class="line">            s_pattern[str] = ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == s_size+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>5KM哲学</title>
    <url>/2023/03/26/%E6%82%9F/5KM%E5%93%B2%E5%AD%A6/</url>
    <content><![CDATA[<p>当我跑5km时，前1km是毫无压力的，因为刚刚开始跑，感觉不到累。<br>最后500米也是可以肆无忌惮地冲刺的，因为我知道跑完这500米完就可以休息了，不用担心接着跑会坚持不下来。<br>而中间的3.5km是十分枯燥的，总是在思考还有多久能休息，再跑心脏会不会承担不了等等问题。可能会感觉到喘不过来气，可能会想要放弃，可能会感觉看不见终点在哪里。</p>
<p>人生也是如此，绝大多数光景我们都在这3.5km中活着，眼前只有一个不太真实可触的目标，身体十分疲惫，心理也承担着巨大的压力。感觉一直在做事情，却难以接近那个遥不可及又充满神秘的未来。</p>
<p>困难的地方在于我们只能也必须跑下去，幸运的地方在于我们还可以跑下去，并且有人到达过终点。</p>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>勇气</title>
    <url>/2023/12/29/%E6%82%9F/%E5%8B%87%E6%B0%94/</url>
    <content><![CDATA[<ul>
<li>人唯有把自己逼进万劫不复的险境，才能获得向死而生的勇气。</li>
<li>人得以不断发展的重要动力是灰暗的生活与光明的未来之间的矛盾。</li>
<li>勇敢的人先享受世界。</li>
<li>人生的分界线就在这里，跨过这一步就是英雄，退回这一步就是懦夫。</li>
</ul>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>书</title>
    <url>/2023/07/07/%E6%82%9F/%E4%B9%A6/</url>
    <content><![CDATA[<ul>
<li><p>如果用一句话形容书我想是“润物细无声”。</p>
</li>
<li><p>读书，是为了那些不能读书的人。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>好人与坏人</title>
    <url>/2023/03/26/%E6%82%9F/%E5%A5%BD%E4%BA%BA%E4%B8%8E%E5%9D%8F%E4%BA%BA/</url>
    <content><![CDATA[<p>在这个世界上没有绝对的好人，也没有绝对的坏人。<br>在一个长的时间限度内，你好事比坏事做的多就是好人，坏事做得比好事多也就成了坏人。<br>所以不必自困于过去的遗憾，做到今天的自己问心无愧就好。<br>但行好事耳。</p>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>时间</title>
    <url>/2023/07/01/%E6%82%9F/%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p>把时间放到更有意义的事情上，是一种延长生命的行为。</p>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>忧思</title>
    <url>/2023/11/25/%E6%82%9F/%E5%BF%A7%E6%80%9D/</url>
    <content><![CDATA[<ul>
<li>睿智，得乎静；刚勇，显与动。是故大丈夫处世，必忧思以深远，行决以神速，孤心磨砺以求成也。</li>
<li>万事万物各行其道我又何必庸人自扰。</li>
<li>去寻找全局最优解，而不是局部最优解。</li>
<li>伟人之所以伟大，只是因为我们跪在地上，站起来吧！</li>
<li>先不不喜欢的事情做好才能去做喜欢的事。</li>
<li>故天将降大任于是人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</li>
<li>熬过每一个今天，成功自然会来。</li>
<li>我们能够掌控的是能力，我们无法掌控的是机遇。没有机遇你展现不了能力，没有能力你抓不住机遇。我们能做的只有提升能力，抓住机遇。</li>
<li>成功或失败是上天决定的，前进或停下是我决定的。命定但不注定。</li>
<li>从无所不能，到无所能，到有所能。循此苦旅，以达天际。</li>
</ul>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>目标</title>
    <url>/2023/05/15/%E6%82%9F/%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<p>有些事情我今天没去做，明天更不会做。<br>有些书我这个月没读，下个月更不会读。<br>有些目标我今年没达成，明年更不会达成。<br>有些成功我年轻没取得，年老也不会实现。</p>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>《毛泽东选集》</title>
    <url>/2024/03/07/%E6%9C%AD/%E3%80%8A%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86%E3%80%8B/</url>
    <content><![CDATA[<ul>
<li>他们站在一切人之上——之前站在一切人之下，所以叫做反常。</li>
</ul>
]]></content>
      <categories>
        <category>札</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统》</title>
    <url>/2024/03/08/%E6%9C%AD/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h1><ul>
<li>计算机系统是由硬件和系统软件组成的，他们共同工作来运行应用程序。</li>
</ul>
<h2 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h2><ul>
<li>源程序实际上就是一个由值0和1组成的为（又称为比特）序列，8个位组成一组，称为<strong>字节</strong>。</li>
<li>大部分的现代计算机系统都使用 ASCII 标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数值来表示每个字符。</li>
<li>只由 ASCII 字符构成的文件称为<strong>文本文件</strong>，所有其他文件称为<strong>二进制文件</strong>。</li>
<li>区别不同数据对象的唯一方法是我们读到这些数据对象时的上下文。</li>
</ul>
<h2 id="程序被其他程序翻译成不同的格式"><a href="#程序被其他程序翻译成不同的格式" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h2><ul>
<li>编译系统<ul>
<li><strong>预处理阶段</strong>。预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。通常生成以<code>.i</code>为后缀名的文件。</li>
<li><strong>编译阶段</strong>。编译器（ccl）将文本文件<code>hello.i</code>翻译成文本文件<code>hello.s</code>，它包含一个汇编语言程序。<ul>
<li>汇编语言为不同高级语言的不同编译器提供了通用的输出语言。</li>
</ul>
</li>
<li><strong>汇编阶段</strong>。汇编器（as）将<code>hello.s</code>翻译成及其语言指令。</li>
<li><strong>链接阶段</strong>。链接器将关于涉及到的函数的预编译文件整合到目标文件中，得到<code>hello</code>文件（可执行文件）。</li>
</ul>
</li>
</ul>
<h2 id="了解编译系统如何工作是大有益处的"><a href="#了解编译系统如何工作是大有益处的" class="headerlink" title="了解编译系统如何工作是大有益处的"></a>了解编译系统如何工作是大有益处的</h2><ul>
<li>优化程序性能</li>
<li>理解链接时出现的错误</li>
<li>避免安全漏洞</li>
</ul>
<h2 id="处理器读并解释储存在内存中的指令"><a href="#处理器读并解释储存在内存中的指令" class="headerlink" title="处理器读并解释储存在内存中的指令"></a>处理器读并解释储存在内存中的指令</h2><ul>
<li><p>shell是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。</p>
</li>
<li><p>系统的硬件组成</p>
<ul>
<li><p><strong>总线</strong>：贯穿整个系统的是一组电子管道，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送字长的字节块，也就是<strong>字</strong>。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节（32位），要么是8个字节（64位）。</p>
</li>
<li><p><strong>I&#x2F;O设备</strong>是系统和外部世界的联系通道。每个I&#x2F;O设备通过一个控制器或适配器与I&#x2F;O总线相连。</p>
<ul>
<li>控制器和适配器之间的区别主要在于它们的封装方式。</li>
<li><strong>控制器</strong>是I&#x2F;O设备本身或者系统的主印制电路板（通常称作主板上）的芯片组。</li>
<li><strong>适配器</strong>是一块插在主板插槽上的卡。</li>
</ul>
</li>
<li><p><strong>主存</strong>是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。</p>
<ul>
<li>从物理上来说，主存是由一组<strong>动态随机存储器（DRAM）</strong>芯片组成的。</li>
<li>从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。</li>
</ul>
</li>
<li><p><strong>处理器</strong>是中央处理单元（CPU）的简称，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为<strong>程序计数器（PC）</strong>。</p>
<ul>
<li><p>在任何时刻，PC都指向主存中的某条及其语言指令（即含有该条指令的地址）。而PC更新时指向的下一条指令并不一定和在内存中刚刚执行的指令相邻。</p>
<ul>
<li><strong>加载</strong>：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。</li>
<li><strong>存储</strong>：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。</li>
<li><strong>操作</strong>：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li>
<li><strong>跳转</strong>：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖PC中原来的值。</li>
</ul>
</li>
<li><p>指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>运行 hello 程序</p>
<ul>
<li>初始时，shell程序执行它的指令，等待我们输入一个指令。当我们在键盘上输入字符串<code>./hello</code>后，shell程序将字符逐一读入寄存器，再把它存放内存中。</li>
<li>当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入。然后shell执行一系列指令来加载可执行的<code>hello</code>文件。这些指令将<code>hello</code>目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串<code>&quot;hello, world\n&quot;</code>。<ul>
<li>利用<strong>直接存储器存取（DMA）</strong>技术，数据可以不通过处理器而直接从磁盘到达主存。</li>
</ul>
</li>
<li>一旦目标位文件中的<code>hello</code>中的代码和数据被加载到主存，处理器就开始执行<code>hello</code>程序的<code>main</code>程序中的机器语言指令。这些指令将<code>&quot;hello, world\n&quot;</code>字符串中的字节从主存赋值到寄存器文件，再从寄存器文件复制到显示设备，最终显示在屏幕上。</li>
</ul>
</li>
</ul>
<h2 id="高速缓存至关重要"><a href="#高速缓存至关重要" class="headerlink" title="高速缓存至关重要"></a>高速缓存至关重要</h2><ul>
<li>较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。</li>
<li>针对这种处理器和主存之间的差异，系统设计者采用了更小更快的存储设备，称为<strong>高速缓存存储器（cache memory，简称为cache或高速缓存）</strong>，作为暂时的集结区域，存放处理器近期可能会需要的信息。</li>
</ul>
<h2 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h2><ul>
<li>每个计算机系统中的存储设备都被组织成了一个存储器层次结构。</li>
<li>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。</li>
<li>操作系统的两个基本功能：<ul>
<li>防止硬件被失控的应用程序滥用。</li>
<li>向应用程序提供简单一致的机制来控制复杂而又通常大小不相同的低级硬件设备。</li>
</ul>
</li>
<li>文件是对I&#x2F;O设备的抽象。<ul>
<li>文件就是字节序列，每个 I&#x2F;O 设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。</li>
</ul>
</li>
<li>虚拟内存是对主存和磁盘 I&#x2F;O 设备的抽象表示。<ul>
<li>每个进程看到的内存都是一致的，称为虚拟地址空间。它们可分为以下区域：<ul>
<li><strong>程序代码和数据</strong>。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。</li>
<li><strong>堆</strong>。代码和数据区后紧随着的是运行时堆。代码和数据区在进程的一开始运行时就被指定了大小，而堆可以在运行时动态地扩展和收缩。</li>
<li><strong>共享库</strong>。大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</li>
<li><strong>栈</strong>。位于用户虚拟地址空间顶部的是<strong>用户栈</strong>，编译器用它来实现函数调用。和堆一样，<strong>用户栈</strong>在程序执行期间可以动态地扩展和收缩。</li>
<li><strong>内核虚拟内存</strong>。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。</li>
</ul>
</li>
</ul>
</li>
<li>进程是对处理器、主存和 I&#x2F;O 设备的抽象表示。<ul>
<li>进程是操作系统对一个正在运行的程序的一种抽象。</li>
<li><strong>并发运行</strong>是说一个进程的指令和另一个进程的指令是交错执行的。</li>
<li>传统系统在一个时刻只能执行一个程序，而先进的<strong>多核</strong>处理器同时能执行多个程序。</li>
<li>无论是单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为<strong>上下文切换</strong>。</li>
<li>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是<strong>上下文</strong>，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行<strong>上下文切换</strong>，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。</li>
<li>从一个进程到另一个进程的转换是由操作系统<strong>内核</strong>管理的。内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。</li>
<li>一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</li>
</ul>
</li>
</ul>
<h2 id="系统之间利用网络通信"><a href="#系统之间利用网络通信" class="headerlink" title="系统之间利用网络通信"></a>系统之间利用网络通信</h2><ul>
<li>现代系统经常通过网络和其他系统连接到一起。</li>
</ul>
<h2 id="重要主题"><a href="#重要主题" class="headerlink" title="重要主题"></a>重要主题</h2><ul>
<li>Amdahl定律的主要思想是当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。</li>
<li><strong>并发</strong>是一个通用的概念，指一个同时具有多个活动的系统。</li>
<li><strong>并行</strong>指的是用并发来使一个系统运行得更快。</li>
<li>处理必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为<strong>单处理系统</strong>。</li>
<li>当构建一个由但操作系统内核控制的多处理器组成的系统时，我们就得到了一个<strong>多处理系统</strong>。</li>
<li>多核处理器是将多个 CPU（称为“核”）集成在一个集成电路芯片上。</li>
<li>超线程，有时称为<strong>多线程</strong>，是一项允许一个 CPU 执行多个控制流的技术。</li>
<li>多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。其次，它可以使应用程序执行地更快。</li>
<li>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为<strong>指令级并行</strong>。</li>
<li>在<strong>流水线</strong>中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。</li>
<li>如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为<strong>超标量</strong>。</li>
<li>允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。</li>
<li><strong>虚拟机</strong>提供对整个计算机的抽象，包括操作系统、处理器和程序。</li>
</ul>
<h1 id="第二章-信息的表示与处理"><a href="#第二章-信息的表示与处理" class="headerlink" title="第二章 信息的表示与处理"></a>第二章 信息的表示与处理</h1><ul>
<li>现代计算机存储和处理的信息以二进制信号表示（<strong>位</strong>），他们形成了数字革命的基础。</li>
<li>当把位组合在一起，再加上某种<strong>解释</strong>，我们就可以描述任何有限集合的元素。</li>
<li><strong>无符号</strong>编码基于传统的二进制表示法，表示大于或等于零的数字。</li>
<li><strong>补码</strong>编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。</li>
<li><strong>浮点数</strong>编码是表示实数的科学记数法以2为基数的版本。</li>
<li>当结果太大以至于不能表示时，某些运算就会<strong>溢出</strong>。</li>
<li>整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精准的；而浮点数虽然可以编码一个较大的数值范围，但这种表示只是近似的。浮点数的计算可能因为运算过程的不同而影响正常结果，整数则不会。</li>
</ul>
<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><ul>
<li>大多数计算机使用8位的块（字节 byte），作为最小的可寻址的内存单位，而不是位。</li>
<li>机器级程序将内存视为一个非常大的字节数组，称为<strong>虚拟内存</strong>。</li>
<li>内存的每一个字节都由一个唯一的数字来标识，称为它的<strong>地址</strong>。</li>
<li>所有可能的地址的集合就称为<strong>虚拟地址空间</strong>。</li>
</ul>
<h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><ul>
<li>一个字节由8位组成。在二进制表示法中，它的值域是00000000<sub>2 </sub>~ 11111111<sub>2</sub>。如果看成十进制整数，它的值域就是0<sub>10</sub> ~ 255<sub>10</sub>。</li>
<li>二进制和十六进制的之间的转换可以通过展开每个十六进制数字，将它转换为二进制格式。</li>
<li>将一个十进制数字 x 转换为十六进制，可以反复地用16除 x。</li>
</ul>
<h3 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h3><ul>
<li>每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）。字长决定的最重要的系统参数就是虚拟地址空间的最大大小。</li>
<li>对于一个字长为 ω 位的机器而言，虚拟地址的范围为0 ~ 2<sup>ω </sup> - 1。</li>
<li>大多数64位机器也可以运行为32位机器编译的程序，这是一种向后兼容。</li>
<li>数据类型 long 一般在32位程序中为4字节，在64位程序中则为8字节。为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99引入一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化，其中就有数据类型 int32_t 和 int64_t，它们分别为4个字节和8个字节。</li>
</ul>
<h3 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h3><ul>
<li><strong>小端法</strong>：最低有效字节在最前面的方式。</li>
<li><strong>大端法</strong>：最高有效字节在最前面的方式。</li>
<li>许多比较新的微处理器是<strong>双端法</strong>，可以把配置成作为大端或者小端的机器运行。</li>
<li><strong>反汇编器</strong>：一种确定可执行程序文件所表示的指令序列的工具。</li>
</ul>
<h3 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h3><ul>
<li>在使用 ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小无关。因而，文本数据比二进制数据具有更强的平台独立性。</li>
</ul>
<h3 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h3><ul>
<li>不同的机器类型使用不同且不兼容的指令和编码方式。</li>
</ul>
<h3 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h3><ul>
<li><p>位向量就是固定长度为 ω 、由0和1组成的串。</p>
</li>
<li><table>
<thead>
<tr>
<th>~</th>
<th></th>
<th></th>
<th>&amp;</th>
<th>0</th>
<th>1</th>
<th></th>
<th>|</th>
<th>0</th>
<th>1</th>
<th></th>
<th>^</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td><strong>0</strong></td>
<td>1</td>
<td></td>
<td><strong>0</strong></td>
<td>0</td>
<td>0</td>
<td></td>
<td><strong>0</strong></td>
<td>0</td>
<td>1</td>
<td></td>
<td><strong>0</strong></td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>0</td>
<td></td>
<td><strong>1</strong></td>
<td>0</td>
<td>1</td>
<td></td>
<td><strong>1</strong></td>
<td>1</td>
<td>1</td>
<td></td>
<td><strong>1</strong></td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="C-语言的位级运算"><a href="#C-语言的位级运算" class="headerlink" title="C 语言的位级运算"></a>C 语言的位级运算</h3><ul>
<li>C 语言的一个有用的特性就是它支持布尔运算。</li>
<li>位级运算的一个常见用法就是实现<strong>掩码</strong>运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。</li>
</ul>
<h3 id="C语言中的逻辑计算"><a href="#C语言中的逻辑计算" class="headerlink" title="C语言中的逻辑计算"></a>C语言中的逻辑计算</h3><ul>
<li>C语言还提供了一组逻辑运算符 || 、&amp;&amp; 和 !，分别对应 OR 、AND 和 NOT运算。逻辑运算认为所有非零的参数都表示 TRUE，而参数0表示 FALSE。它们返回1或者0，分别表示结果为 TRUE 或者为 FALSE。</li>
<li>逻辑运算符 &amp;&amp; 和 || 与它们对应的位级运算 &amp; 和 | 之间第二个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。</li>
</ul>
<h3 id="C语言中的移位运算"><a href="#C语言中的移位运算" class="headerlink" title="C语言中的移位运算"></a>C语言中的移位运算</h3><ul>
<li>C 语言还提供了一组<strong>移位</strong>运算，向左或者向右移动位模式。C 表达式 x&lt;&lt;k 会生成一个值，x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个0。移位运算时从左至右可结合的。</li>
<li>一般而言，机器支持两种形式的右移：<strong>逻辑右移</strong>和<strong>算术右移</strong>。<ul>
<li>逻辑右移是在左端补 k 个0。</li>
<li>算术右移是在左端补 k 个最高有效位的值，它对有符号整数数据的运算非常有用。</li>
</ul>
</li>
<li>C 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移——算术右移或者逻辑右移都可以。</li>
<li>对于无符号数，右移必须是逻辑的。</li>
<li>与 C 相比，Java 对于如何进行右移有明确的定义。表达是 x&gt;&gt;k 会将 x 算术右移 k 个位置，而 x&gt;&gt;&gt;k 会对 x 做逻辑右移。</li>
</ul>
<h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2>]]></content>
      <categories>
        <category>札</category>
      </categories>
  </entry>
  <entry>
    <title>《海边的卡夫卡》</title>
    <url>/2023/05/04/%E6%9C%AD/%E3%80%8A%E6%B5%B7%E8%BE%B9%E7%9A%84%E5%8D%A1%E5%A4%AB%E5%8D%A1%E3%80%8B/</url>
    <content><![CDATA[<ul>
<li>世界缓慢地持续旋转，而人们都活在梦中。</li>
<li>正因为不能称心如意，人生才有意思。</li>
<li>我们大家都在持续失去种种宝贵的东西——宝贵的机会和可能性，无法挽回的感情。这是生存的一个意义。但我们的脑袋里——我想应该是脑袋里——有一个将这些作为记忆保存下来的小房间。肯定是类似图书馆书架的房间。而我们为了解自己的心的正确状态，必须不断制作那个房间用的检索卡。也需要清扫、换空气、给花瓶换水。换言之，你势必永远活在你自身的图书馆里。</li>
<li>于是我们领教了世界是何等凶顽，同时又得知世界也可以变得温存和美好。</li>
<li>某种情况下，命运这东西类似不断改变前进方向的局部沙尘暴。你变换脚步力图避开他，不料沙尘暴就像配合你似的同样变换脚步。不知有多少人曾在那里流血，你本身也会流血。温暖的鲜红的血。你将双手接血。那既是你的血，又是别人的血。不过有一点是清楚的：从沙尘暴中逃出的你已不再是跨入沙尘暴时的你。是的，这就是所谓沙生暴的含义。</li>
<li>纵使那样，也就是说纵使你的选择和努力注定徒劳无益，你也仍然绝对是你，不是你以外的什么。你正在作为你自己而向前迈进，毫无疑问，不必担心。</li>
<li>就经验性来说，人强烈追求什么的时候，那东西基本上是不来的， 而当你极力回避它的时候，它却自然找到头上。</li>
<li>不是人选择命运，而是命运选择人。</li>
</ul>
]]></content>
      <categories>
        <category>札</category>
      </categories>
  </entry>
  <entry>
    <title>《病隙随笔》</title>
    <url>/2024/03/07/%E6%9C%AD/%E3%80%8A%E7%97%85%E9%9A%99%E9%9A%8F%E7%AC%94%E3%80%8B/</url>
    <content><![CDATA[<ul>
<li>我们太看重了白昼，又太忽视黑夜。生命，至少有一半是在黑夜中呀。</li>
<li>一棵树上落着一群鸟儿，把树砍了，鸟儿也就没了吗？不，树上的鸟儿没了，但它们在别处。同样，此一肉身，栖居过一些思想、情感和心绪，这肉身火化了，那思想、情感和心绪也就没了吗？不，他们在别处。</li>
<li>进退维谷之日正可能是别有洞天之时。</li>
<li>所谓命运，就是说，这一出 “人间戏剧”需要各种各样的角色，你只能是其中之一，不可以随意调换。</li>
<li>佛法博大精深，但我确实不认为满腹功利是对佛法的尊敬。便去烧香，也不该有那样的要求，不该以为命运欠了你什么。莫非是佛一时疏忽错有安排，倒要你这凡夫俗子去提醒一二？唯当去求一份智慧，以醒贪迷。</li>
<li>不断的苦难才是不断需要信心的原因。</li>
<li>科学需要证明，信仰并不需要。</li>
<li>爱，原就是自卑弃暗投明的时刻。</li>
<li>皈依并不在一个住所，皈依是在路上。</li>
<li>彻底的圆满只不过是彻底的无路可走。</li>
<li>一切尘世之名都可以磨灭，而“我”不死。</li>
<li>左右苍茫时，总也得有条路走。</li>
<li>我想，上帝为人性写下的最本质的两条密码是：残疾与爱情。</li>
<li>而你若永远地走向它，你便随时都在它的光照之中。</li>
<li>残疾人以及所有的人，固然应该对艰难的生途说“是”，但要对那无言的坚壁说“不”，那无言的坚壁才是人性的残疾。</li>
<li>如果白昼的语言已经枯朽，就用黑夜的梦语，用诗的性灵。</li>
<li>放弃自卑，同时放弃怨恨；其实这两点必然是同时放弃的，因为曾经，它们也是一齐出生的。</li>
<li>那路途中的一切，有些与我擦肩而过从此天各一方，有些便永驻进我的心魂，雕琢我，塑造我，锤炼我，融入我而成为我。</li>
<li>白昼的清晰是有限的，黑夜却漫长，尤其是那心流所遭遇的黑暗更是辽阔无边。</li>
<li>生命的意义本不在向外的寻取，而在向内的建立。</li>
<li>心中对叛徒的看法似乎都在动摇，我慢慢看见，勇猛和可敬之外还有还有着更为复杂的人生处境。</li>
<li>仇恨的最大弊端是仇恨的蔓延，压迫的最大遗患是压迫的复制。</li>
<li>而那虚假的信仰一旦揭开，内里仍不过一场权利之争，一切轰轰烈烈立刻没了根基。</li>
<li>今天，绝对的信仰之光正趋淡薄，日新月异的生活道具正淹没着对生命意义的追求。</li>
</ul>
]]></content>
      <categories>
        <category>札</category>
      </categories>
  </entry>
  <entry>
    <title>自律</title>
    <url>/2023/07/02/%E6%82%9F/%E8%87%AA%E5%BE%8B/</url>
    <content><![CDATA[<ul>
<li>自律就像是用气球包住了无数的欲望。这个气球会越来越大越来越大，随时都无比接近爆炸。但是只要自律还在，气球就不会爆炸。</li>
<li>愈是沉迷什么，就愈要远离什么。你只能臣服于一种东西，那就是对自己强大的控制力。</li>
</ul>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>Hello 算法</title>
    <url>/2024/03/04/%E7%AE%97%E6%B3%95/Hello%20%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.hello-algo.com/">Hello 算法 </a></p>
]]></content>
      <categories>
        <category>Algo</category>
      </categories>
  </entry>
  <entry>
    <title>第一章 绪论</title>
    <url>/2023/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li><p>数据：数据是<strong>信息的载体</strong>，是描述客观事物属性的数、字符及所有<strong>能输入到计算机中并被计算机程序识别</strong>和处理的符号的集合。数据是计算机程序加工的原料。</p>
</li>
<li><p>数据元素、数据项：<strong>数据元素</strong>是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干<strong>数据项</strong>组成，数据项是构成数据元素的不可分割的最小单位。</p>
</li>
<li><p>数据结构：相互之间存在一种或多种特定<strong>关系</strong>的数据元素的集合。</p>
</li>
<li><p>数据对象：具有<strong>相同性质</strong>的数据元素的集合，是数据的一个子集。</p>
</li>
<li><p>数据类型：一个值的集合和定义在此集合上的一组操作的总称。</p>
<ul>
<li>原子类型。其值不可再分的数据类型。</li>
<li>结构类型。其值可以再分解为若干成分（分量）的数据类型。</li>
</ul>
</li>
<li><p>抽象数据类型（Abstract Data Type, ADT）：抽象数据组织及与之相关的操作。</p>
<ul>
<li>原子类型。其值不可分解。</li>
<li>固定聚合类型。其值由确定数目的成分按某种结构组成。</li>
<li>可变聚合类型。其值的成分数目不确定。</li>
</ul>
</li>
<li><p>多形数据类型：其值的成分不确定的数据类型。</p>
</li>
</ul>
<h1 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h1><ul>
<li>逻辑结构<ul>
<li>集合：各个元素同属一个集合，别无其他关系。</li>
<li>线性结构：数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一前驱，除了最后一个元素，所有元素都有唯一后继。</li>
<li>树性结构：数据元素之间是一对多的关系。</li>
<li>图状结构（网状结构）：数据元素之间是多对多的关系。</li>
</ul>
</li>
<li>物理结构（存储结构）<ul>
<li>顺序存储：把<strong>逻辑上相邻的元素存储在物理位置上也相邻的存储单元中</strong>，元素之间的关系由存储单元的邻接关系来体现。<ul>
<li>若采用<strong>顺序存储</strong>，则各个数据元素在物理上必须是<strong>连续的</strong>；若采用<strong>非顺序存储</strong>，则各个数据元素在物理上可以是<strong>离散的</strong>。</li>
<li>数据的<strong>存储结构</strong>会<strong>影响存储空间分配的方便程度</strong>。</li>
<li>数据的<strong>存储结构</strong>会<strong>影响对数据运算的速度</strong>。</li>
</ul>
</li>
<li>链式存储：<strong>逻辑上相邻的元素在物理位置上可以不相邻</strong>，借助指示元素存储地址的指针来表示元素之间的逻辑关系。</li>
<li>索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。</li>
<li>散列存储：根据元素的关键字直接计算出该元素的存储地址，又称<strong>哈希（Hash）存储</strong>。</li>
</ul>
</li>
<li>数据的运算<ul>
<li>施加在数据上的运算包括运算的定义和实现。</li>
<li><strong>运算的定义</strong>是<strong>针对逻辑结构</strong>的，指出运算的功能。</li>
<li><strong>运算的实现</strong>是<strong>针对存储结构</strong>的，指出运算的具体操作步骤。</li>
</ul>
</li>
</ul>
<h1 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h1><ul>
<li><strong>算法（Algorithm）</strong>是<strong>对特定问题求解步骤的一种描述</strong>，它是指令的有限序列，其中的每条指令表示一个或多个操作。</li>
<li>算法的特性<ul>
<li><strong>有穷性</strong>。一个算法必须总在执行有穷步后结束，且每一步都可在有穷时间内完成。<ul>
<li><strong>算法</strong>必须是<strong>有穷</strong>的，而<strong>程序</strong>可以是<strong>无穷</strong>的。</li>
</ul>
</li>
<li><strong>确定性</strong>。算法中每条指令必须有确切的含义，对于<strong>相同的输入</strong>只能得出<strong>相同的输出</strong>。</li>
<li><strong>可行性</strong>。算法中描述的操作都可以通过已经实现的<strong>基本运算执行有限次</strong>来实现。</li>
<li><strong>输入</strong>。一个算法<strong>有零个或多个输入</strong>，这些输入取自于某个特定的对象的集合。</li>
<li><strong>输出</strong>。一个算法<strong>有一个或多个输出</strong>，这些输出是与输入有某种特定关系的量。</li>
</ul>
</li>
<li>“好”算法的特质：<ul>
<li><strong>正确性</strong>。算法应能正确地求解问题。</li>
<li><strong>可读性</strong>。算法应具有良好的可读性，以帮助人们理解。</li>
<li>健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</li>
<li><strong>高效率</strong>与<strong>低存储量需求</strong>。<ul>
<li>高效率：花的时间少。时间复杂度低。</li>
<li>低存储量需求：不费内存。空间复杂度低。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h1><h2 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h2><ul>
<li><strong>事先预估</strong>算法<strong>时间开销T(n)<strong>与</strong>问题规模n</strong>的关系（T表示”time”）。</li>
<li>在T(n)中可以只考虑阶数高的部分。</li>
<li>大O表示“同阶”，同等数量级。即：当n趋近于无穷大时，二者之比为常数。</li>
<li>加法规则：T(n) &#x3D; T1(n)+T2(n) &#x3D; O(f(n)) + O(g(n)) &#x3D; O(max(f(n), g(n)))</li>
<li>乘法规则：T(n) &#x3D; T1(n) * T2(n) &#x3D; O(f(n)) *  O(g(n)) &#x3D; O(f(n) * g(n))</li>
<li>O(n) &lt; O(log<del>2</del>n) &lt; O(n) &lt; O(nlog<del>2</del>n) &lt;O(n^2^) &lt; O(n^3^) &lt; O(2^n^) &lt; O(n!) &lt; O(n^n^)</li>
<li>顺序执行的代码只会影响常数项，可以忽略。只需挑循环中的<strong>一个基本操作</strong>分析它的执行次数与n的关系即可。如果有多层嵌套循环，只需关注最深层循环循环了几次。</li>
<li>最坏时间复杂度：最坏情况下算法的时间复杂度。</li>
<li>平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间。</li>
<li>最好时间复杂度：最好情况下算法的时间复杂度。（不常用）</li>
</ul>
<h2 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h2><ul>
<li>算法<strong>原地工作</strong>：算法所需的内存空间为常量。</li>
<li>函数递归调用带来的内存开销：空间复杂度 &#x3D; 递归调用的深度</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>第三章 栈和队列</title>
    <url>/2024/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h1><ul>
<li>栈（Stack）：一种操作受限的线性表，<strong>只允许在一端进行插入和删除操作</strong>的线性表。<ul>
<li>特点：后进先出（Last In First Out，LIFO）</li>
<li>逻辑结构：与普通线性表相同</li>
<li>数据的运算：插入、删除操作有区别</li>
</ul>
</li>
<li>重要术语：<ul>
<li>空栈：栈里面没有任何数据元素</li>
<li>栈顶：允许插入和删除的一端</li>
<li>栈底：不允许插入和删除的一端</li>
</ul>
</li>
<li>基本操作：<ul>
<li><code>InitStack(&amp;S)</code>：<strong>初始化</strong>栈。构造一个空栈 S，<strong>分配内存空间</strong>。</li>
<li><code>DestroyStack(&amp;S)</code>：<strong>销毁</strong>栈。销毁并<strong>释放</strong>栈 S 所占用的<strong>内存空间</strong>。</li>
<li><code>Push(&amp;S, x)</code>：<strong>进栈</strong>，若栈 S 未满，则将 x 加入使其成为新栈顶。 </li>
<li><code>Pop(&amp;S, &amp;x)</code>：<strong>出栈</strong>，若栈 S 非空，则弹出栈顶元素，并用 x 返回。</li>
<li><code>GetTop(S, &amp;x)</code>：<strong>读栈顶元素</strong>。若栈 S 非空，则用 x 返回栈顶元素。</li>
<li><code>StackEmpty(S)</code>：判断一个栈 S 是否为空。若 S 为空，返回 ture，否则返回 false。</li>
</ul>
</li>
<li>n 个不同元素进栈，出栈元素不同排列的个数为$\frac{1}{n+1}C^n_{2n}$，上述公式称为卡特兰（Catalan）数，可采用数学归纳法证明。</li>
</ul>
<h1 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h1><ul>
<li><p>顺序栈的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">	<span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">	<span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(Sqtack &amp;S)</span> &#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;	<span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)	<span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> 			<span class="comment">//不空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进栈操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">	<span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MaxSize - <span class="number">1</span>)	<span class="comment">//栈满，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top = S.top + <span class="number">1</span>;	<span class="comment">//指针先加1</span></span><br><span class="line">    S.data[S.top] = x;	<span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="comment">//以上两行代码等价于 S.data[++S.top] = x;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出栈操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">	<span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)	<span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];	<span class="comment">//栈顶元素先出栈</span></span><br><span class="line">    S.top = S.top - <span class="number">1</span>;	<span class="comment">//指针再减一</span></span><br><span class="line">    <span class="comment">//以上两行代码等价于 x = S.data[S.top--];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读栈顶操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">	<span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)	<span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];	<span class="comment">//x记录栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化，入栈，出栈和读栈顶都是O(1)时间复杂度。</p>
</li>
<li><p><code>SqStack S;</code>声明栈时分配内存，函数运行结束后系统自动回收内存。</p>
</li>
<li><p>栈满的条件：top &#x3D;&#x3D; MaxSize - 1</p>
</li>
<li><p>另一种方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">	<span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(Sqtack &amp;S)</span> &#123;</span><br><span class="line">    S.top = <span class="number">0</span>;	<span class="comment">//top指向下一个可以插入元素的位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">0</span>)	<span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> 			<span class="comment">//不空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line">S.data[S.top] = x;</span><br><span class="line">S.top = S.top + <span class="number">1</span>;</span><br><span class="line">等价于 S.data[S.top++] = x;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">S.top = S.top - <span class="number">1</span>;</span><br><span class="line">x = S.data[S.top];</span><br><span class="line">等价于 x = S.data[--S.top];</span><br></pre></td></tr></table></figure>

<p>栈满的条件：top &#x3D;&#x3D; MaxSize</p>
</li>
<li><p>顺序栈的缺点：栈的大小不可变。</p>
</li>
<li><p>共享栈：两个栈共享同一片空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">	<span class="type">int</span> top0;	<span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;	<span class="comment">//1号栈栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(Sqtack &amp;S)</span> &#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;	<span class="comment">//初始化栈顶指针</span></span><br><span class="line">    S.top1 = MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈满的条件：top0 + 1 &#x3D;&#x3D; top1</p>
</li>
</ul>
<h1 id="链栈的实现"><a href="#链栈的实现" class="headerlink" title="链栈的实现"></a>链栈的实现</h1><ul>
<li><p>链栈：用链式存储方式实现的栈。</p>
</li>
<li><p>链栈的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> &#123;</span></span><br><span class="line">    ElemType data;	<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>	<span class="comment">//指针域</span></span><br><span class="line">&#125; *LiStack;	<span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进栈：对头结点后插操作。</p>
</li>
<li><p>出栈：对头结点“后删”操作。</p>
</li>
<li><p>进栈和出栈操作都只能在栈顶一端进行（链头作为栈顶）。</p>
</li>
<li><p>实现方式推荐不带头结点。</p>
</li>
</ul>
<h1 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h1><ul>
<li>队列（Queue）：一种操作受限的线性表，<strong>只允许在一端进行插入，在另一端删除</strong>的线性表。<ul>
<li>特点：先进先出（Firstt In First Out，FIFO）</li>
</ul>
</li>
<li>重要术语：<ul>
<li>空队列：队列里面没有任何数据元素。</li>
<li>队尾：允许插入的一端。</li>
<li>队头：允许删除的一端。</li>
</ul>
</li>
<li>基本操作：<ul>
<li><code>InitQueue(&amp;Q)</code>：<strong>初始化</strong>队列。构造一个空队列 Q。</li>
<li><code>DestroyQueue(&amp;Q)</code>：<strong>销毁</strong>队列。销毁并<strong>释放</strong>队列 Q 所占用的<strong>内存空间</strong>。</li>
<li><code>Push(&amp;Q, x)</code>：<strong>进队</strong>，若队列 Q 未满，则将 x 加入使其成为新的队尾。 </li>
<li><code>Pop(&amp;Q, &amp;x)</code>：<strong>出队</strong>，若队列 Q 非空，则弹出队顶元素，并用 x 返回。</li>
<li><code>GetTop(Q, &amp;x)</code>：<strong>读队头元素</strong>。若队列 Q 非空，则用 x 返回队头元素。</li>
<li><code>QueuekEmpty(Q)</code>：判断一个队列 Q 是否为空。若 Q 为空，返回 ture，否则返回 false。</li>
</ul>
</li>
</ul>
<h1 id="队列的顺序实现"><a href="#队列的顺序实现" class="headerlink" title="队列的顺序实现"></a>队列的顺序实现</h1><ul>
<li><p>队列的顺序实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemeType date[MaxSize];	<span class="comment">//静态数组存放队列元素</span></span><br><span class="line">	<span class="type">int</span> front, rear;	<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>

<p>队头指针指向头元素；队尾指针指向下一个应该插入的位置</p>
</li>
<li><p>初始化操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemeType date[MaxSize];	<span class="comment">//静态数组存放队列元素</span></span><br><span class="line">	<span class="type">int</span> front, rear;	<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> &#123;</span><br><span class="line">    <span class="comment">//初始时 队头、队尾指针指向0</span></span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>入队操作（循环队列）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemeType date[MaxSize];	<span class="comment">//静态数组存放队列元素</span></span><br><span class="line">	<span class="type">int</span> front, rear;	<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队（循环队列）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MaxSize == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//队满则报错</span></span><br><span class="line">    Q.data[Q.rear] = x;	<span class="comment">//新元素插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;	<span class="comment">//队尾指针加1取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出队操作（循环队列）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出队（删除一个队头元素，并用x返回）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//队空则报错</span></span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取队头元素的值，用x返回</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetHead</span><span class="params">(SqQueue Q, ElemType &amp;x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//队空则报错</span></span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断队列已满&#x2F;已空</p>
<ul>
<li><p>方案一：</p>
<ul>
<li>队满条件：队尾指针的下一个位置是队头<code>(Q.rear + 1) % MaxSize == Q.front</code></li>
<li>队空条件：<code>Q.rear == Q.front</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemeType date[MaxSize];	<span class="comment">//静态数组存放队列元素</span></span><br><span class="line">	<span class="type">int</span> front, rear;	<span class="comment">//队头指针和队尾指针（初始化时 rear = front = 0)</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方案二：</p>
<ul>
<li>队满条件：<code>size == MaxSize</code></li>
<li>队空条件：<code>size == 0</code></li>
<li>插入成功 size++；删除成功 size–</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemeType date[MaxSize];	<span class="comment">//静态数组存放队列元素</span></span><br><span class="line">	<span class="type">int</span> front, rear;	<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">    <span class="type">int</span> size;	<span class="comment">//队列当前长度（初始化时：size = 0）</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方案三：</p>
<ul>
<li>队满条件：<code>front == rear &amp;&amp; tag == 1</code></li>
<li>队空条件：<code>front == rear &amp;&amp; tag == 0</code></li>
<li>插入成功 <code>tag = 0</code>；删除成功 <code>tag = 1</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemeType date[MaxSize];	<span class="comment">//静态数组存放队列元素</span></span><br><span class="line">	<span class="type">int</span> front, rear;	<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">    <span class="type">int</span> tag;	<span class="comment">//最近进行的是删除/插入（初始化时：tag = 0）</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>队尾指针指向队尾元素下一个位置</li>
<li>队尾指针指向指向队尾元素<ul>
<li>初始化：front &#x3D; 0；rear &#x3D; n-1</li>
<li>插入：队尾指针先后移，再插入元素</li>
<li>判空：(Q.rear+1)%MaxSize &#x3D;&#x3D; Q.front</li>
<li>判满：<ul>
<li>牺牲一个存储单元</li>
<li>增加辅助变量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="队列的链式实现"><a href="#队列的链式实现" class="headerlink" title="队列的链式实现"></a>队列的链式实现</h1><ul>
<li><p>队列的链式实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> &#123;</span>	<span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front, *rear;	<span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125; LinkQueue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化（带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> &#123;</span>	<span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front, *rear;	<span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列（带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span> &#123;</span><br><span class="line">    <span class="comment">//初始时 front 和 rear 都指向头结点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpy</span><span class="params">(LinkQueue Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化（不带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化队列（不带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span> &#123;</span><br><span class="line">    <span class="comment">//初始时 front 和 rear 都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear= <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpy</span><span class="params">(LinkQueue Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>入队（带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span> &#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = s;	<span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear = s;	<span class="comment">//修改表尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入队（不带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span> &#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>) &#123;	<span class="comment">//在空队列中插入第一个元素</span></span><br><span class="line">        Q.front = s;	<span class="comment">//修改队头队尾指针</span></span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		Q.rear-&gt;next = s;	<span class="comment">//新结点插入到 rear 结点之后</span></span><br><span class="line">        Q.rear = s;	<span class="comment">//修改 rear 指针</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出队（带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队头元素出队（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//空队</span></span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    x = p-&gt;data;	<span class="comment">//用变量 x 返回队头元素</span></span><br><span class="line">    Q.front-&gt;next = p-&gt;next;	<span class="comment">//修改头结点的 next 指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)	<span class="comment">//此次是最后一个极点出队</span></span><br><span class="line">        Q.rear == Q.front;	<span class="comment">//修改 rear 指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);	<span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出队（不带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队头元素出队（不带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//空队</span></span><br><span class="line">    LinkNode *p = Q.front;	<span class="comment">//p 指向此次出队的结点</span></span><br><span class="line">    x = p-&gt;data;	<span class="comment">//用变量 x 返回队头元素</span></span><br><span class="line">    Q.front = p-&gt;next;	<span class="comment">//修改 front 指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)	<span class="comment">//此次是最后一个极点出队</span></span><br><span class="line">        Q.front == <span class="literal">NULL</span>;	<span class="comment">//front 指向 NULL</span></span><br><span class="line">        Q.rear == <span class="literal">NULL</span>;	<span class="comment">//rear 指针 NULL</span></span><br><span class="line">    <span class="built_in">free</span>(p);	<span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链式存储——一般不会队满，除非内存不足。</p>
</li>
</ul>
<h1 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h1><ul>
<li>只允许从<strong>两端插入</strong>，<strong>两端删除</strong>的线性表。<ul>
<li><strong>输入</strong>受限的双端队列：只允许从<strong>一端插入</strong>，<strong>两端删除</strong>的线性表。</li>
<li><strong>输出</strong>受限的双端队列：只允许从<strong>两端插入</strong>，<strong>一端删除</strong>的线性表。</li>
</ul>
</li>
</ul>
<h1 id="栈的应用——括号匹配问题"><a href="#栈的应用——括号匹配问题" class="headerlink" title="栈的应用——括号匹配问题"></a>栈的应用——括号匹配问题</h1><ul>
<li><p>最后出现的左括号最先被匹配（LIFO）</p>
</li>
<li><p>算法实现：依次扫描所有字符，遇到左括号进栈，遇到右括号则弹出栈顶元素检查是否匹配。</p>
<ul>
<li>匹配失败情况：<ul>
<li>剩余左（右）括号</li>
<li>左右括号不匹配</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数（存在存满情况可用 链栈）</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;s)</span>;</span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>;</span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S, <span class="type">char</span> x)</span>;</span><br><span class="line"><span class="comment">//栈顶元素出栈，用 x 返回</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S, <span class="type">char</span> &amp;x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bracketCheck</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(S);	<span class="comment">//初始化一个栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            Push(S, str[i]);	<span class="comment">//匹配到左括号，入栈</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(StackEmpty(S))	<span class="comment">//匹配到右括号，且当前栈空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//匹配失效</span></span><br><span class="line">            <span class="type">char</span> topElem;</span><br><span class="line">            Pop(S, topElem);	<span class="comment">//栈顶元素出栈</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StackEmpty(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="栈的应用——表达式求值"><a href="#栈的应用——表达式求值" class="headerlink" title="栈的应用——表达式求值"></a>栈的应用——表达式求值</h1><ul>
<li><strong>中缀表达式</strong>：运算符在两个操作数中间</li>
<li><strong>后缀表达式</strong>（逆波兰表达式）：运算符在两个操作数后面</li>
<li><strong>前缀表达式</strong>（波兰表达式）：运算符在两个操作数前面</li>
<li><strong>中缀转后缀</strong>的<strong>手算</strong>方法：<ol>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>选择下一个运算符，按照（<strong>左操作数 右操作数 运算符</strong>）的方式组成一个新的操作数</li>
<li>如果还有运算符没被处理，就继续上一步</li>
</ol>
</li>
<li><strong>“左优先“</strong>原则：只要<strong>左边</strong>的运算符能先计算，就优先算<strong>左边</strong>的。保证手算和机算结果相同。</li>
<li><strong>从左往右</strong>扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对运算，合体为一个操作数。</li>
<li>用栈实现<strong>后缀表达式</strong>的<strong>计算</strong>：<ol>
<li><strong>从左往右</strong>扫描下一个元素，直到处理完所有元素</li>
<li>若扫描到操作数则压入栈，回到上一步；否则执行下一步</li>
<li>若扫描到运算符，则弹出两个栈顶元素（<strong>先出栈的是“右操作数”</strong>），执行相应运算，运算结果压回栈顶，回到第一步</li>
</ol>
</li>
<li><strong>中缀转前缀</strong>的<strong>手算</strong>方法：<ol>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>选择下一个运算符，按照（<strong>运算符 左操作数 右操作数</strong>）的方式组成一个新的操作数</li>
<li>如果还有运算符没被处理，就继续上一步</li>
</ol>
</li>
<li><strong>“右优先“</strong>原则：只要<strong>右边</strong>的运算符能先计算，就优先算<strong>右边</strong>的。保证手算和机算结果相同。</li>
<li>用栈实现<strong>前缀表达式</strong>的<strong>计算</strong>：<ol>
<li><strong>从右往左</strong>扫描下一个元素，直到处理完所有元素</li>
<li>若扫描到操作数则压入栈，回到上一步；否则执行下一步</li>
<li>若扫描到运算符，则弹出两个栈顶元素（<strong>先出栈的是“左操作数”</strong>），执行相应运算，运算结果压回栈顶，回到第一步</li>
</ol>
</li>
<li>中缀表达式转后缀表达式（<strong>机算</strong>）<ol>
<li>初始化一个栈，用于保存<strong>暂时还不能确定运算顺序的运算符</strong>。</li>
<li>从左到右处理各个元素，直到末尾。可能遇到三种情况：<ul>
<li>遇到<strong>操作数</strong>。直接假如后缀表达式。</li>
<li>遇到<strong>界限符</strong>。遇到 “(“ 直接入栈；遇到 “)” 则依次弹出栈内运算符并加入后缀表达式，直到弹出 “(“ 为止。注意：”(“ 不加入后缀表达式。</li>
<li>遇到<strong>运算符</strong>。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到 “(“ 或栈空则停止。之后再把当前运算符入栈。</li>
</ul>
</li>
<li>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</li>
</ol>
</li>
<li>中缀表达式的计算（用栈实现）：<ol>
<li>初始化两个栈，操作数栈和运算符栈</li>
<li>若扫描到操作数，压入操作数栈</li>
<li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应元素，运算结果再压回操作数栈）</li>
</ol>
</li>
</ul>
<h1 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h1><ul>
<li>函数调用的特点：最后被调用的函数最先执行结束（LIFO）</li>
<li>函数调用时，需要用到一个栈存储：<ul>
<li>调用返回地址</li>
<li>实参</li>
<li>局部变量</li>
</ul>
</li>
<li>适合用“递归”算法解决：可以把原始问题转换为<strong>属性相同</strong>，但<strong>规模较小</strong>的问题。例如：<ul>
<li>计算正整数的阶乘！</li>
<li>求斐波那契数列</li>
</ul>
</li>
<li>递归调用时，函数调用栈可称为“递归工作栈”。<ul>
<li>每进入一层递归，就将递归调用所需信息压入栈顶。</li>
<li>每退出一层递归，每退出一层递归，就从栈顶弹出相应信息。</li>
</ul>
</li>
<li>缺点：效率低，太多层递归可能会导致栈溢出；可能包含很多重复计算。</li>
<li>可以自定义栈将递归算法改造成非递归算法。</li>
</ul>
<h1 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h1><ul>
<li>树的层次遍历</li>
<li>图的广度优先遍历</li>
<li>队列在操作系统中应用<ul>
<li>多个进程争抢着使用有限的系统资源，<strong>FCFS</strong>（First Come First Service，先来先服务）是一种常用策略。</li>
<li>打印数据缓冲区。</li>
</ul>
</li>
</ul>
<h1 id="特殊矩阵压缩存储"><a href="#特殊矩阵压缩存储" class="headerlink" title="特殊矩阵压缩存储"></a>特殊矩阵压缩存储</h1><h2 id="数组的存储结构"><a href="#数组的存储结构" class="headerlink" title="数组的存储结构"></a>数组的存储结构</h2><ul>
<li>一维数组的存储结构<ul>
<li><code>ElemType a[10];</code>	</li>
<li>起始地址：LOC</li>
<li>各组元素大小相同，且物理上连续存放。<ul>
<li>数组元素 a[i] 的存放地址 &#x3D; LOC+ i*sizeof(Elemtype)</li>
<li>数组下标默认从0开始。</li>
</ul>
</li>
</ul>
</li>
<li>二维数组的存储结构<ul>
<li>两种存储策略：行优先存储；列优先存储。</li>
<li>起始地址：LOC</li>
<li>在M行N列的二维数组中<ul>
<li>若行优先存储，b[ i ] [ j ]的存储地址 &#x3D; LOC + (i * N + j) * sizeof(ElemType)</li>
<li>若列优先存储，b[ i ] [ j ]的存储地址 &#x3D; LOC + (i * M + i) * sizeof(ElemType)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="普通矩阵的存储"><a href="#普通矩阵的存储" class="headerlink" title="普通矩阵的存储"></a>普通矩阵的存储</h2><ul>
<li>可用二维数组存储</li>
<li>描述矩阵元素时行和列通常从1开始，描述数组时通常从0开始。</li>
</ul>
<h2 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="headerlink" title="对称矩阵的压缩存储"></a>对称矩阵的压缩存储</h2><ul>
<li>对称矩阵：元素值关于主对角线对称。</li>
<li>策略：只存储主对角线 + 下三角区。</li>
<li>按行优先原则将各元素存入一维数组中。<ul>
<li>共有$\frac{n * (n+1)}{2}$个元素，按行优先原则a<sub>i,j</sub>是第$\frac{i * (i -1)}{2} + j$个元素。</li>
<li>找上三角区元素：找a<sub>j,i</sub></li>
</ul>
</li>
<li>按列优先原则将各元素存入一维数组中。<ul>
<li>共有$\frac{n * (n+1)}{2}$个元素，按行优先原则a<sub>i,j</sub>是第[n + (n-1) + … + (n-j+2)] + (i-j) +1个元素。</li>
<li>找上三角区元素：找a<sub>j,i</sub></li>
</ul>
</li>
</ul>
<h2 id="三角矩阵的压缩存储"><a href="#三角矩阵的压缩存储" class="headerlink" title="三角矩阵的压缩存储"></a>三角矩阵的压缩存储</h2><ul>
<li><p>下三角矩阵：除了主对角线和下三角区，其余的元素都相同</p>
</li>
<li><p>压缩存储策略：</p>
<ul>
<li><p>按行优先原则将<strong>下三角区</strong>存入一维数组中。并在最后一个位置存储常量C。</p>
</li>
<li><p>共有$\frac{n * (n+1)}{2} + 1$个元素，按行优先原则：</p>
<ul>
<li>若i &gt;&#x3D; j，a<sub>i,j</sub>是第$\frac{i * (i -1)}{2} + j$个元素。</li>
<li>若i &lt; j，a<sub>i,j</sub>是第$\frac{n * (n + 1)}{2} + j$个元素。</li>
</ul>
</li>
<li><p>按行优先原则将<strong>上三角区</strong>存入一维数组中。并在最后一个位置存储常量C。</p>
</li>
<li><p>共有$\frac{n * (n+1)}{2} + 1$个元素，按行优先原则：</p>
<ul>
<li>若i &lt;&#x3D; j，a<sub>i,j</sub>是第[n + (n - 1) + … + (n - j + 2)] + (i - j) +1个元素。</li>
<li>若i &gt; j，a<sub>i,j</sub>是第$\frac{n * (n + 1)}{2} + j$个元素。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="三对角矩阵的压缩存储"><a href="#三对角矩阵的压缩存储" class="headerlink" title="三对角矩阵的压缩存储"></a>三对角矩阵的压缩存储</h2><ul>
<li>三对角矩阵：又称带状矩阵。主对角线及其相邻对角线元素可以不为0，其余元素均为0。（除了第一行和最后一行至多有两个不为0元素，其余行至多有三个不为0元素。</li>
<li>共有3n-2个元素，按行优先原则，a<sub>i,j</sub>是第2*i+j-2个元素。</li>
<li>第 k 个元素在第(k+2) &#x2F;3行，第k-2*i+3列。</li>
</ul>
<h2 id="稀疏矩阵的压缩存储"><a href="#稀疏矩阵的压缩存储" class="headerlink" title="稀疏矩阵的压缩存储"></a>稀疏矩阵的压缩存储</h2><ul>
<li>稀疏矩阵：非零元素远远少于矩阵元素的个数。</li>
<li>策略：<ul>
<li>顺序存储——三元组&lt;行，列，值&gt;（<code>struct</code>）</li>
<li>链式存储——十字链表法<ul>
<li>向下域down：指向同列的下一个非零元素</li>
<li>向右域right：指向同行的下一个非零元素</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>第二章 线性表</title>
    <url>/2023/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><ul>
<li>线性表示具有<strong>相同</strong>数据类型的 n（n &gt;&#x3D; 0)个<strong>数据元素</strong>的<strong>有限序列</strong>，其中 n <strong>为表长</strong>，当 n &#x3D; 0时线性表是一个<strong>空表</strong>。若用L命名线性表，则其一般表示为 L &#x3D; (a<sub>1</sub>, a<sub>2</sub>, a<sub>i</sub>, a<sub>i+1</sub>, a<sub>n</sub>)。每个数据元素所占空间一样大。<ul>
<li>有次序。</li>
<li>有限（所有整数按递增次序排列不是一个线性表）。</li>
<li>a<sub>i</sub> 是线性表中的“第 i 个”元素线性表的<strong>位序</strong>。</li>
<li>a<sub>1</sub> 是<strong>表头元素</strong>；a<sub>n</sub> 是<strong>表尾元素</strong></li>
<li>除第一个元素外，每个元素有且仅有一个<strong>直接前驱</strong>；除最后一个元素外，每个元素有且仅有一个<strong>直接后继</strong>。</li>
</ul>
</li>
</ul>
<h2 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h2><ul>
<li><code>InitList(&amp;L)</code>：<strong>初始化</strong>表。构造一个空的线性表 L，<strong>分配内存空间</strong>。</li>
<li><code>Destroy(&amp;L)</code>：<strong>销毁</strong>操作。销毁线性表，并<strong>释放</strong>线性表 L 所占用的<strong>内存空间</strong>。</li>
<li><code>LinstInsert(&amp;L, i, e)</code>：<strong>插入</strong>操作。在表L中的第 i 个位置上插入指定元素e。</li>
<li><code>ListDelete(&amp;L, i, &amp;e)</code>：删除操作。删除表 L 中的第 i 个位置的元素，并用 e 返回删除元素的值。</li>
<li><code>LocateElem(L, i)</code>：<strong>按值查找</strong>操作。在表 L 中查找具有给定关键字值的元素。</li>
<li><code>GetElem(L, i)</code>：<strong>按位查找</strong>操作。获取表 L 中第 i 个位置的元素的值。</li>
<li><code>Length(L)</code>：求表长。返回线性表 L 的长度，即 L 中数据元素的个数。</li>
<li><code>PrintList(L)</code>：输出操作。按前后顺序输出线性表 L 的所有元素值。</li>
<li><code>Empty(L)</code>：判空操作。若 L 为空表，则返回 true，否则返回 false。</li>
</ul>
<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><h2 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h2><ul>
<li>用顺序存储的方式实现线性表顺序存储。把<strong>逻辑上相邻</strong>的元素存储在<strong>物理位置上也相邻</strong>的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</li>
</ul>
<h2 id="顺序表的实现"><a href="#顺序表的实现" class="headerlink" title="顺序表的实现"></a>顺序表的实现</h2><ul>
<li><p><strong>静态</strong>分配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态</strong>分配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType* data;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">    <span class="type">int</span> lengeh;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SeqList&amp; L, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* p = L.data;</span><br><span class="line">    L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>((L.MaxSize + len) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        L.data[i] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">    L.MaxSize = L.MaxSize + len;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序表的特点</p>
<ul>
<li><strong>随机访问</strong>，即可以在 O(1) 时间内找到第i个元素。</li>
<li>存储密度高，每个结点只存储数据元素。</li>
<li>拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）。</li>
<li>插入、删除操作不方便，需要移动大量元素。</li>
</ul>
</li>
</ul>
<h2 id="顺序表的插入和删除"><a href="#顺序表的插入和删除" class="headerlink" title="顺序表的插入和删除"></a>顺序表的插入和删除</h2><ul>
<li><p><strong>插入</strong>操作。在表 L 中的第 i 个位置上插入指定元素e。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">LinstInsert</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length &gt;= MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = L.length; j &gt;= i; j--) &#123;</span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好时间复杂度：O(1)</p>
<p>最坏时间复杂度：O(n)</p>
<p>平均时间复杂度：O(n)</p>
</li>
<li><p><strong>删除</strong>操作。删除表 L 第 i 个位置的元素，并用 e 返回删除元素的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, <span class="type">int</span>&amp; e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">        L.length--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好时间复杂度：O(1)</p>
<p>最坏时间复杂度：O(n)</p>
<p>平均时间复杂度：O(n)</p>
</li>
</ul>
<h2 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h2><ul>
<li><p><strong>按位查找</strong>操作。获取表 L 中第 i 个位置的元素的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
</li>
<li><p><strong>按值查找</strong>操作。在表 L 中查找具有给定关键字值的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SeqList L, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好时间复杂度：O(1)</p>
<p>最坏时间复杂度：O(n)</p>
<p>平均时间复杂度：O(n)</p>
</li>
</ul>
<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><h2 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h2><ul>
<li><p>顺序表：每个结点中只存放数据元素。</p>
<ul>
<li>优点：可随机存取，存储密度高。</li>
<li>缺点：要求大片连续空间，改变容量不方便。</li>
</ul>
</li>
<li><p>单链表：每个结点除了存放数据元素外，还要存储指向下一个结点的指针。</p>
<ul>
<li>优点：不要求大片连续空间，改变容量方便。</li>
<li>缺点：不可随机存取，要耗费一定空间存放指针。</li>
</ul>
</li>
<li><p>结构体定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, * LinkList;</span><br></pre></td></tr></table></figure>

<p>强调这是一个<strong>单链表</strong>：使用<code>LinkList</code></p>
<p>强调这是一个<strong>结点</strong>：使用<code>LNode*</code></p>
</li>
<li><p>不带头结点的单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList&amp; L)</span> &#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;<span class="comment">// 空表，暂时还没有任何结点（防止脏数据）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>带头结点的单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList&amp; L)</span> &#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>头结点不存储数据。</p>
</li>
</ul>
<h2 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h2><ul>
<li><p><strong>插入</strong>操作。在表L中的<strong>第i个位置</strong>上插入指定元素e。</p>
<ul>
<li><strong>带头结点</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;<span class="comment">//此句和下一句不能颠倒</span></span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好时间复杂度：O(1)</p>
<p>最坏时间复杂度：O(n)</p>
<p>平均时间复杂度：O(n)</p>
<ul>
<li><strong>不带头结点</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">        LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode* p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>后插</strong>操作。在 p 结点之后插入元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextNode</span><span class="params">(LNode* p, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>)<span class="comment">// 某些情况下内存分配失败（如内存不足）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>前插</strong>操作。在 p 结点之前插入元素 e。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode* p, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;<span class="comment">//新节点s连到p之后</span></span><br><span class="line">    s-&gt;data = p-&gt;data;<span class="comment">//将p中元素复制到s中</span></span><br><span class="line">    p-&gt;data = e;<span class="comment">//p中元素覆盖为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
</li>
</ul>
<h2 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h2><ul>
<li><p><strong>删除</strong>操作。删除表中<strong>第 i 个位置</strong>的元素，并用 e 返回删除元素的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType&amp; e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* q = p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好时间复杂度：O(1)</p>
<p>最坏时间复杂度：O(n)</p>
<p>平均时间复杂度：O(n)</p>
</li>
<li><p><strong>删除指定结点p</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(LNode* p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：不满足p是最后一个结点的情况。若需要删除最后一个结点，只能从表头依次寻找p的前驱。</p>
</li>
</ul>
<h2 id="单链表的查找"><a href="#单链表的查找" class="headerlink" title="单链表的查找"></a>单链表的查找</h2><ul>
<li><p><strong>按位</strong>查找，返回第i个元素（带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode* <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode* p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平均时间复杂度：O(n)</p>
</li>
<li><p>封装（基本操作）的好处：避免重复代码，简洁、易维护。</p>
</li>
<li><p><strong>按值</strong>查找，找到<code>数据域 == e</code>的结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  LNode* <span class="title function_">LocateElem</span><span class="params">(LinkList L, ElemType e)</span> &#123;</span><br><span class="line">      LNode* p = L-&gt;next;</span><br><span class="line">      <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">          p = p-&gt;next;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">- 求表的长度。</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  <span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span> &#123;</span><br><span class="line">      <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          p = p-&gt;next;</span><br><span class="line">          len++;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
</li>
</ul>
<h2 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h2><ul>
<li><p><strong>尾插法</strong>建立单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList&amp; L)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    LNode* s,* r = L;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">9999</span>) &#123;<span class="comment">//输入9999表示结束</span></span><br><span class="line">        s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：设置一个指向表尾结点的指针。</p>
</li>
<li><p><strong>头插法</strong>建立单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList&amp; L)</span> &#123;</span><br><span class="line">      LNode *s;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">      L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      <span class="keyword">while</span>(x != <span class="number">9999</span>) &#123;<span class="comment">//输入9999表示结束</span></span><br><span class="line">          s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">          s-&gt;data = x;</span><br><span class="line">          s-&gt;next = L-&gt;next;</span><br><span class="line">          L-&gt;next = s;</span><br><span class="line">          <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> L;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"># 双链表</span><br><span class="line"></span><br><span class="line">- 单链表：无法逆向检索，有时候不太方便。</span><br><span class="line"></span><br><span class="line">- 双链表：可双向检索，存储密度略低于单链表。</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">      ElemType data;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>* <span class="title">prior</span>, * <span class="title">next</span>;</span></span><br><span class="line">  &#125;DNode, * DLinkList;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双链表的初始化（带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinklist&amp; L)</span> &#123;</span><br><span class="line">    L = (DNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双链表的插入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode* p, DNode* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;<span class="comment">//将s结点插入到p结点之后</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    	p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双链表的删除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNextDNode</span><span class="params">(DNode* p)</span> &#123;<span class="comment">//删除p结点的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode* q = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双链表的遍历</p>
<ul>
<li><strong>后向</strong>遍历</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>前向</strong>遍历</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>前向</strong>遍历（跳过<strong>头结点</strong>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;prior != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双链表不可随机存取，按位查找、按值查找操作都只能用遍历方法实现。时间复杂度O(n)</p>
</li>
</ul>
<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><ul>
<li><p>单链表：从一个结点出发只能找到后续的各个结点。</p>
</li>
<li><p>循环单链表：从一个结点出发可以找到其他任何一个结点。</p>
</li>
<li><p>初始化循环单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList&amp; L)</span> &#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = L;<span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在循环单链表中如果需要经常对表头&#x2F;表尾结点操作，可将表头&#x2F;表尾设为头结点。</p>
</li>
<li><p>初始化循环双链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinklist&amp; L)</span> &#123;</span><br><span class="line">    L = (DNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = L;</span><br><span class="line">    L-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环双链表的插入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode* p, DNode* s)</span> &#123;</span><br><span class="line">    s-&gt;next = p-&gt;next;<span class="comment">//将s结点插入到p结点之后</span></span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环双链表的删除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNextDNode</span><span class="params">(DNode* p)</span> &#123;<span class="comment">//删除p结点的后继结点q</span></span><br><span class="line">    DNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><ul>
<li><p>定义：分配一整片连续的内存空间，各个结点集中安置（用数组方式实现的链表）。</p>
<ul>
<li>与数组不同之处：数组各个元素是按照数据下标0至n依次排序的。而在每个结点包含数据元素和下一个结点的数组下标（游标）两个信息，因而静态链表不一定依次排序。</li>
<li>每个数据元素4B，每个游标4B（每个结点8B），设起始地址为addr（不是e<sub>0</sub>地址），则e<sub>1</sub>的存放地址为addr + 8*2。</li>
</ul>
</li>
<li><p>结构体定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;<span class="comment">//下一个数据下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;SLinkList[MaxSize]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SLinkList a</code>可用 SLinkList 定义“一个长度为 MaxSize 的 Node 型数组”</li>
</ul>
</li>
<li><p>初始化静态链表：</p>
<ul>
<li>把 a[0] 的 next 设为-1。</li>
<li>把其他结点的 next 设为一个特殊的值来表示空闲，如-2。</li>
</ul>
</li>
<li><p>查找：从头结点出发依次往后遍历结点。</p>
</li>
<li><p>插入位序为i的结点：</p>
<ol>
<li>找到一个空的结点，存入数据元素。</li>
<li>从头结点出发找到位序为 i-1 的结点。</li>
<li>修改新结点的 next。</li>
<li>修改 i-1 号结点的 next。</li>
</ol>
</li>
<li><p>删除某个结点：</p>
<ol>
<li>从头结点出发找到前驱结点。</li>
<li>修改前驱结点的游标。</li>
<li>被删除结点的 next 设为-2。</li>
</ol>
</li>
<li><p>静态链表的优点：增删操作不需要大量移动元素</p>
</li>
<li><p>静态链表的缺点：</p>
<ul>
<li>不能随机存取，只能从头结点开始依次往后查找。</li>
<li><strong>容量固定不可变。</strong></li>
</ul>
</li>
</ul>
<h1 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h1><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ul>
<li>都属于线性表，都是线性结构。</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><ul>
<li>顺序表：<ul>
<li>优点：支持随机存取、存储密度高。</li>
<li>缺点：大片连续空间分配不方便，改变容量不方便。</li>
</ul>
</li>
<li>链表：<ul>
<li>优点：离散的小空间分配方便，改变容量方便。</li>
<li>缺点：不可随机存取，存储密度低。</li>
</ul>
</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>初始化：<ul>
<li>顺序表：需要预分配大片连续空间。若分配内存过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源。<ul>
<li>静态分配：静态数组：容量不可改变。</li>
<li>动态分配：动态数组（malloc、free）：容量可以改变，但需要移动大量元素，时间代价高。</li>
</ul>
</li>
<li>链表：只需分配一个头结点（也可以不要头结点，只声明一个头指针），以后方便拓展。</li>
</ul>
</li>
<li>销毁：<ul>
<li>顺序表：修改<code>length</code>&#x3D;0。<ul>
<li>静态分配（静态数组）：系统自动回收空间。</li>
<li>动态分配（动态数组：malloc、free）：需要手动 free。</li>
</ul>
</li>
<li>链表：依次删除各个结点（free）。</li>
</ul>
</li>
<li>插入删除：<ul>
<li>顺序表：需要将后续元素后移&#x2F;前移。<ul>
<li>时间复杂度：O(n)。时间开销主要来自于移动元素。若数据元素很大，则移动的时间代价很高。</li>
</ul>
</li>
<li>链表：只需要修改指针。<ul>
<li>时间复杂度：O(n)。时间开销主要来自于查找元素。查找元素的时间代价更低。</li>
</ul>
</li>
</ul>
</li>
<li>查找：<ul>
<li>顺序表：<ul>
<li>按位查找：O(1)</li>
<li>按值查找：O(n)。若表内元素有序，则可在O(log<sub>2</sub>n)时间内找到。</li>
</ul>
</li>
<li>链表：<ul>
<li>按位查找：O(n)</li>
<li>按值查找：O(n)</li>
</ul>
</li>
</ul>
</li>
<li>表长难以预估、经常要增加&#x2F;删除元素：链表。</li>
<li>表长可预估、查询（搜索）操作较多：顺序表。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>第五章 树与二叉树</title>
    <url>/2024/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h1><h2 id="数的定义和基本术语"><a href="#数的定义和基本术语" class="headerlink" title="数的定义和基本术语"></a>数的定义和基本术语</h2><ul>
<li>树：从树根生发，逐级分支。</li>
<li>空树：结点数为0的树。</li>
<li>非空树的特性：<ul>
<li>有且仅有一个根结点。</li>
<li>没有后继的结点称为“叶子结点”（或终端结点）。</li>
<li>有后继的结点称为“分支结点”（或非终端结点）。</li>
<li>除了根结点外，任何一个结点都<strong>有且仅有一个</strong>前驱。</li>
<li>每个结点可以有一个或多个后驱。</li>
</ul>
</li>
<li>树是 n （n &gt;&#x3D; 0）个<strong>结点</strong>的有限集合，n &#x3D; 0 时，称为<strong>空树</strong>，这是一种特殊情况。在任意一颗<strong>非空树</strong>中应满足：<ol>
<li>有且仅有一个特定的称为<strong>根</strong>的结点。</li>
<li>当 n &gt; 1 时，其余结点可分为 m (m &gt; 0)个<strong>互不相交的有限集合</strong> T<sub>1</sub>,T<sub>2</sub>,…T<sub>m</sub>，其中每个集合本身又是一颗树，并且称为根结点的<strong>子树</strong>。</li>
</ol>
</li>
<li>树是递归定义的数据结构。</li>
<li>结点之间的关系描述：<ul>
<li>祖先结点</li>
<li>子孙结点</li>
<li>双亲结点（父结点）</li>
<li>孩子结点</li>
<li>兄弟结点</li>
<li>堂兄弟结点</li>
<li>两个结点之间的<strong>路径</strong>：只能从上往下</li>
<li><strong>路径长度</strong>：经过几条边</li>
</ul>
</li>
<li>结点和树的属性描述：<ul>
<li>结点的层次（深度）——从上往下数</li>
<li>结点的高度——从下往上数</li>
<li>树的高度（深度）——总共多少层</li>
<li><strong>结点的度</strong>——有几个孩子（分支）</li>
<li><strong>树的度</strong>——各结点的度的最大值</li>
</ul>
</li>
<li>有序树：逻辑上看，树中结点的各子树从左至右是<strong>有次序的</strong>，不能互换。</li>
<li>有序树：逻辑上看，树中结点的各子树从左至右是<strong>无次序的</strong>，不能互换。</li>
<li>森林：森林是 m(M &gt;&#x3D; 0)棵互不相交的树的集合。</li>
</ul>
<h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><ul>
<li><p>结点数 &#x3D; 总度数 + 1</p>
</li>
<li><p>树的度——各结点度的最大值</p>
</li>
<li><p>m叉树——每个结点最多只能有m个孩子的树</p>
</li>
<li><table>
<thead>
<tr>
<th>度为 m 的树</th>
<th>m 叉树</th>
</tr>
</thead>
<tbody><tr>
<td>任意结点的度 &lt;&#x3D; m（最多 m 个孩子）</td>
<td>任意结点的度 &lt;&#x3D; m（最多 m 个孩子）</td>
</tr>
<tr>
<td>至少有一个结点度 &#x3D; m（有 m 个孩子）</td>
<td>允许所有结点的度都 &lt;  m</td>
</tr>
<tr>
<td>一定是非空树，至少有 m + 1 个结点</td>
<td>可以是空树</td>
</tr>
</tbody></table>
</li>
<li><p>度为 m 的树第 i 层至多有 m<sup>i-1</sup>个结点（i &gt;&#x3D; 1）</p>
<ul>
<li>m 叉树第 i 层至多有m<sup>i-1</sup>个结点（i &gt;&#x3D; 1）</li>
</ul>
</li>
<li><p>高度为 h 的 m 叉树至多有$\frac{m^h-1}{m-1}$（等比求和）</p>
</li>
<li><p>高度为 h 的 m 叉树至少有 h 个结点；高度为 h 同时度为 m 的树至少有 h+m-1 个结点。</p>
</li>
<li><p>具有 n 个结点的 m 叉树的最小高度为 log<sub>m</sub>(n(m-1)+1)。</p>
</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的定义和基本术语"><a href="#二叉树的定义和基本术语" class="headerlink" title="二叉树的定义和基本术语"></a>二叉树的定义和基本术语</h2><ul>
<li>m 叉树是 n （n &gt;&#x3D; 0）个结点的有限集合：<ul>
<li>或者为<strong>空二叉树</strong>，即 n &#x3D; 0。</li>
<li>或者由一个<strong>根结点</strong>和两个互不相交的被称为根的<strong>左子树</strong>和<strong>右子树</strong>组成。左子树和右子树分别是一颗二叉树。</li>
<li>特点：<ul>
<li>每个结点至多只有两棵子树</li>
<li>左右子树不能颠倒（二叉树<strong>是有序树</strong>）</li>
</ul>
</li>
</ul>
</li>
<li>二叉树是递归定义的数据结构。</li>
<li>二叉树的五种状态：<ul>
<li>空二叉树</li>
<li>只有左子树</li>
<li>只有右子树</li>
<li>只有根结点</li>
<li>左右子树都有</li>
</ul>
</li>
<li>几个特殊的二叉树：<ul>
<li><strong>满二叉树</strong>。一棵高度为 h，且含有2<sup>h</sup>-1个结点的二叉树。特点：<ul>
<li>只有最后一层有叶子结点。</li>
<li>不存在度为1的结点。</li>
<li>按层序从1开始编号，结点 i 的左孩子为 2i，右孩子为 2i+1；结点 i 的父结点为 i&#x2F;2。</li>
</ul>
</li>
<li><strong>完全二叉树</strong>。当且进当其每个结点都与高度为 h 的满二叉树中编号为 1~n 的结点一一对应时，称为完全二叉树。特点：<ul>
<li>只有最后两层可能有叶子结点。</li>
<li>最多只有一个度为1的结点。</li>
<li>按层序从1开始编号，结点 i 的左孩子为 2i，右孩子为 2i+1；结点 i 的父结点为 i&#x2F;2。</li>
<li>i &lt;&#x3D; n&#x2F;2 为分支结点，i &gt; n&#x2F;2 为叶子结点。</li>
<li>如果某结点只有一个孩子，那么一定是左孩子。</li>
</ul>
</li>
<li><strong>二叉排序树</strong>。一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：<ul>
<li><strong>左子树</strong>上所有结点的<strong>关键字</strong>均<strong>小于根结点</strong>的关键字。</li>
<li><strong>右子树</strong>上所有结点的<strong>关键字</strong>均<strong>大于根结点</strong>的关键字。</li>
<li>左子树和右子树又各是一颗二叉排序树。</li>
</ul>
</li>
<li><strong>平衡二叉树</strong>。树上任一结点的<strong>左子树</strong>和<strong>右子树</strong>的<strong>深度之差不超过1</strong>。<ul>
<li>平衡二叉树能有更高的搜索效率。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ul>
<li>设非空二叉树度为0、1和2的结点个数分别为n<sub>0</sub>、n<sub>1</sub>和n<sub>2</sub>，则 n<sub>0</sub> &#x3D; n<sub>2</sub> + 1（叶子结点比二分支结点多一个）</li>
<li>二叉树第 i 层至多有 2<sup>i-1</sup>个结点（i &gt;&#x3D; 1）</li>
<li>高度为 h 的二叉树至多有$2^h-1$（等比求和）</li>
<li>具有 n 个(n &gt; 0)结点的完全二叉树的高度 h 为 log<sub>2</sub>(n+1) 或 log<sub>2</sub>n + 1</li>
<li>对于完全二叉树，可以由结点数 n 推出度为0、1和2的结点个数分别为n<sub>0</sub>、n<sub>1</sub>和n<sub>2</sub><ul>
<li>完全二叉树最多只有一个度为1的结点，即 n<sub>1</sub> &#x3D; 0或1，而n<sub>0</sub> &#x3D; n<sub>2</sub> + 1故n<sub>0 </sub>+ n<sub>2</sub> 一定是奇数<ul>
<li>若完全二叉树有 2k （偶数）个结点，则必有n<sub>1</sub> &#x3D; 1，n<sub>0</sub> &#x3D; k，n<sub>2</sub> &#x3D; k-1</li>
<li>若完全二叉树有 2k-1 （奇数）个结点，则必有n<sub>1</sub> &#x3D; 0，n<sub>0</sub> &#x3D; k，n<sub>2</sub> &#x3D; k-1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h3><ul>
<li><p>顺序存储的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    ElemType value;	<span class="comment">//结点中的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;	<span class="comment">//结点是否为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode t[MaxSize];</span><br></pre></td></tr></table></figure>

<p>定义一个长度为 MaxSize 的数组 t，按照从上至下、从左至右的顺序依次存储<strong>完全二叉树</strong>中的各个结点。</p>
</li>
<li><p>几个重要的基本操作</p>
<ul>
<li>i 的左孩子—— 2i</li>
<li>i 的右孩子—— 2i+1</li>
<li>i 的父结点—— i&#x2F;2</li>
<li>i 所在的层次—— log<sub>2</sub>(n+1))或 log<sub>2</sub>n + 1</li>
</ul>
</li>
<li><p>若<strong>完全二叉树</strong>中共有 n 个结点</p>
<ul>
<li>判断 i 是否有左孩子——2i &lt;&#x3D; n</li>
<li>判断 i 是否有右孩子——2i+1 &lt;&#x3D; n</li>
<li>判断 i 是否是叶子或分支结点——i &gt; n&#x2F;2</li>
</ul>
</li>
<li><p>如果不是<strong>完全二叉树</strong>，依然按层序将各结点顺序存储，则无法从结点编号反映出结点间的逻辑关系。</p>
</li>
<li><p>二叉的顺序存储中，一定要把二叉树的结点编号与<strong>完全二叉树</strong>对应起来。</p>
</li>
<li><p>最坏情况：高度为 h 且只有 h 个结点的单支树（所有结点只有右孩子），也至少需要 2<sup>h</sup>-1个存储单元。</p>
</li>
</ul>
<h3 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h3><ul>
<li><p>链式存储的代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;	<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<p>n 个结点的二叉链表共有 n+1 个空链域。</p>
</li>
<li><p>二叉树的建立</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ElemType</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一棵空树</span></span><br><span class="line">BiTree root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根结点</span></span><br><span class="line">root = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));</span><br><span class="line">root-&gt;data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode * p = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;lchild = p;	<span class="comment">//作为根结点的左孩子</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>三叉链表——方便找父结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;	<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">//左、右孩子指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span>	<span class="comment">//父结点指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二叉树的先-x2F-中-x2F-后序遍历"><a href="#二叉树的先-x2F-中-x2F-后序遍历" class="headerlink" title="二叉树的先&#x2F;中&#x2F;后序遍历"></a>二叉树的先&#x2F;中&#x2F;后序遍历</h2><ul>
<li><p>遍历：按照某种次序把所有结点都访问一遍。</p>
</li>
<li><p>层次遍历：基于树的层次特性确定的次序规则。</p>
</li>
<li><p>先&#x2F;中&#x2F;后序遍历：基于树的递归特性确定的次序规则。</p>
<ul>
<li>先序遍历：根左右（NLR）</li>
<li>中序遍历：左根右（LNR）</li>
<li>后序遍历：左右根（LRN）</li>
</ul>
</li>
<li><p>二叉树的递归特性：</p>
<ul>
<li>要么是个空二叉树。</li>
<li>要么就是由“根结点+左子树+右子树”组成的二叉树。</li>
</ul>
</li>
<li><p>算术表达式的“分析树”</p>
<ul>
<li>先序遍历：根左右 -&gt; 前缀表达式</li>
<li>中序遍历：左根右 -&gt; 中缀表达式（需要加界限符）</li>
<li>后序遍历：左右根 -&gt; 后缀表达式</li>
</ul>
</li>
<li><p><strong>先序遍历</strong>的代码实现</p>
<ol>
<li>若二叉树为空，则什么都不做</li>
<li>若二叉树非空：<ol>
<li>访问根节点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        visit(T);	<span class="comment">//访问根结点</span></span><br><span class="line">        PreOrder(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>中序遍历</strong>的代码实现</p>
<ol>
<li>若二叉树为空，则什么都不做</li>
<li>若二叉树非空：<ol>
<li>先序遍历左子树</li>
<li>访问根节点</li>
<li>先序遍历右子树</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        InOrder(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        visit(T);	<span class="comment">//访问根结点</span></span><br><span class="line">        InOrder(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>后序遍历</strong>的代码实现</p>
<ol>
<li>若二叉树为空，则什么都不做</li>
<li>若二叉树非空：<ol>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
<li>访问根节点</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        PostOrder(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">        visit(T);	<span class="comment">//访问根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先序遍历——第一次路过时访问结点</p>
</li>
<li><p>中序遍历——第二次路过时访问结点</p>
</li>
<li><p>后序遍历——第三次路过时访问结点</p>
</li>
<li><p>应用：求树的深度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="comment">//树的深度 = Max(左子树深度，右子树深度)+1</span></span><br><span class="line">        <span class="keyword">return</span> l &gt; r ? l+<span class="number">1</span> : r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><ul>
<li><p>算法思想：</p>
<ol>
<li>初始化一个辅助<strong>队列</strong></li>
<li>根结点入队</li>
<li>若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾（如果有的话）</li>
<li>重复上一步直至队列为空</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点（链式存储）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    BiTNode * data;	<span class="comment">//存指针而不是结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *front, *rear;	<span class="comment">//队头队尾</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);	<span class="comment">//初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q, T);	<span class="comment">//将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(Q)) &#123;	<span class="comment">//队列不空则循环</span></span><br><span class="line">        DeQueue(Q, p);	<span class="comment">//队列结点出队</span></span><br><span class="line">        visit(p);	<span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q, p-&gt;lchild);	<span class="comment">//左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q, p-&gt;rchild);	<span class="comment">//右孩子入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><ul>
<li>一个中&#x2F;前&#x2F;后&#x2F;层序遍历序列可能对应<strong>多种</strong>二叉树形态。<strong>中序</strong> + 前&#x2F;后&#x2F;层序遍历可得到唯一二叉树。</li>
<li>由前序&#x2F;后序&#x2F;层序找到树的根结点，并根据中序序列划分左右子树，再找到左右子树根结点。</li>
</ul>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><ul>
<li><p>如何找到指定结点 p 在中序遍历序列中的前驱和后继：从根结点出发，重新进行一次中序遍历，指针 q 记录当前访问的结点，指针 pre 记录上一个被访问的结点。</p>
</li>
<li><p>当 q &#x3D;&#x3D; p 时，pre 为前驱。</p>
</li>
<li><p>当 pre &#x3D;&#x3D; p 时，q 为后继。</p>
</li>
<li><p>中序线索二叉树：</p>
<ul>
<li>前驱线索：左孩子指针充当</li>
<li>后继线索：右孩子指针充当</li>
</ul>
</li>
<li><p>线索二叉树的存储结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点（链式存储）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThtreadNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag, rtag;	<span class="comment">//左、右线索标志 tag:1 表示线索  tag:0 表示孩子</span></span><br><span class="line">&#125; TreadNode, *TreadTree;	</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二叉树线索化"><a href="#二叉树线索化" class="headerlink" title="二叉树线索化"></a>二叉树线索化</h2><ul>
<li><p>借用 pre 指针找到中序前驱</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        InOrder(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        visit(T);	<span class="comment">//访问根结点</span></span><br><span class="line">        InOrder(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点 q</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTNode *q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q == p)	<span class="comment">//当前访问结点刚好是结点 p</span></span><br><span class="line">        final = pre;	<span class="comment">//找到 p 的前驱</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        pre = q;	<span class="comment">//pre 指向当前访问的结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助全局变量，用于查找结点 p 的前驱</span></span><br><span class="line">BiTNode * p;	<span class="comment">//p 指向目标结点</span></span><br><span class="line">BiTNode * pre == <span class="literal">NULL</span>;	<span class="comment">//指向当前访问的结点的前驱</span></span><br><span class="line">BiTNode * final == <span class="literal">NULL</span>;	<span class="comment">//用于记录最终结果</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>中序线索化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量 pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树 T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span> &#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;	<span class="comment">//pre初始化为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;	<span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        InThread(T);	<span class="comment">//中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;	<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThtreadNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag, rtag;	<span class="comment">//左、右线索标志 tag:1 表示线索  tag:0 表示孩子</span></span><br><span class="line">&#125; TreadNode, *TreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        InThread(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        visit(T);	<span class="comment">//访问根结点</span></span><br><span class="line">        InThread(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;	<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;	<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先序线索化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量 pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树 T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatePreThread</span><span class="params">(ThreadTree T)</span> &#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;	<span class="comment">//pre初始化为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;	<span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">       PreThread(T);	<span class="comment">//先序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;	<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThtreadNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag, rtag;	<span class="comment">//左、右线索标志 tag:1 表示线索  tag:0 表示孩子</span></span><br><span class="line">&#125; TreadNode, *TreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        visit(T);	<span class="comment">//访问根结点</span></span><br><span class="line">        <span class="keyword">if</span> (T-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        	PreThread(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreThread(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;	<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;	<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序线索化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量 pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序线索化二叉树 T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatePostThread</span><span class="params">(ThreadTree T)</span> &#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;	<span class="comment">//pre初始化为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;	<span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">       PostThread(T);	<span class="comment">//后序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;	<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThtreadNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag, rtag;	<span class="comment">//左、右线索标志 tag:1 表示线索  tag:0 表示孩子</span></span><br><span class="line">&#125; TreadNode, *TreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PreThread(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreThread(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">        visit(T);	<span class="comment">//访问根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;	<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;	<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线索二叉树——找前驱-x2F-后继"><a href="#线索二叉树——找前驱-x2F-后继" class="headerlink" title="线索二叉树——找前驱&#x2F;后继"></a>线索二叉树——找前驱&#x2F;后继</h2><ul>
<li><p>在中序线索二叉树中找到指定结点 *p 的中序后继 next</p>
<ul>
<li>若 p-&gt;rtag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;rchild</li>
<li>若 p-&gt;rtag &#x3D;&#x3D; 0，则 next &#x3D; p的右子树中最左下结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到以 p 为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span> &#123;</span><br><span class="line">    <span class="comment">//循环找到最左下结点（不一定是叶结点）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在中序线索二叉树中找到结点 p 的后继结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Nextnode</span><span class="params">(ThreadNode *p)</span> &#123;</span><br><span class="line">    <span class="comment">//右子树中最左下结点</span></span><br><span class="line">    <span class="keyword">if</span>  (p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;	<span class="comment">//rtag == 1直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行中序遍历（利用线索实现的非递归算法）	空间复杂度：O(1)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadNode *T)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = Firstnode(T); p != <span class="literal">NULL</span>; p = Nextnode(p))</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在中序线索二叉树中找到指定结点 *p 的中序前驱 pre</p>
<ul>
<li>若 p-&gt;ltag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;lchild</li>
<li>若 p-&gt;ltag &#x3D;&#x3D; 0，则 next &#x3D; p的左子树中最右下结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到以 p 为根的子树中，最后一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Lastnode</span><span class="params">(ThreadNode *p)</span> &#123;</span><br><span class="line">    <span class="comment">//循环找到最右下结点（不一定是叶结点）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在中序线索二叉树中找到结点 p 的前驱结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Prenode</span><span class="params">(ThreadNode *p)</span> &#123;</span><br><span class="line">    <span class="comment">//左子树中最右下结点</span></span><br><span class="line">    <span class="keyword">if</span>  (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Firstnode(p-&gt;lchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild;	<span class="comment">//rtag == 1直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RevInorder</span><span class="params">(ThreadNode *T)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = Lastnode(T); p != <span class="literal">NULL</span>; p = Prenode(p))</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在先序线索二叉树中找到指定结点 *p 的先序后继 next</p>
<ul>
<li>若 p-&gt;rtag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;rchild</li>
<li>若 p-&gt;rtag &#x3D;&#x3D; 0，则 <ul>
<li>若 p 有左孩子，则先序后继为左孩子</li>
<li>若 p 没有左孩子，则先序后继为右孩子</li>
</ul>
</li>
</ul>
</li>
<li><p>在先序线索二叉树中找到指定结点 *p 的先序前驱 pre</p>
<ul>
<li>若 p-&gt;ltag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;lchild</li>
<li>若 p-&gt;ltag &#x3D;&#x3D; 0，则<ul>
<li>p 必有左孩子。由于先序遍历中左右子树中的结点只可能是根的后继，不可能是前驱。只能从头开始先序遍历找前驱。</li>
<li>若改用三叉链表可以找到父节点<ul>
<li>p 为左孩子，则 p 的父结点即为其前驱</li>
<li>p 为右孩子，<ul>
<li>其左兄弟为空，则 p 的父结点即为其前驱</li>
<li>其左兄弟非空，则 p 的前驱为左兄弟子树中最后一个被先序遍历的结点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在后序线索二叉树中找到指定结点 *p 的后序前驱 pre</p>
<ul>
<li>若 p-&gt;ltag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;lchild</li>
<li>若 p-&gt;ltag &#x3D;&#x3D; 0，则 p 必有左孩子<ul>
<li>若 p 有右孩子，则后序前驱为右孩子</li>
<li>若 p 没有右孩子，则后序前驱为左孩子</li>
</ul>
</li>
</ul>
</li>
<li><p>在后序线索二叉树中找到指定结点 *p 的先序后继 next</p>
<ul>
<li>若 p-&gt;rtag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;rchild</li>
<li>若 p-&gt;rtag &#x3D;&#x3D; 0，则 <ul>
<li>p 必有右孩子。由于先序遍历中左右子树中的结点只可能是根的后继，不可能是前驱。只能从头开始先序遍历找前驱。</li>
<li>若改用三叉链表可以找到父节点<ul>
<li>p 为右孩子，则 p 的父结点即为其前驱</li>
<li>p 为左孩子，<ul>
<li>其右兄弟为空，则 p 的父结点即为其前驱</li>
<li>其右兄弟非空，则 p 的前驱为右兄弟子树中第一个被后序遍历的结点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h1><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><ul>
<li><p>双亲表表示法（顺序存储）</p>
<ul>
<li>用数组顺序存储各个结点。每个结点中保存<strong>数据元素、指向双亲结点（父节点）的“指针”</strong>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100	<span class="comment">//树中最多结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">//树的结点定义</span></span><br><span class="line">    ElemType data;	<span class="comment">//数据元素</span></span><br><span class="line">    <span class="type">int</span> parent;	<span class="comment">//双亲位置域</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];	<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> n;	<span class="comment">//结点数</span></span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优缺点：</p>
<ul>
<li><p>优点：找双亲（父结点）方便</p>
</li>
<li><p>缺点：找孩子不方便，只能从头到尾遍历整个数组</p>
</li>
<li><p>适用于“找父亲“多，”找孩子“少的应用场景。如：并查集</p>
</li>
</ul>
</li>
<li><p>双亲表示法也可表示<strong>森林</strong>，每棵树的根结点双亲指针 &#x3D; -1。</p>
</li>
</ul>
</li>
<li><p>孩子表示法（顺序存储 + 链式存储）</p>
<ul>
<li>用数组顺序存储各个节点。每个结点中保存<strong>数据元素、孩子链表头指针</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> child;	<span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>	<span class="comment">//下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>	<span class="comment">//第一个孩子</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n, r;</span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure>

<ul>
<li>优缺点：<ul>
<li>优点：找孩子很方便</li>
<li>缺点：找双亲（父结点）不方便，只能遍历每个链表</li>
<li>适用于“找父亲“少，”找孩子“多的应用场景。如：服务流程树</li>
</ul>
</li>
<li>用孩子表示法存储<strong>森林</strong>，需要记录多个根的位置。</li>
</ul>
</li>
<li><p>孩子兄弟表示法（链式存储）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure>

<ul>
<li>树的孩子兄弟表示法与二叉树类似，采用<strong>二叉链表</strong>实现。每个结点内保存<strong>数据元素</strong>和<strong>两个指针</strong>，但两个指针的含义和二叉树结点不同。</li>
<li>存储<strong>森林</strong>时，森林中每棵树的根结点视为平级的兄弟关系。</li>
</ul>
</li>
</ul>
<h2 id="树、森林和二叉树的转化"><a href="#树、森林和二叉树的转化" class="headerlink" title="树、森林和二叉树的转化"></a>树、森林和二叉树的转化</h2><ul>
<li>树转换为二叉树<ol>
<li>先在二叉树中，画一个根结点。</li>
<li>按“树的层序”依次处理每个结点。<ul>
<li>处理一个结点的方法是：如果当前处理的结点在树中有孩子，就把所有孩子结点用右指针串成一串，并在二叉树中把第一个孩子挂在当前结点的左指针上。</li>
</ul>
</li>
</ol>
</li>
<li>森林转换为二叉树<ol>
<li>先把所有树的根结点画出来，在二叉树中用右指针串成一串。</li>
<li>按“森林的层序”依次处理每个结点。<ul>
<li>处理一个结点的方法是：如果当前处理的结点在树中有孩子，就把所有孩子结点用右指针串成一串，并在二叉树中把第一个孩子挂在当前结点的左指针上。</li>
</ul>
</li>
</ol>
</li>
<li>二叉树转换为树</li>
</ul>
<ol>
<li>先画出树的根结点</li>
<li>从树的根结点开始，按“树的层序”恢复每个结点的孩子<ul>
<li>如何恢复一个结点的孩子，在二叉树中，如果当前处理的结点有左孩子，就把左孩子和一整串右指针拆下来，按顺序挂在当前结点的下面。</li>
</ul>
</li>
</ol>
<ul>
<li>二叉树转换为森林<ol>
<li>先把二叉树的根结点和一整串右指针拆下来，作为多棵树的根结点</li>
<li>按“森林的层序”恢复每个结点的孩子<ul>
<li>如何恢复一个结点的孩子，在二叉树中，如果当前处理的结点有左孩子，就把左孩子和一整串右指针拆下来，按顺序挂在当前结点的下面。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="树、森林的遍历"><a href="#树、森林的遍历" class="headerlink" title="树、森林的遍历"></a>树、森林的遍历</h2><ul>
<li><p>树的先根遍历（深度优先遍历）。若树非空，先访问根结点，再依次对每棵子树进行先根遍历。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树的先根遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (R != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        visit(R);	<span class="comment">//访问根结点</span></span><br><span class="line">        <span class="keyword">while</span> (R 还有下一个子树 T)</span><br><span class="line">            Prerder(T);	<span class="comment">//先根遍历下一棵子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>树的后根遍历（深度优先遍历）。若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树的后根遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode *R)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (R != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (R 还有下一个子树 T)</span><br><span class="line">            Prerder(T);	<span class="comment">//后根遍历下一棵子树</span></span><br><span class="line">        visit(R);	<span class="comment">//访问根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树的后根遍序列与这棵树相应二叉树的中序序列相同。</p>
</li>
<li><p>数的层次遍历（用队列实现）（广度优先遍历）</p>
<ol>
<li>若树非空，则根结点入队</li>
<li>若队列非空，队头元素出队并访问，同时该元素的孩子依次入队</li>
<li>重复上一步直至队空</li>
</ol>
</li>
<li><p>先序遍历森林。</p>
<ul>
<li>若森林为非空，则按如下规则进行遍历：<ul>
<li>访问森林中第一棵树的根结点</li>
<li>先序遍历第一棵树中根结点的子树森林</li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林</li>
</ul>
</li>
<li>效果等同于依次对二叉树的先序遍历。</li>
</ul>
</li>
<li><p>中序遍历森林。</p>
<ul>
<li>若森林为非空，则按如下规则进行遍历：<ul>
<li>中序遍历森林中第一棵树的根结点的子树森林</li>
<li>访问第一棵树的根结点</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林</li>
</ul>
</li>
<li>效果等同于依次对各个树进行后根遍历</li>
<li>转化为二叉树后效果等同于依次对二叉树的中序遍历</li>
</ul>
</li>
</ul>
<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><ul>
<li>结点的<strong>权</strong>：有某种现实含义的数值（如：表示结点的重要性等）</li>
<li><strong>结点的带权路径长度</strong>：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积</li>
<li><strong>树的带权路径长度</strong>：树中所有<strong>叶结点</strong>的带权路径长度之和（WPL，Weighted Path Length）</li>
<li>在含有 n 个带权叶结点的二叉树中，其中<strong>带权路径长度（WPL）最小的二叉树</strong>称为<strong>哈夫曼树</strong>，也称<strong>最优二叉树</strong>。</li>
<li>哈夫曼树的构造：给定 n 个权值分别为 w<sub>1</sub>，w<sub>2</sub>，…，w<sub>n</sub> 的结点。<ol>
<li>将这 n 个结点分别作为 n 棵仅含一个结点的二叉树，构成森林 F。</li>
<li>构造一个新结点，从 F 中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。</li>
<li>从 F 中删除刚才选出的两棵树，同时将新得到的树加入 F 中。</li>
<li>重复以上两步，直至 F 中只剩下一棵树为止。</li>
</ol>
</li>
<li>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。</li>
<li>哈夫曼树的结点总数为 2n-1。</li>
<li>哈夫曼树中不存在度为1的结点。</li>
<li>哈夫曼树并不唯一，但 WPL 必然相同且为最优。</li>
<li>固定长度编码——每个字符用相等长度的二进制位表示。</li>
<li>可变长度编码——允许对不同字符用不等长的二进制位表示。</li>
<li>若没有一个编码是另一个编码的前缀，则称这样的编码为<strong>前缀编码</strong>。非前缀编码有歧义。</li>
<li>由哈夫曼树得到哈夫曼编码——字符集中的每个字符作为一个叶子结点，每个字符出现的频度作为结点的权值，再构建哈夫曼树。</li>
</ul>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><ul>
<li><p>用互不相交的树，表示多个“集合”	</p>
<ul>
<li>如何“<strong>查</strong>”到一个元素到底属于哪一个集合——从指定元素出发，找到根结点</li>
<li>如何把两个集合“<strong>并</strong>”为一个集合——让一棵树成为另一棵树的子树即可</li>
</ul>
</li>
<li><p>“并查集”的存储结构：参考树的双亲表示法</p>
<ul>
<li>集合的两个基本操作——“并”和“查”<ul>
<li>Find——“查”操作：确定一个指定元素所属集合</li>
<li>Union——“并”操作：将两个不相交的集合合并为一个</li>
<li>并查集（Disjoint Set）是逻辑结构——集合的一种具体实现，只进行“并”和“查”两种基本操作</li>
</ul>
</li>
</ul>
</li>
<li><p>“并查集”的代码实现——初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 13</span></span><br><span class="line"><span class="type">int</span> UFSets[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化并查集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initial</span><span class="params">(<span class="type">int</span> S[])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">        S[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>“并查集”的代码实现——并、查</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Find “查”操作，找 x 所属集合（返回 x 所属根结点）	最坏时间复杂度：O(n)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x] &gt;= <span class="number">0</span>)	<span class="comment">//循环寻找 x 的根</span></span><br><span class="line">        x = S[x];</span><br><span class="line">    <span class="keyword">return</span> x;	<span class="comment">//根的S[]小于0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Union “并”操作，将两个集合合并为一个	时间复杂度：O(1)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> Root1, <span class="type">int</span> Root2)</span> &#123;</span><br><span class="line">    <span class="comment">//要求 Root1 与 Root2 是不同的集合</span></span><br><span class="line">    <span class="keyword">if</span> (Root1 == Root2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将根 Root2 连接到另一根 Root1 下面</span></span><br><span class="line">    S[Root2] = Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优化思路：在每次 Union 操作构建树的时候，尽量不让树长高</p>
<ul>
<li>用根结点的绝对值表示树的结点总数（例如 -6 而不是 -1）</li>
<li>Union 操作，让小树合并到大树</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Union “并”操作，小树合并到大树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> Root1, <span class="type">int</span> Root2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Root1 == Root2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (S[Root2] &gt; S[Root1]) &#123;	<span class="comment">//Root2 结点数更少</span></span><br><span class="line">        S[Root1] += S[Root2];	<span class="comment">//累加结点总数</span></span><br><span class="line">        S[Root2] = Root1;	<span class="comment">//小树合并到大树</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        S[Root2] += S[Root1];	<span class="comment">//累加结点总数</span></span><br><span class="line">        S[Root1] = Root2;	<span class="comment">//小树合并到大树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法构造的树高不超过 log<sub>2</sub>n+1</p>
</li>
<li><p>并查集的进一步优化</p>
<ul>
<li><p>Find 操作的优化（压缩路径）：先找到根结点，再将查找路径上所有结点都挂到根结点下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Find “查”操作优化，先找到根结点，再进行“压缩路径”</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> root = x;</span><br><span class="line">    <span class="keyword">while</span> (S[root] &gt;= <span class="number">0</span>)</span><br><span class="line">        root = S[root];	<span class="comment">//循环找到根</span></span><br><span class="line">    <span class="keyword">while</span> (x != root) &#123;	<span class="comment">//压缩路径	</span></span><br><span class="line">        <span class="type">int</span> t = S[x];	<span class="comment">//t 指向 x 的父结点下</span></span><br><span class="line">        S[x] = root;	<span class="comment">//x 直接挂到根结点下</span></span><br><span class="line">        x = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;	<span class="comment">//返回根结点编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次 Find 操作，先找根，再“压缩路径”，可使树的高度不超过 O(α(n))。α(n) 是一个增长很缓慢的函数，对于常见的 n 值，通常 α(n) &lt;&#x3D; 4，因此优化后并查集的 Find、Union 操作时间开销都很低。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>第四章 串</title>
    <url>/2024/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="定义和基本操作"><a href="#定义和基本操作" class="headerlink" title="定义和基本操作"></a>定义和基本操作</h1><ul>
<li><p><strong>串</strong>，即<strong>字符串（String）</strong>是由零个或多个<strong>字符</strong>组成的有限序列。一般记为 S &#x3D; ‘a<sub>1</sub>a<sub>2</sub>……a<sub>n</sub>‘（n &gt;&#x3D; 0)。其中，S 是<strong>串名</strong>，单引号（有的地方用双引号）括起来的字符序列是串的值；a<sub>i</sub>可以是字母、数字或其他字符；串中字符的个数 n 称为<strong>串的长度</strong>。n &#x3D; 0时的串称为<strong>空串</strong>（用∅表示）</p>
</li>
<li><p>子串：串中任意个连续的字符组成 的子序列。</p>
</li>
<li><p>主串：包含子串的串。</p>
</li>
<li><p>字符在主串中的位置：字符在串中的序号。</p>
</li>
<li><p>子串在主串中的位置：子串的第一个字符在主串中的位置。</p>
</li>
<li><p>空串和空格串：</p>
<ul>
<li>M &#x3D; ‘’（空串）</li>
<li>N &#x3D; ‘   ‘（三个空格符号组成的空格串，每个空格字符占1B）</li>
</ul>
</li>
<li><p>串是一种特殊的线性表，数据元素之间呈线性关系。</p>
</li>
<li><p>串的数据对象限定为字符集（如中文字符、英文字符、数字字符和标点符号等）。</p>
</li>
<li><p>串的基本操作，如增删改查等<strong>通常以子串为操作对象</strong>。</p>
</li>
<li><p>基本操作：</p>
<ul>
<li><code>StrAssign(&amp;T, chars)</code>：赋值操作。把串T赋值为 chars。</li>
<li><code>StrCopy(&amp;T, S)</code>：复制操作。由串 S 复制得到串 T。</li>
<li><code>StrEmpty(S)</code>：判空操作。若 S 为空串，则返回 TRUE，否则返回 FALSE。</li>
<li><code>StrLength(S)</code>：求串长。返回串 S 的元素个数。</li>
<li><code>ClearString(&amp;S)</code>：清空操作。将 S 清为空串。</li>
<li><code>DestroyString(&amp;S)</code>：销毁串。将串 S 销毁（回收存储空间）。</li>
<li><code>Concat(&amp;Y, S1, S2)</code>：串联接。用 T 返回由 S1 和 S2联接而成的新串。</li>
<li><code>SubString(&amp;Sub, S, pos, len)</code>：：求子串。用 sub 返回串 S 的第 pos 个字符起长度为 len 的子串。</li>
<li><code>Index(S, T)</code>：定位操作。若主串中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置；否则函数值为0。</li>
<li><code>StrCompare(S, T)</code>：比较操作。若 S &gt; T，则返回值 &gt; 0；若 S &#x3D; T，则返回值 &#x3D; 0；若 S &lt; T，则返回值 &lt; 0。</li>
</ul>
</li>
<li><p>字符集：</p>
<ul>
<li>英文字符——ASCII字符集</li>
<li>中英文——Unicode字符集</li>
<li>基于同一个字符集，可以有多种编码方案。</li>
</ul>
</li>
</ul>
<h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><ul>
<li><p>顺序存储</p>
<ul>
<li><p>静态数组实现（定长顺序存储）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255	<span class="comment">//预定义最大串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];	<span class="comment">//每个分量存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;	<span class="comment">//串的实际长度</span></span><br><span class="line">&#125; SString;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态数组实现（堆分配存储）</p>
<ul>
<li>用完需要手动 free</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;	<span class="comment">//按串长分配存储区，ch 指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> length;	<span class="comment">//串的长度</span></span><br><span class="line">&#125; HString;</span><br><span class="line">HString S;</span><br><span class="line">S.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MAXLEN * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">S.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>四种顺序存储方案：</p>
<ul>
<li>最后一个位置放 length</li>
<li>第一个位置放 length</li>
<li>没有 length，以 ‘\0’ 表示结尾</li>
<li>ch[0] 废弃不用，最后一个位置放 length</li>
</ul>
</li>
<li><p>串的链式存储</p>
<ul>
<li><p>存储密度低：每个字符1B，每个指针4B</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ch;	<span class="comment">//每个结点存1个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StringNode, * String;</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储密度提高</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];	<span class="comment">//每个结点存多个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125; StringNode, * String;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>SubString(&amp;Sub, S, pos, len)</code>：：求子串。用 sub 返回串 S 的第 pos 个字符起长度为 len 的子串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255	<span class="comment">//预定义最大串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];	<span class="comment">//每个分量存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;	<span class="comment">//串的实际长度</span></span><br><span class="line">&#125; SString;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求子串</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SubString</span><span class="params">(SString &amp;sub, SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">//子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span> (pos + len - <span class="number">1</span> &gt; S.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt; pos + len; i++)</span><br><span class="line">        SUb.ch[i - pos + <span class="number">1</span>] = S.ch[i];</span><br><span class="line">    Sub.length = len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>StrCompare(S, T)</code>：比较操作。若 S &gt; T，则返回值 &gt; 0；若 S &#x3D; T，则返回值 &#x3D; 0；若 S &lt; T，则返回值 &lt; 0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Strcompare</span><span class="params">(SString S, SString T)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= S.length &amp;&amp; i &lt;= T.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] != T.ch[i])</span><br><span class="line">            <span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//扫描过的所有字符都相同，则长度长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.length-T.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Index(S, T)</code>：定位操作。若主串中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置；否则函数值为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, n = Strlength(S), m = StrLength(T);</span><br><span class="line">    SString sub;	<span class="comment">//用于暂存子串</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n - m + <span class="number">1</span>) &#123;</span><br><span class="line">        SubString(sub, S, i, m);</span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub, T) != <span class="number">0</span>)</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> i;	<span class="comment">//返回子串在主串中的位置</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//S 中不存在与 T 相等的子串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h1><ul>
<li><p>字符串模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置。</p>
<ul>
<li>子串——主串的一部分，一定能找到</li>
<li>模式串——不一定能在主串中找到</li>
</ul>
</li>
<li><p>朴素模式匹配算法：主串长度为 n，模式串长度为 m。将主串中<strong>所有长度为 m 的子串</strong>依次与模式串对比，直到找到一个完全匹配的子串，或所有子串都不匹配为止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == T.ch[i]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j +<span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最坏时间复杂度：O(nm)</p>
</li>
</ul>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="KMP算法的实现"><a href="#KMP算法的实现" class="headerlink" title="KMP算法的实现"></a>KMP算法的实现</h2><ul>
<li><p>朴素模式匹配算法</p>
<ul>
<li>一旦发现当前这个子串中某个字符不匹配，就只能转而匹配下一个子串（从头开始）</li>
<li>不匹配的字符之前，一定是和模式串一致的</li>
</ul>
</li>
<li><p>KMP算法中主串指针不回溯。</p>
</li>
<li><p>算法实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> next[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;=T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;	<span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];	<span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length)</span><br><span class="line">        <span class="keyword">return</span> i - T.length;	<span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KMP算法，最坏时间复杂度 O(m+n)，其中，求 next 数组时间复杂度 O(m)</p>
</li>
</ul>
<h2 id="求-next-数组"><a href="#求-next-数组" class="headerlink" title="求 next 数组"></a>求 next 数组</h2><ul>
<li>next 数组的作用：当模式串的第 j 个字符失配时，从模式串的第 next[j] 的继续往后匹配。</li>
<li>任何模式串都一样，第一个字符不匹配时，只能匹配下一个子串。因此，next[1] 都为0。</li>
<li>任何模式串都一样，第二个字符不匹配时，只能匹配下一个子串。因此，next[2] 都为1。</li>
<li>在不匹配的位置前边，划一条分界线。模式串一步一步往右移，直到分界线之前“能对上”，或模式串完全跨过分界线为止。此时 j 指向哪儿，next 数组值就是多少。</li>
</ul>
<h2 id="KMP算法的进一步优化"><a href="#KMP算法的进一步优化" class="headerlink" title="KMP算法的进一步优化"></a>KMP算法的进一步优化</h2><ul>
<li><p>求 nextval 数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= T; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (T.ch[next[j]] == T.ch[j])</span><br><span class="line">        nextval[j] = nextval[next[j]];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nextval[j] = next[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 nextval 数组代替 next 数组进行计算。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>CString和String类型转换</title>
    <url>/2022/06/27/C++%E5%AD%A6%E4%B9%A0/MFC%E5%AD%A6%E4%B9%A0/MFC%E4%B8%ADCString%E5%92%8CString%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>将String类型的sring1转换为CSting类型的cstring1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CStringA str;</span><br><span class="line"></span><br><span class="line">str1 =string1;</span><br><span class="line"></span><br><span class="line">cstring1 = str1.<span class="built_in">GetBuffer</span>();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>MFC</category>
      </categories>
  </entry>
  <entry>
    <title>界面挂载通用代码</title>
    <url>/2022/06/15/C++%E5%AD%A6%E4%B9%A0/MFC%E5%AD%A6%E4%B9%A0/%E7%95%8C%E9%9D%A2%E6%8C%82%E8%BD%BD%E9%80%9A%E7%94%A8%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>在MFC框架下将CInfoDlg界面挂载到主页面</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Context.m_pNewViewClass = <span class="built_in">RUNTIME_CLASS</span>(CInfoDlg);</span><br><span class="line"></span><br><span class="line">Context.m_pCurrentFrame = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">Context.m_pLastView = (CFormView *)m_spliter.<span class="built_in">GetPane</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">m_spliter.<span class="built_in">DeleteView</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">m_spliter.<span class="built_in">CreateView</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">RUNTIME_CLASS</span>(CInfoDlg), <span class="built_in">CSize</span>(<span class="number">600</span>, <span class="number">0</span>), &amp;Context);</span><br><span class="line"></span><br><span class="line">CInfoDlg *pNewView = (CInfoDlg *)m_spliter.<span class="built_in">GetPane</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">m_spliter.<span class="built_in">RecalcLayout</span>();</span><br><span class="line"></span><br><span class="line">pNewView-&gt;<span class="built_in">OnInitialUpdate</span>();</span><br><span class="line"></span><br><span class="line">m_spliter.<span class="built_in">SetActivePane</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>MFC</category>
      </categories>
  </entry>
</search>
