<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++学习笔记</title>
    <url>/2024/01/03/C++%E5%AD%A6%E4%B9%A0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/ClaireSy/article/details/120155878">黑马——C++基础入门</a></p>
<p><a href="https://blog.csdn.net/ClaireSy/article/details/108423047">黑马——C++核心编程</a></p>
<p><a href="https://blog.csdn.net/ClaireSy/article/details/108423061">黑马——C++提高编程</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>STL学习总结</title>
    <url>/2022/12/30/C++%E5%AD%A6%E4%B9%A0/STL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h1><h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>string是C++风格的字符串，本质上是一个类。其内部封装了char*。</p>
</li>
<li><p>成员函数主要有find，copy，delete，replace，insert</p>
</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li><p><code>string();</code>&#x2F;&#x2F;生成空string</p>
</li>
<li><p><code>string(const char* s);</code>&#x2F;&#x2F;以字符串s初始化</p>
</li>
<li><p><code>string(const string&amp; str);</code>&#x2F;&#x2F;以string对象初始化另一个string对象</p>
</li>
<li><p><code>string(int n, char c);</code>&#x2F;&#x2F;以n个字符c初始化</p>
</li>
</ul>
<h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><ul>
<li><p><code>string&amp; operator=(const char* s);</code></p>
</li>
<li><p><code>string&amp; operator=(const string &amp;s);</code></p>
</li>
<li><p><code>string&amp; operator=(char c);</code></p>
</li>
<li><p><code>string&amp; assign(const char *s)</code></p>
</li>
<li><p><code>string&amp; assign(const char *s, int n)</code></p>
</li>
<li><p><code>string&amp; assign(const string &amp;s)</code></p>
</li>
<li><p><code>string&amp; assign(int n, char c);</code></p>
</li>
</ul>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><ul>
<li><p><code>string&amp; operator+=(const char* str);</code></p>
</li>
<li><p><code>string&amp; operator+=(const char c);</code></p>
</li>
<li><p><code>string&amp; operator+=(const string&amp; str);</code></p>
</li>
<li><p><code>string&amp; append(const char* s)</code></p>
</li>
<li><p><code>string&amp; append(const char* s,int n);</code></p>
</li>
<li><p><code>string&amp; append(const string&amp; str);</code></p>
</li>
<li><p><code>string&amp; append(const string &amp;s,int pos,int n);</code>&#x2F;&#x2F;字符串s中从pos开始的n个字符连接到字符串结尾</p>
</li>
</ul>
<h3 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h3><ul>
<li><p><code>int find(const string&amp; str, int pos = 0) const;</code>&#x2F;&#x2F;从pos开始查找str出现的第一次位置</p>
</li>
<li><p><code>int find(const char* s,int pos = 0) const</code>&#x2F;&#x2F;从pos开始查找s出现的第一次位置</p>
</li>
<li><p><code>int fing(const char* s, int pos, int n) const;</code>&#x2F;&#x2F;从pos开始查找s的前n个字符出现的第一次位置</p>
</li>
<li><p><code>int find(const char c,int pos = 0) const</code>&#x2F;&#x2F;从pos开始查找c出现的第一次位置</p>
</li>
<li><p><code>int rfind(const string&amp; str, int pos = npos) const;</code>&#x2F;&#x2F;从pos开始查找str出现的最后一次位置</p>
</li>
<li><p><code>int rfind(const char* s,int pos = npos) const</code>&#x2F;&#x2F;从pos开始查找s出现的最后一次位置</p>
</li>
<li><p><code>int rfind(const char* s, int pos, int n) const;</code>&#x2F;&#x2F;从pos开始查找s的前n个字符出现的最后一次位置</p>
</li>
<li><p><code>int find(const char c,int pos = 0) const</code>&#x2F;&#x2F;从pos开始查找c出现的最后一次位置</p>
</li>
<li><p><code>sting&amp; replace(int pos, int n, const string&amp; str)</code>&#x2F;&#x2F;替换从pos开始n个字符为字符串str</p>
</li>
<li><p><code>sting&amp; replace(int pos, int n, const char* s)</code>&#x2F;&#x2F;替换从pos开始n个字符为字符串s</p>
</li>
<li><p>find是从左往右，rfind是从右往左，二者都是寻找第一次找到的字符或字符串，故从结果上来看find的结果是从左到右第一次出现的位置，rfind的结果是从左到右最后一次出现的位置。</p>
</li>
<li><p>find和rfind找不到字符时返回-1。</p>
</li>
<li><p>replace在替换时要指定替换的开始位置、字符数量和字符内容。</p>
</li>
</ul>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><ul>
<li><p>比较方式：按ASCII码进行比较。<br>&#x3D; 返回 0<br>&gt; 返回 1<br>&lt; 返回 -1</p>
</li>
<li><p><code>int compare(const string&amp; s) const;</code></p>
</li>
<li><p><code>int compare(const char* s) const;</code></p>
</li>
</ul>
<h3 id="字符串存取"><a href="#字符串存取" class="headerlink" title="字符串存取"></a>字符串存取</h3><ul>
<li><p><code>char&amp; operator[](int n);</code>&#x2F;&#x2F;通过[]取字符</p>
</li>
<li><p><code>char&amp; at(int n);</code>&#x2F;&#x2F;通过at取字符</p>
</li>
</ul>
<h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><ul>
<li><p><code>string&amp; insert(int pos, const char* s);</code></p>
</li>
<li><p><code>string&amp; insert(int pos, const string&amp; str);</code></p>
</li>
<li><p><code>string&amp; insert(int pos, int n, char c);</code>&#x2F;&#x2F;在pos位置插入n个字符c</p>
</li>
<li><p><code>string&amp; erase(int pos, int n = npos);</code>&#x2F;&#x2F;删除从pos开始的n个字符</p>
</li>
<li><p><code>string&amp; erase(pos);</code>&#x2F;&#x2F;删除pos处的一个字符</p>
</li>
<li><p><code>erase(first,last);</code>&#x2F;&#x2F;删除从first到last之间的字符</p>
</li>
<li><p>插入和删除的下标都是从0开始。</p>
</li>
</ul>
<h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><ul>
<li><code>string substr(int pos = 0, int n = npos) const;</code>&#x2F;&#x2F;返回从pos开始的n个字符组成的字符串</li>
</ul>
<h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>vector数据结构和数组十分相似，也称为单端数组。</p>
</li>
<li><p>数组是静态空间，而vector可以动态扩展。<br>动态扩展：并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</p>
</li>
<li><p>vector的迭代器是支持随机访问的迭代器</p>
</li>
</ul>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li><p><code>vector&lt;T&gt; v;</code>&#x2F;&#x2F;采用模板实现类实现，默认构造函数</p>
</li>
<li><p><code>vector&lt;T&gt; v(num)</code>&#x2F;&#x2F;创建容量为num的vector，默认值为0</p>
</li>
<li><p><code>vector(v.begin(), v.end());</code>&#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身</p>
</li>
<li><p><code>vector(n, elem);</code>&#x2F;&#x2F;将n个elem拷贝给本身</p>
</li>
<li><p><code>vector(const vector&amp; vec);</code>&#x2F;&#x2F;拷贝构造</p>
</li>
</ul>
<h3 id="赋值操作-1"><a href="#赋值操作-1" class="headerlink" title="赋值操作"></a>赋值操作</h3><ul>
<li><p><code>vector&amp; operator=(const vector&amp; vec);</code></p>
</li>
<li><p><code>assign(beg, end);</code>&#x2F;&#x2F;将[beg, end)区间中的元素拷贝给本身</p>
</li>
<li><p><code>assign(n, elem);</code>&#x2F;&#x2F;将n个elem拷贝给本身</p>
</li>
</ul>
<h3 id="容量和大小"><a href="#容量和大小" class="headerlink" title="容量和大小"></a>容量和大小</h3><ul>
<li><p><code>empty();</code>&#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>capacity();</code>&#x2F;&#x2F;容器的容量</p>
</li>
<li><p><code>size();</code>&#x2F;&#x2F;容器的元素的个数</p>
</li>
<li><p><code>resize(int num);</code>&#x2F;&#x2F;重新指定容器的长度为num。若容器变长，则以默认值填充新位置；若容器变短，则多出的元素将被删除。</p>
</li>
<li><p><code>resize(int num, elem);</code>&#x2F;&#x2F;重新指定容器的长度为num。若容器变长，则以elem填充新位置；若容器变短，则多出的元素将被删除。</p>
</li>
</ul>
<h3 id="插入和删除-1"><a href="#插入和删除-1" class="headerlink" title="插入和删除"></a>插入和删除</h3><ul>
<li><p><code>push_back(elem);</code>&#x2F;&#x2F;尾插元素elem</p>
</li>
<li><p><code>pop_back();</code>&#x2F;&#x2F;删除最后一个元素</p>
</li>
<li><p><code>insert(const_iterator pos, elem);</code>&#x2F;&#x2F;迭代器指向位置pos插入元素elem</p>
</li>
<li><p><code>insert(const_iterator pos, int count, elem);</code>&#x2F;&#x2F;迭代器指向位置pos插入count个元素elem</p>
</li>
<li><p><code>erase(const_iterator pos);</code>&#x2F;&#x2F;删除迭代器指向的元素</p>
</li>
<li><p><code>erase(const_iterator start, const_iterator end);</code>&#x2F;&#x2F;删除迭代器从start到end之间的元素</p>
</li>
<li><p><code>clear();</code>&#x2F;&#x2F;删除容器中所有元素</p>
</li>
</ul>
<h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h3><ul>
<li><p><code>at(int idx);</code>&#x2F;&#x2F;返回索引idx所指的数据</p>
</li>
<li><p><code>operator[];</code></p>
</li>
<li><p><code>front();</code>&#x2F;&#x2F;返回容器中的第一个元素</p>
</li>
<li><p><code>back();</code>&#x2F;&#x2F;返回容器中的最后一个元素</p>
</li>
</ul>
<h3 id="互换容器"><a href="#互换容器" class="headerlink" title="互换容器"></a>互换容器</h3><ul>
<li><p><code>swap(vec);</code>&#x2F;&#x2F;将vec与本身的元素互换</p>
</li>
<li><p>swap可以使两个容器互换，可以达到收缩内存效果。</p>
</li>
</ul>
<h3 id="预留空间"><a href="#预留空间" class="headerlink" title="预留空间"></a>预留空间</h3><ul>
<li><p><code>reserve(int len);</code>&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问</p>
</li>
<li><p>预留空间可以减少vector在动态扩展容量时的扩展次数。如果数据量较大，可以一开始利用reserve预留空间。</p>
</li>
</ul>
<h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>vector对于头部的插入效率低，数据量越大，效率越低。deque相对而言对头部的插入速度更快。但是vector访问元素的速度更快。这与两者内部的实现有关。</p>
</li>
<li><p>内部工作原理：deque内部有个中控器，维护每段缓冲区的内容，缓冲区中存放真实数据。中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间。</p>
</li>
<li><p>deque容器的迭代器也是支持随机访问的。</p>
</li>
</ul>
<h3 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li><p><code>deque&lt;T&gt;depT;</code></p>
</li>
<li><p><code>deque(beg,end);</code>&#x2F;&#x2F;将[beg, end)区间中的元素拷贝给本身</p>
</li>
<li><p><code>deque(n,elem);</code>&#x2F;&#x2F;将n个elem拷贝给本身</p>
</li>
<li><p><code>deque(const deque&amp; dep);</code>&#x2F;&#x2F;拷贝构造函数</p>
</li>
</ul>
<h3 id="赋值操作-2"><a href="#赋值操作-2" class="headerlink" title="赋值操作"></a>赋值操作</h3><ul>
<li><p><code>deque&amp; operator=(const deque&amp; dep);</code></p>
</li>
<li><p><code>assign(beg, end);</code>&#x2F;&#x2F;将[beg, end)区间中的元素拷贝给本身</p>
</li>
<li><p><code>assign(n, elem);</code>&#x2F;&#x2F;拷贝构造函数</p>
</li>
</ul>
<h3 id="大小操作"><a href="#大小操作" class="headerlink" title="大小操作"></a>大小操作</h3><ul>
<li><p><code>deque.empty();</code>&#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>deque.size();</code>&#x2F;&#x2F;返回容器中元素的个数</p>
</li>
<li><p><code>deuqe.resize(int num);</code>&#x2F;&#x2F;重新指定容器的长度为num。若容器变长，则以默认值填充新位置；若容器变短，则多出的元素将被删除。</p>
</li>
<li><p><code>dque.resize(int num, elem);</code>&#x2F;&#x2F;重新指定容器的长度为num。若容器变长，则以elem填充新位置；若容器变短，则多出的元素将被删除。</p>
</li>
<li><p>deque容器没有容量的概念。</p>
</li>
</ul>
<h3 id="插入和删除-2"><a href="#插入和删除-2" class="headerlink" title="插入和删除"></a>插入和删除</h3><ul>
<li><p><code>push_back(elem);</code>&#x2F;&#x2F;在容器尾部添加一个数据</p>
</li>
<li><p><code>push_front(elem);</code>&#x2F;&#x2F;在容器头部添加一个数据</p>
</li>
<li><p><code>pop_back;</code>&#x2F;&#x2F;删除容器的最后一个数据</p>
</li>
<li><p><code>pop_front;</code>&#x2F;&#x2F;删除容器的第一个数据</p>
</li>
<li><p><code>insert(pos, elem);</code>&#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置</p>
</li>
<li><p><code>insert(pos, n, elem);</code>&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值</p>
</li>
<li><p><code>insert(pos, beg, end);</code>&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</p>
</li>
<li><p><code>clear();</code>&#x2F;&#x2F;清除所有数据</p>
</li>
<li><p><code>erase(beg, end);</code>&#x2F;&#x2F;删除[beg, end)区间的数据u，返回下一个数据的位置</p>
</li>
<li><p><code>erase(pos);</code>&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置</p>
</li>
<li><p>插入和删除提供的位置是迭代器</p>
</li>
</ul>
<h3 id="数据存取-1"><a href="#数据存取-1" class="headerlink" title="数据存取"></a>数据存取</h3><ul>
<li><p><code>at(int, idx);</code>&#x2F;&#x2F;返回索引idx所指的数据</p>
</li>
<li><p><code>operator[];</code></p>
</li>
<li><p><code>front();</code>&#x2F;&#x2F;返回第一个元素</p>
</li>
<li><p><code>end();</code>&#x2F;&#x2F;返回最后一个元素</p>
</li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li><p><code>sort(iterator beg, iterator end);</code>&#x2F;&#x2F;对beg和end之间的元素进行排序</p>
</li>
<li><p>sort算法使用时应包含头文件 algorithm。</p>
</li>
</ul>
<h2 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p>stack是一种先进后出的数据结构，它只有一个出口。栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为。栈中进出数据称为入栈，栈中弹出数据称为出栈。</p>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><p>构造函数</p>
<ul>
<li><p><code>stack&lt;T&gt; stk;</code></p>
</li>
<li><p><code>stack(const stack&amp; stk);</code>&#x2F;&#x2F;拷贝构造</p>
</li>
</ul>
<p>赋值操作</p>
<ul>
<li><code>stack&amp; operator=(const stack&amp; stk);</code></li>
</ul>
<p>数据存取</p>
<ul>
<li><p><code>push(elem);</code>&#x2F;&#x2F;向栈顶添加数据</p>
</li>
<li><p><code>pop();</code>&#x2F;&#x2F;从栈顶移除一个数据</p>
</li>
<li><p><code>top();</code>&#x2F;&#x2F;返回栈顶元素</p>
</li>
</ul>
<p>大小操作</p>
<ul>
<li><p><code>empty();</code>&#x2F;&#x2F;判断堆栈是否为空</p>
</li>
<li><p><code>size();</code>&#x2F;&#x2F;返回栈的大小</p>
</li>
</ul>
<h2 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h2><h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><p>queue是一种先进先出的数据结构，它有两个出口。队列容器允许从一端新增元素，从另一端移除元素。队列中只允许队头和队尾才可以被外界使用，因此队列不允许有遍历行为。队列中进数据称为入队(push)，出数据称为出队(pop)。</p>
<p>构造函数</p>
<ul>
<li><p><code>queue&lt;T&gt; que;</code></p>
</li>
<li><p><code>queue(const queue&amp; que);</code>&#x2F;&#x2F;拷贝构造</p>
</li>
</ul>
<p>赋值操作</p>
<ul>
<li><code>queue&amp; operator=(const queue&amp; que);</code></li>
</ul>
<p>数据存取</p>
<ul>
<li><p><code>push(elem);</code>&#x2F;&#x2F;往队尾添加元素</p>
</li>
<li><p><code>pop();</code>&#x2F;&#x2F;删除队头第一个元素</p>
</li>
<li><p><code>back();</code>&#x2F;&#x2F;返回最后一个元素</p>
</li>
<li><p><code>front();</code>&#x2F;&#x2F;返回第一个元素</p>
</li>
</ul>
<p>大小操作</p>
<ul>
<li><p><code>empty();</code>&#x2F;&#x2F;判断堆栈是否为空</p>
</li>
<li><p><code>size();</code>&#x2F;&#x2F;返回栈的大小</p>
</li>
</ul>
<h2 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h2><h3 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>链表是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针连接实现的。链表由一系列结点组成。结点有数据域和下一个结点地点的指针域组成。STL的链表是一个双向循环链表。由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器。</p>
</li>
<li><p>list的优点是采用动态存储分配，不会造成内存浪费和溢出；链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素。</p>
</li>
<li><p>list的缺点是链表灵活，但是空间（指针域）和时间（遍历）额外耗费较大。</p>
</li>
<li><p>list有一个重要的性质，插入和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p>
</li>
</ul>
<h3 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li><p><code>list&lt;T&gt; lst;</code></p>
</li>
<li><p><code>list(beg, end);</code>&#x2F;&#x2F;将[beg, end)区间中的元素拷贝给本身</p>
</li>
<li><p><code>list(n, elem);</code>&#x2F;&#x2F;将n个elem拷贝给本身</p>
</li>
<li><p><code>list(const list&amp; lst);</code>&#x2F;&#x2F;拷贝构造函数</p>
</li>
</ul>
<h3 id="赋值与交换"><a href="#赋值与交换" class="headerlink" title="赋值与交换"></a>赋值与交换</h3><ul>
<li><p><code>assign(beg, end);</code>&#x2F;&#x2F;将[beg, end)区间中的元素拷贝给本身</p>
</li>
<li><p><code>asign(n, elem);</code>&#x2F;&#x2F;将n个elem拷贝给本身</p>
</li>
<li><p><code>list&amp; operator = (const list&amp; lst);</code></p>
</li>
<li><p><code>swap(lst);</code>&#x2F;&#x2F;将lst于本身的元素互换</p>
</li>
</ul>
<h3 id="大小操作-1"><a href="#大小操作-1" class="headerlink" title="大小操作"></a>大小操作</h3><ul>
<li><p><code>size();</code>&#x2F;&#x2F;返回容器中元素的个数</p>
</li>
<li><p><code>empty();</code>&#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>resize();</code>&#x2F;&#x2F;重新指定容器的长度为num。若容器变长，则以默认值填充新位置；若容器变短，则多出的元素将被删除。</p>
</li>
<li><p><code>resize(int num, elem);</code>&#x2F;&#x2F;重新指定容器的长度为num。若容器变长，则以elem填充新位置；若容器变短，则多出的元素将被删除。</p>
</li>
</ul>
<h3 id="插入和删除-3"><a href="#插入和删除-3" class="headerlink" title="插入和删除"></a>插入和删除</h3><ul>
<li><p><code>push_back(elem);</code>&#x2F;&#x2F;尾插一个元素</p>
</li>
<li><p><code>pop_back();</code>&#x2F;&#x2F;删除最后一个元素</p>
</li>
<li><p><code>push_front(elem);</code>&#x2F;&#x2F;在容器开头插入一个元素</p>
</li>
<li><p><code>pop_front();</code>&#x2F;&#x2F;删除第一个元素</p>
</li>
<li><p><code>insert(pos, elem);</code>&#x2F;&#x2F;在pos位置插elem元素的拷贝</p>
</li>
<li><p><code>insert(pos, n, elem);</code>&#x2F;&#x2F;在pos位置插入n个elem</p>
</li>
<li><p><code>insert(pos, beg, end);</code>&#x2F;&#x2F;在pos位置插入[beg, end)区间的数据，无返回值</p>
</li>
<li><p><code>clear();</code>&#x2F;&#x2F;删除容器所有元素</p>
</li>
<li><p><code>erase(beg, end);</code>&#x2F;&#x2F;删除[beg, end)区间的数据，返回下一个元素的位置</p>
</li>
<li><p><code>erase(pos);</code>&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置</p>
</li>
<li><p><code>remove(elem);</code>&#x2F;&#x2F;删除容器中所有与elem值匹配的元素</p>
</li>
</ul>
<h3 id="数据存取-2"><a href="#数据存取-2" class="headerlink" title="数据存取"></a>数据存取</h3><ul>
<li><p><code>front();</code>&#x2F;&#x2F;返回第一个元素</p>
</li>
<li><p><code>back();</code>&#x2F;&#x2F;返回最后一个元素</p>
</li>
<li><p>list容器中不可以通过[]或者at方式访问数据。</p>
</li>
</ul>
<h3 id="反转和排序"><a href="#反转和排序" class="headerlink" title="反转和排序"></a>反转和排序</h3><ul>
<li><p><code>reverse();</code>&#x2F;&#x2F;反转链表</p>
</li>
<li><p><code>sort();</code>&#x2F;&#x2F;链表排序</p>
</li>
</ul>
<h2 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set&#x2F; multiset容器"></a>set&#x2F; multiset容器</h2><h3 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>所有元素都会在插入时自动排序。</p>
</li>
<li><p>set&#x2F; multiset属于关联式容器，底层结构由二叉树实现。</p>
</li>
<li><p>区别：set不允许容器中有重复的元素；multiset允许容器中有重复元素。</p>
</li>
</ul>
<h3 id="构造和赋值"><a href="#构造和赋值" class="headerlink" title="构造和赋值"></a>构造和赋值</h3><ul>
<li><p><code>set&lt;T&gt; st;</code></p>
</li>
<li><p><code>set(const set&amp; st);</code>&#x2F;&#x2F;拷贝构造函数</p>
</li>
<li><p><code>set&amp; operator=(const set&amp; st);</code></p>
</li>
</ul>
<h3 id="大小和交换"><a href="#大小和交换" class="headerlink" title="大小和交换"></a>大小和交换</h3><ul>
<li><p><code>size();</code>&#x2F;&#x2F;返回容器中元素的个数</p>
</li>
<li><p><code>empty();</code>&#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>swap();</code>&#x2F;&#x2F;交换两个容器</p>
</li>
</ul>
<h3 id="插入和删除-4"><a href="#插入和删除-4" class="headerlink" title="插入和删除"></a>插入和删除</h3><ul>
<li><p><code>insert(elem);</code>&#x2F;&#x2F;插入元素elem</p>
</li>
<li><p><code>clear();</code>&#x2F;&#x2F;清空容器</p>
</li>
<li><p><code>erase(pos);</code>&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器</p>
</li>
<li><p><code>erase(beg, end);</code>&#x2F;&#x2F;删除区间[beg, end)的所有元素，返回下一个元素的迭代器</p>
</li>
<li><p><code>erase(elem);</code>&#x2F;&#x2F;删除容器中所有与elem值匹配的元素</p>
</li>
</ul>
<h3 id="查找和统计"><a href="#查找和统计" class="headerlink" title="查找和统计"></a>查找和统计</h3><ul>
<li><p><code>find(key);</code>&#x2F;&#x2F;查找key是否存在，若存在返回该元素的迭代器；若不存在返回set.end()</p>
</li>
<li><p><code>count(key);</code>&#x2F;&#x2F;统计key的元素个数（对于set，结果为0或1）</p>
</li>
</ul>
<h3 id="set和multiset的区别"><a href="#set和multiset的区别" class="headerlink" title="set和multiset的区别"></a>set和multiset的区别</h3><ul>
<li><p>set不可以插入重复数据，而multiset可以。</p>
</li>
<li><p>set插入数据的同时会返回插入结果，表示插入是否成功。返回的内容为对组，first为迭代器，second为bool。</p>
</li>
<li><p>multiset不会检测数据，因此可以插入重复数据。</p>
</li>
</ul>
<h3 id="pair对组创建"><a href="#pair对组创建" class="headerlink" title="pair对组创建"></a>pair对组创建</h3><ul>
<li><p><code>pair&lt;type, type&gt; p ( value1, value2 );</code></p>
</li>
<li><p><code>pair&lt;type, type&gt; p = make_pair( value, value2 );</code></p>
</li>
</ul>
<h3 id="容器排序"><a href="#容器排序" class="headerlink" title="容器排序"></a>容器排序</h3><p>set&#x2F; multiset容器容器默认排序规则为从小到大，可利用仿函数改变排序规则。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">comparePerson</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person &amp;p2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line">        <span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">insert</span>(p1);</span><br><span class="line">    s.<span class="built_in">insert</span>(p2);</span><br><span class="line">    s.<span class="built_in">insert</span>(p3);</span><br><span class="line">    s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map&#x2F; multimap容器"></a>map&#x2F; multimap容器</h2><h3 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>map&#x2F; multimap容器中所有容器都是pair。</p>
</li>
<li><p>pair中第一个元素为key，起到索引作用，第二个元素为value。</p>
</li>
<li><p>所有元素都会根据元素的key自动排序。</p>
</li>
<li><p>map&#x2F; multimap容器数据关联式容器，底层结构由二叉树实现。</p>
</li>
<li><p>可以根据key值快速找到value值。</p>
</li>
<li><p>区别：map不允许容器中有重复key值元素；multimap允许容器中有重复key值元素。</p>
</li>
</ul>
<h3 id="构造和赋值-1"><a href="#构造和赋值-1" class="headerlink" title="构造和赋值"></a>构造和赋值</h3><ul>
<li><p><code>map&lt;T1, T2&gt; mp;</code></p>
</li>
<li><p><code>map(const map&amp; mp);</code>&#x2F;&#x2F;拷贝构造函数</p>
</li>
<li><p><code>map&amp; operator=(const map&amp; mp);</code></p>
</li>
</ul>
<h3 id="大小和交换-1"><a href="#大小和交换-1" class="headerlink" title="大小和交换"></a>大小和交换</h3><ul>
<li><p><code>size();</code>&#x2F;&#x2F;返回容器中元素的数目</p>
</li>
<li><p><code>empty();</code>&#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>swap(st);</code>&#x2F;&#x2F;交换两个容器</p>
</li>
</ul>
<h3 id="插入和删除-5"><a href="#插入和删除-5" class="headerlink" title="插入和删除"></a>插入和删除</h3><ul>
<li><p>map中所有元素都是成对出现，插入数据时候要使用对组</p>
</li>
<li><p><code>insert(elem);</code>&#x2F;&#x2F;插入元素elem</p>
</li>
<li><p><code>clear();</code>&#x2F;&#x2F;清除所有元素</p>
</li>
<li><p><code>erase(pos);</code>&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器</p>
</li>
<li><p><code>erase(beg, end);</code>&#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器</p>
</li>
<li><p><code>erakey(key);</code>&#x2F;&#x2F;删除容器中值为key的元素</p>
</li>
</ul>
<h3 id="查找和统计-1"><a href="#查找和统计-1" class="headerlink" title="查找和统计"></a>查找和统计</h3><ul>
<li><p><code>find(key);</code>&#x2F;&#x2F;查找key是否存在，若存在返回该元素的迭代器；若不存在返回map.end()</p>
</li>
<li><p><code>count(key);</code>&#x2F;&#x2F;统计key的元素个数（对于map，结果为0或1）</p>
</li>
</ul>
<h3 id="容器排序-1"><a href="#容器排序-1" class="headerlink" title="容器排序"></a>容器排序</h3><p>map&#x2F; multimap容器容器默认排序规则为从小到大，可利用仿函数改变排序规则。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认从小到大排序</span></span><br><span class="line">    <span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><ul>
<li><p>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code> 组成。</p>
</li>
<li><p><algorithm>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</p>
</li>
<li><p><numeric>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</p>
</li>
<li><p><functional>定义了一些模板类,用以声明函数对象。</p>
</li>
</ul>
<h2 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h2><h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h3><ul>
<li><p><code>for_each(iterator beg, iterator end, _func);</code>&#x2F;&#x2F; beg 开始迭代器; end 结束迭代器; _func 函数或者函数对象</p>
</li>
<li><p>实现容器的遍历</p>
</li>
</ul>
<h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><ul>
<li><p><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code>&#x2F;&#x2F;beg1 源容器开始迭代器; end1 源容器结束迭代器; beg2 目标容器开始迭代器; _func 函数或者函数对象</p>
</li>
<li><p>搬运容器到另一个容器中</p>
</li>
<li><p>搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
</li>
</ul>
<h2 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul>
<li><p><code>find(iterator beg, iterator end, value);</code>&#x2F;&#x2F;beg 开始迭代器; end 结束迭代器; value 查找的元素</p>
</li>
<li><p>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
</li>
</ul>
<h3 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h3><ul>
<li><p><code>find_if(iterator beg, iterator end, _Pred);</code>&#x2F;&#x2F; beg 开始迭代器; end 结束迭代器; _Pred 函数或者谓词（返回bool类型的仿函数）</p>
</li>
<li><p>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
</li>
</ul>
<h3 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h3><ul>
<li><p><code>adjacent_find(iterator beg, iterator end);</code>&#x2F;&#x2F;beg 开始迭代器; end 结束迭代器</p>
</li>
<li><p>查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p>
</li>
</ul>
<h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><ul>
<li><p><code>bool binary_search(iterator beg, iterator end, value);</code>&#x2F;&#x2F; beg 开始迭代器;end 结束迭代器;value 查找的元素</p>
</li>
<li><p>查找指定的元素，查到 返回true 否则false</p>
</li>
<li><p>在无序序列中不可用</p>
</li>
</ul>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><ul>
<li><p><code>count(iterator beg, iterator end, value);</code>&#x2F;&#x2F; beg 开始迭代器; end 结束迭代器; value 统计的元素</p>
</li>
<li><p>统计元素出现次数</p>
</li>
<li><p>统计自定义数据类型时，需要配合重载 operator&#x3D;&#x3D;</p>
</li>
</ul>
<h3 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h3><ul>
<li><p><code>count_if(iterator beg, iterator end, _Pred);</code>&#x2F;&#x2F; beg 开始迭代器; end 结束迭代器; _Pred 谓词</p>
</li>
<li><p>按条件统计元素出现次数</p>
</li>
</ul>
<h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><ul>
<li><p><code>sort(iterator beg, iterator end, _Pred);</code>&#x2F;&#x2F;beg 开始迭代器; end 结束迭代器; _Pred 谓词</p>
</li>
<li><p>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
</li>
</ul>
<h3 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h3><ul>
<li><p><code>random_shuffle(iterator beg, iterator end);</code>&#x2F;&#x2F;beg 开始迭代器; end 结束迭代器</p>
</li>
<li><p>指定范围内的元素随机调整次序</p>
</li>
<li><p>使用时需要添加随机数种子</p>
</li>
</ul>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><ul>
<li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code>&#x2F;&#x2F;beg1 容器1开始迭代器; end1 容器1结束迭代器; beg2 容器2开始迭代器; end2 容器2结束迭代器; dest 目标容器开始迭代器</p>
</li>
<li><p>容器元素合并，并存储到另一容器中</p>
</li>
<li><p>两个容器必须是有序的</p>
</li>
</ul>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><ul>
<li><p><code>reverse(iterator beg, iterator end);</code>&#x2F;&#x2F;beg 开始迭代器; end 结束迭代器</p>
</li>
<li><p>反转指定范围的元素</p>
</li>
</ul>
<h2 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h2><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><ul>
<li><p><code>copy(iterator beg, iterator end, iterator dest);</code> &#x2F;&#x2F;beg 开始迭代器; end 结束迭代器; dest 目标起始迭代器</p>
</li>
<li><p>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
</li>
</ul>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><ul>
<li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code>&#x2F;&#x2F;beg 开始迭代器; end 结束迭代器; oldvalue 旧元素; newvalue 新元素</p>
</li>
<li><p>将区间内旧元素 替换成 新元素</p>
</li>
</ul>
<h3 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if"></a>replace_if</h3><ul>
<li><p><code>replace_if(iterator beg, iterator end, _Pred, newvalue);</code>&#x2F;&#x2F;beg 开始迭代器; end 结束迭代器; _pred 谓词; newvalue 替换的新元素</p>
</li>
<li><p>按条件替换元素，满足条件的替换成指定元素</p>
</li>
</ul>
<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><ul>
<li><p><code>swap(container c1, container c2);</code>&#x2F;&#x2F;c1容器1; c2容器2</p>
</li>
<li><p>互换两个容器的元素，两个容器要同种类型</p>
</li>
</ul>
<h2 id="常用算术生成算法"><a href="#常用算术生成算法" class="headerlink" title="常用算术生成算法"></a>常用算术生成算法</h2><ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为#include <numeric></li>
</ul>
<h3 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h3><ul>
<li><p><code>accumulate(iterator beg, iterator end, value);</code>&#x2F;&#x2F;beg 开始迭代器； end 结束迭代器； value 起始值</p>
</li>
<li><p>计算容器元素累计总和</p>
</li>
</ul>
<h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><ul>
<li><p><code>fill(iterator beg, iterator end, value);</code> &#x2F;&#x2F;beg 开始迭代器; end 结束迭代器; value 填充的值</p>
</li>
<li><p>向容器中填充指定元素</p>
</li>
</ul>
<h2 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h2><h3 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h3><ul>
<li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code>&#x2F;&#x2F; beg1 容器1开始迭代器; end1 容器1结束迭代器; beg2 容器2开始迭代器; end2 容器2结束迭代器; dest 目标容器开始迭代器</p>
</li>
<li><p>求两个集合的交集</p>
</li>
<li><p>两个集合必须是有序序列</p>
</li>
<li><p>目标容器开辟空间需要从两个容器中取小值</p>
</li>
<li><p>set_intersection返回值既是交集中最后一个元素的位置</p>
</li>
</ul>
<h3 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h3><ul>
<li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code>&#x2F;&#x2F;beg1 容器1开始迭代器; end1 容器1结束迭代器; beg2 容器2开始迭代器; end2 容器2结束迭代器; dest 目标容器开始迭代器</p>
</li>
<li><p>求两个集合的并集</p>
</li>
<li><p>两个集合必须是有序序列</p>
</li>
<li><p>目标容器开辟空间需要两个容器相加</p>
</li>
<li><p>set_union返回值既是并集中最后一个元素的位置</p>
</li>
</ul>
<h3 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h3><ul>
<li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code>&#x2F;&#x2F;beg1 容器1开始迭代器; end1 容器1结束迭代器; beg2 容器2开始迭代器; end2 容器2结束迭代器; dest 目标容器开始迭代器</p>
</li>
<li><p>求两个集合的差集</p>
</li>
<li><p>两个集合必须是有序序列</p>
</li>
<li><p>目标容器开辟空间需要从两个容器取较大值</p>
</li>
<li><p>set_difference返回值是差集中最后一个元素的位置</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>list.remove()函数删除结构体结点</title>
    <url>/2022/06/27/C++%E5%AD%A6%E4%B9%A0/list.remove()%E5%87%BD%E6%95%B0%E5%88%A0%E9%99%A4%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%93%E7%82%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>使用stl中list的list.remove()函数删除结构体结点时，会遇到&#x3D;&#x3D;的运算符重载问题，解决方法如下：</p>
<ul>
<li>结构体定义内容：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">msg</span></span><br><span class="line">&#123;</span><br><span class="line">  string studentNumber;</span><br><span class="line">  string studentName;</span><br><span class="line">  <span class="type">int</span> gradeChinese, gradeMath, gradeEnglish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x3D;&#x3D;运算符重载实现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> CInfoFile::msg&amp; msg1, <span class="type">const</span> CInfoFile::msg&amp; msg2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (msg1.studentNumber == msg2.studentNumber 					              		  &amp;&amp;msg1.studentName==msg2.studentName</span><br><span class="line">	  &amp;&amp;msg1.gradeChinese==msg2.gradeChinese</span><br><span class="line">      &amp;&amp;msg1.gradeEnglish==msg2.gradeEnglish</span><br><span class="line">      &amp;&amp;msg1.gradeMath==msg2.gradeMath)</span><br><span class="line">  flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>define或typedef遇到模板</title>
    <url>/2022/04/21/C++%E5%AD%A6%E4%B9%A0/%E5%BD%93define%E6%88%96%E8%80%85typedef%E9%81%87%E5%88%B0%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">NODE</span></span><br><span class="line">&#123;</span><br><span class="line">	T data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">NODE</span> *next;</span><br><span class="line">&#125; LinkList;</span><br></pre></td></tr></table></figure>

<p>这里的代码会报错，因为define和typedef不允许定义模糊的类型，如果要使用，一定要显式指明数据类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NODE</span></span><br><span class="line">&#123;</span><br><span class="line">	T data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">NODE</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> NODE&lt;<span class="type">int</span>&gt; LinkList;</span><br></pre></td></tr></table></figure>

<p>上面为正确的用法，并且对于typedef必须定义在模板结构的下面。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>连续删除链表结点</title>
    <url>/2022/04/21/C++%E5%AD%A6%E4%B9%A0/%E8%BF%9E%E7%BB%AD%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p>struct定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Linklist</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	Linklist *next;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>函数实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(LinkList *list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value;<span class="comment">//要删除的结点数据</span></span><br><span class="line">    cin&gt;&gt;value;</span><br><span class="line">    Linklist *t = list-&gt;next,*in = list;</span><br><span class="line">    <span class="keyword">while</span>(t != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Linklist *t = list -&gt;next,* in = list;</span><br><span class="line">        <span class="keyword">while</span>(t != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> is = <span class="number">1</span>;<span class="comment">//判断是否查找到对象</span></span><br><span class="line">            <span class="keyword">if</span>(t-&gt;date != age)is = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(is == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                in -&gt;next = t-&gt;next;</span><br><span class="line">                <span class="built_in">delete</span>(t);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">            in = in-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Python基本语法</title>
    <url>/2023/05/15/Python%E5%AD%A6%E4%B9%A0/Python%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h1><ul>
<li><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">加</td>
<td></td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减</td>
<td></td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘</td>
<td></td>
</tr>
<tr>
<td align="center">&#x2F;</td>
<td align="center">除</td>
<td>9 &#x2F; 2 &#x3D; 4.5</td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F;</td>
<td align="center">取整除</td>
<td>9 &#x2F;&#x2F; 2 &#x3D; 4</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">取余数</td>
<td>9 % 2 &#x3D; 1</td>
</tr>
<tr>
<td align="center">**</td>
<td align="center">幂</td>
<td>2 ** 3 &#x3D; 8</td>
</tr>
</tbody></table>
</li>
<li><p>在Python中<code>*</code>还可以用于字符串，计算结果就是字符串重复指定次数的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [1]:&quot;-&quot; * 5</span><br><span class="line">Out[1]&quot;-----&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><ul>
<li><p>数字型</p>
<ul>
<li><p>整型 int</p>
</li>
<li><p>浮点型 float</p>
</li>
<li><p>布尔型 bool</p>
</li>
<li><p>True</p>
</li>
<li><p>False</p>
</li>
<li><p>复数型 complex</p>
</li>
<li><p>主要用于科学计算，例如：平面场问题、波动问题、电容电感等问题</p>
</li>
</ul>
</li>
<li><p>非数字型</p>
<ul>
<li>字符串</li>
<li>列表</li>
<li>元组</li>
<li>字典</li>
</ul>
</li>
<li><p>提示：在Python2.x中，整数还可分为<code>int</code>和<code>long</code></p>
</li>
<li><p>使用<code>type</code>函数可以查看一个变量类型</p>
<ul>
<li>In [1]: type(name)</li>
</ul>
</li>
<li><blockquote>
<p>字符串之间可以用<code>+</code>进行拼接</p>
<p>字符串可以和整数使用*重复拼接相同的字符串</p>
<p>数字型变量和字符串之间不能进行其他运算</p>
</blockquote>
</li>
</ul>
<h1 id="变量的输入和输出"><a href="#变量的输入和输出" class="headerlink" title="变量的输入和输出"></a>变量的输入和输出</h1><ul>
<li><p><code>input()</code></p>
<ul>
<li><code>字符串变量 = input(&quot;提示信息：&quot;)</code></li>
<li><code>input()</code>输入的内容都认为是一个字符串</li>
</ul>
</li>
<li><p>类型转换函数</p>
<ul>
<li><code>int(x)</code>将x转换为一个整数</li>
<li><code>float(x)</code>将x装换为一个浮点数</li>
</ul>
</li>
<li><p>变量的格式化输出</p>
<ul>
<li><table>
<thead>
<tr>
<th>格式化字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%d</td>
<td>有符号十进制整数，<code>%06</code>表示输出的整数显示6位数，不足的地方用0补全</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数，<code>%.02f</code>表示小数点后只显示两位</td>
</tr>
<tr>
<td>%%</td>
<td>输出%</td>
</tr>
</tbody></table>
</li>
<li><p><code>print(&quot;Name:%s,Age:%d&quot;% (name, age))</code>，<code>name</code>变量中为姓名信息，<code>age</code>变量中为年龄信息</p>
</li>
<li><p><code>print(&quot;abc&quot;, end = &quot;a&quot;)</code>在默认情况下，print输出后会自动在末尾添加换行，利用end可用end内容替代换行</p>
</li>
<li><p><code>print(&quot;&quot;)</code>在一行输出后添加换行</p>
</li>
</ul>
</li>
</ul>
<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><ul>
<li><table>
<thead>
<tr>
<th>转义字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\\</td>
<td>反斜杠符号</td>
</tr>
<tr>
<td>\&#96;</td>
<td>单引号</td>
</tr>
<tr>
<td>\\“</td>
<td>双引号</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\t</td>
<td>横向制表符</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="函数的基本使用"><a href="#函数的基本使用" class="headerlink" title="函数的基本使用"></a>函数的基本使用</h1><ul>
<li><p>函数的定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>():</span><br><span class="line">    <span class="comment"># 函数内容</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义的函数只有被调用才会执行</p>
</li>
</ul>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><ul>
<li>每一个以扩展名<code>.py</code>为结尾的python源文件都是一个模块</li>
<li>导入模块需要<code>import</code></li>
<li>模块名也是标识符，需要遵循标识符命名规则</li>
<li><code>.pyc</code>表示编译过文件</li>
</ul>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ul>
<li><p>查看列表<code>List</code>能使用的功能</p>
<ul>
<li>在ipython3中操作：</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [1]:name_list.(+tab键)</span><br><span class="line">name_list.append  name_list.count等等</span><br></pre></td></tr></table></figure>

<ul>
<li><table>
<thead>
<tr>
<th>序号</th>
<th>分类</th>
<th>关键字&#x2F;函数&#x2F;方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>增加</td>
<td>列表.insert(索引,数据)</td>
<td>在指定位置插入数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.append(数据)</td>
<td>在末尾追加数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.extend(列表2)</td>
<td>将列表2的数据追加到列表</td>
</tr>
<tr>
<td>2</td>
<td>修改</td>
<td>列表[索引] &#x3D; 数据</td>
<td>修改指定索引的数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>del 列表[索引]</td>
<td>删除指定索引的数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.remove(数据)</td>
<td>删除第一个出现的指定数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.pop</td>
<td>删除末尾数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.pop(索引)</td>
<td>删除指定索引数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.clear</td>
<td>情空列表</td>
</tr>
<tr>
<td>4</td>
<td>统计</td>
<td>len(列表)</td>
<td>列表长度</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.count(数据)</td>
<td>数据在列表中出现次数</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.index(数据)</td>
<td>返回数据索引</td>
</tr>
<tr>
<td>5</td>
<td>排序</td>
<td>列表.sort()</td>
<td>升序排序</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.sort(reverse&#x3D;True)</td>
<td>降序排序</td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表.reverse()</td>
<td>逆转，反转</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>使用<code>del</code>关键字可以从内存中删除变量</p>
</li>
<li><p>关键字后面不需要使用括号，函数需要</p>
</li>
<li><p>迭代循环<code>for num in nums</code></p>
</li>
<li><p>列表中可以存储不同类型数据</p>
</li>
</ul>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><ul>
<li><p><code>Tuple</code>与列表类似，不同之处在于元组的元素不能修改</p>
<ul>
<li>元组表示多个元素组成的序列</li>
<li>元组在<code>Python</code>开发中有特定的应用场景</li>
</ul>
</li>
<li><p>用于存储一串信息，数据之间使用<code>,</code>分隔</p>
</li>
<li><p>元组用<code>()</code>定义</p>
</li>
<li><p>元组的索引从0开始</p>
</li>
<li><p>创建空元组<code>()</code></p>
</li>
<li><p>查看元组能使用的功能方法如列表</p>
</li>
<li><p>可用<code>for in</code>遍历元组</p>
</li>
<li><p>应用场景</p>
<ul>
<li>函数的参数和返回值</li>
<li>格式化字符串</li>
<li>让列表不可被修改，以保护列表安全</li>
</ul>
</li>
<li><blockquote>
<p>list(元组)# 元组转换为列表</p>
<p>tuple(列表)# 列表转换为元组</p>
</blockquote>
</li>
</ul>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><ul>
<li><p><code>dictionary</code>（字典）可用于存储多个数据</p>
</li>
<li><p>字典是无序对象合集，列表是有序对象合集</p>
</li>
<li><p>字典用<code>&#123;&#125;</code>定义</p>
</li>
<li><p>字典使用<strong>键值对</strong>存储数据，键值之间使用<code>，</code>分隔</p>
<ul>
<li>键<code>key</code>是索引</li>
<li>值<code>value</code>是数据</li>
<li>键和值之间使用<code>:</code>分隔</li>
<li>键必须是唯一的</li>
<li>值可以取任何数据类型，但键只能使用字符串、数字和元组</li>
</ul>
</li>
<li><p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xiaoming = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">            <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">            <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&quot;height&quot;</span>: <span class="number">1.75</span>&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>小明</td>
</tr>
<tr>
<td>age</td>
<td>18</td>
</tr>
<tr>
<td>gender</td>
<td>True</td>
</tr>
<tr>
<td>height</td>
<td>1.75</td>
</tr>
</tbody></table>
</li>
<li><p>字典取值使用<code>[]</code></p>
<ul>
<li>例如：<code>pirnt([&quot;name&quot;])</code></li>
</ul>
</li>
<li><p><code>xiaoming[&quot;GPA&quot;] = 3.5</code>若key不存在则会新增键值对</p>
</li>
<li><p>查看元组能使用的功能方法如列表</p>
</li>
<li><p><code>for k in xiaoming</code>变量<code>k</code>是键值</p>
</li>
<li><p>使用场景</p>
<ul>
<li>使用多个键值对存储描述一个物体的相关信息</li>
<li>将多个字典放在一个列表中再进行遍历，再循环体内部针对每一个字典进行相同的处理</li>
</ul>
</li>
</ul>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li><p>可以用<code>&quot;&quot;</code> 或<code>&#39;&#39;</code>定义字符串，使用<code>&#39;&#39;</code>往往用于定义字符串内有<code>&quot;&quot;</code>的情况</p>
<ul>
<li><code>str2 = &#39;my name is &quot;logo&quot;&#39;</code></li>
</ul>
</li>
<li><p><code>index(&quot;substring&quot;)</code>查询子字符串<code>substring</code>不存在代码会报错</p>
</li>
<li><p>判断类型</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>string.isspace()</code></td>
<td>若string只包含空格，返回True</td>
</tr>
<tr>
<td><code>sting.isalnum()</code></td>
<td>若string至少有一个字符并且所以字符或数字返回True</td>
</tr>
<tr>
<td><code>string.isalpha()</code></td>
<td>若string至少有一个并且所有字符都是字母返回True</td>
</tr>
<tr>
<td><code>string.isdecimal()</code></td>
<td>若string只包含数字则返回True（全角数字）</td>
</tr>
<tr>
<td><code>string.isdigit()</code></td>
<td>若string只包含数字则返回True（全角数字，（1），<code>\u00b2</code>）</td>
</tr>
<tr>
<td><code>string.isnumeric()</code></td>
<td>若string只包含数字则返回True（全角数字，汉字数字）</td>
</tr>
<tr>
<td><code>string.istitle()</code></td>
<td>若string是标题化的（每个单词首字母大写）则返回True</td>
</tr>
<tr>
<td><code>string.islower()</code></td>
<td>若string中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是小写，则返回True</td>
</tr>
<tr>
<td><code>string.isupper()</code></td>
<td>若string中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是大写，则返回True</td>
</tr>
</tbody></table>
<ul>
<li>查找和替换</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>string.startswith(str)</code></td>
<td>若string以<code>str</code>开头则返回True</td>
</tr>
<tr>
<td><code>string.endwith(str)</code></td>
<td>若string以<code>str</code>结尾则返回True</td>
</tr>
<tr>
<td><code>string.find(str,start=0,end=len(string))</code></td>
<td>若<code>str</code>在 string的start到end中则返回索引值，否则返回-1</td>
</tr>
<tr>
<td><code>string.rfind(str,start=0,end=len(string))</code></td>
<td>类似<code>find()</code>函数，从右边开始</td>
</tr>
<tr>
<td><code>string.index(str,start=0,end=len(string))</code></td>
<td>与<code>find()</code>类似，但是<code>str</code>不在string中会报错</td>
</tr>
<tr>
<td><code>string.rindex(str,start=0,end=len(string))</code></td>
<td>类似于<code>index()</code>，从右边开始</td>
</tr>
<tr>
<td><code>string.replace(old_str,new_str,num=string.count(old))</code></td>
<td>把string中<code>old_str</code>替换为<code>new_str</code>，若<code>num</code>指定，则替换不超过<code>num</code>次</td>
</tr>
</tbody></table>
<ul>
<li>大小写转换</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>string.capitalize()</code></td>
<td>把字符串第一个字符大写</td>
</tr>
<tr>
<td><code>string.title()</code></td>
<td>把字符串每个单词首字母大写</td>
</tr>
<tr>
<td><code>string.lower()</code></td>
<td>转换string所有大写字母为小写</td>
</tr>
<tr>
<td><code>string.upper()</code></td>
<td>转换string所有小写字母为大写</td>
</tr>
<tr>
<td><code>string.swapcase()</code></td>
<td>翻转string中的大小写</td>
</tr>
</tbody></table>
<ul>
<li>去除空白字符</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>string.lstrip()</code></td>
<td>截掉 string 左边（开始）的空白字符</td>
</tr>
<tr>
<td><code>string.rstrip()</code></td>
<td>截掉 string 右边（末尾）的空白字符</td>
</tr>
<tr>
<td><code>string.strip()</code></td>
<td>截掉 string 左右两边的空白字符</td>
</tr>
</tbody></table>
<ul>
<li>拆分和连接</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>string.partition(str)</code></td>
<td>把字符串 string 分成一个 3 元素的元组 (<code>str</code>前面, <code>str</code>, <code>str</code>后面)</td>
</tr>
<tr>
<td><code>string.rpartition(str)</code></td>
<td>类似于 partition() 方法，不过是从右边开始查找</td>
</tr>
<tr>
<td><code>string.split(str=&quot;&quot;, num)</code></td>
<td>以 <code>str</code> 为分隔符拆分 string，如果 <code>num</code> 有指定值，则仅分隔 <code>num + 1</code> 个子字符串，<code>str</code> 默认包含 ‘\r’, ‘\t’, ‘\n’ 和空格</td>
</tr>
<tr>
<td><code>string.splitlines()</code></td>
<td>按照行(‘\r’, ‘\n’, ‘\r\n’)分隔，返回一个包含各行作为元素的列表</td>
</tr>
<tr>
<td><code>string.join(seq)</code></td>
<td>以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串</td>
</tr>
</tbody></table>
<ul>
<li><strong>切片</strong> 方法适用于 <strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong><ul>
<li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li>
<li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li>
<li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li>
<li><code>nums_str[开始索引:结束索引:步长]</code></li>
<li><strong>注意</strong>：<ul>
<li>指定的区间属于 <strong>左闭右开</strong> 型 <code>[开始索引,  结束索引)</code> &#x3D;&gt; <code>开始索引 &gt;= 范围 &lt; 结束索引</code></li>
<li>从 <code>起始</code> 位开始，到 <strong><code>结束</code>位的前一位</strong> 结束（<strong>不包含结束位本身</strong>)</li>
<li>从头开始，<strong>开始索引</strong> <strong>数字可以省略，冒号不能省略</strong></li>
<li>到末尾结束，<strong>结束索引</strong> <strong>数字可以省略，冒号不能省略</strong></li>
<li>步长默认为 <code>1</code>，如果连续切片，<strong>数字和冒号都可以省略</strong></li>
</ul>
</li>
<li>索引的顺序和倒序<ul>
<li>在 Python 中不仅支持 <strong>顺序索引</strong>，同时还支持 <strong>倒序索引</strong>，步长为-1</li>
<li>所谓倒序索引就是 <strong>从右向左</strong> 计算索引<ul>
<li>最右边的索引值是 <strong>-1</strong>，依次递减</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h1><ul>
<li>内置函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>len(item)</td>
<td>计算容器中元素个数</td>
<td></td>
</tr>
<tr>
<td>del(item)</td>
<td>删除变量</td>
<td>del 有两种方式</td>
</tr>
<tr>
<td>max(item)</td>
<td>返回容器中元素最大值</td>
<td>如果是字典，只针对 key 比较</td>
</tr>
<tr>
<td>min(item)</td>
<td>返回容器中元素最小值</td>
<td>如果是字典，只针对 key 比较</td>
</tr>
<tr>
<td><code>cmp(item1, item2)</code></td>
<td>比较两个值，-1 小于&#x2F;0 相等&#x2F;1 大于</td>
<td><code>Python 3.x </code>取消了 <code>cmp </code>函数</td>
</tr>
</tbody></table>
<p>  <strong>注意</strong></p>
<ul>
<li><strong>字符串</strong> 比较符合以下规则： “0” &lt; “A” &lt; “a”</li>
</ul>
<ul>
<li><p>切片</p>
<table>
<thead>
<tr>
<th align="center">描述</th>
<th>Python 表达式</th>
<th>结果</th>
<th>支持的数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">切片</td>
<td>“0123456789”[::-2]</td>
<td>“97531”</td>
<td>字符串、列表、元组</td>
</tr>
</tbody></table>
<ul>
<li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li>
<li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li>
<li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li>
</ul>
</li>
<li><p>运算符</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
<th>支持的数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td>[1, 2] + [3, 4]</td>
<td>[1, 2, 3, 4]</td>
<td>合并</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td align="center">*</td>
<td>[“Hi!”] * 4</td>
<td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td>重复</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td align="center">in</td>
<td>3 in (1, 2, 3)</td>
<td>True</td>
<td>元素是否存在</td>
<td>字符串、列表、元组、字典</td>
</tr>
<tr>
<td align="center">not in</td>
<td>4 not in (1, 2, 3)</td>
<td>True</td>
<td>元素是否不存在</td>
<td>字符串、列表、元组、字典</td>
</tr>
<tr>
<td align="center"><code>&gt;</code> <code>&gt;=</code> <code> ==</code> <code>&lt;</code> <code>&lt;=</code></td>
<td>(1, 2, 3) &lt; (2, 2, 3)</td>
<td>True</td>
<td>元素比较</td>
<td>字符串、列表、元组</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<ul>
<li><code>in</code> 在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></li>
<li><code>in</code> 和 <code>not in</code> 被称为 <strong>成员运算符</strong></li>
</ul>
</li>
<li><p>成员运算符</p>
<p>成员运算符用于 <strong>测试</strong> 序列中是否包含指定的 <strong>成员</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>如果在指定的序列中找到值返回 True，否则返回 False</td>
<td><code>3 in (1, 2, 3)</code> 返回 <code>True</code></td>
</tr>
<tr>
<td>not in</td>
<td>如果在指定的序列中没有找到值返回 True，否则返回 False</td>
<td><code>3 not in (1, 2, 3)</code> 返回 <code>False</code></td>
</tr>
</tbody></table>
<p>注意：在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></p>
</li>
<li><p>完整的 for 循环语法</p>
<ul>
<li>在 <code>Python</code> 中完整的 <code>for 循环</code> 的语法如下：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 集合:</span><br><span class="line">    </span><br><span class="line">    循环体代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    没有通过 <span class="keyword">break</span> 退出循环，循环结束后，会执行的代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用场景</p>
<ul>
<li><p>在 <strong>迭代遍历</strong> 嵌套的数据类型时，例如 <strong>一个列表包含了多个字典</strong></p>
</li>
<li><p>需求：要判断 某一个字典中 是否存在 指定的 值 </p>
<ul>
<li><p>如果 <strong>存在</strong>，提示并且退出循环</p>
</li>
<li><p>如果 <strong>不存在</strong>，在 <strong>循环整体结束</strong> 后，希望 <strong>得到一个统一的提示</strong></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="LINUX-上的-Shebang-符号"><a href="#LINUX-上的-Shebang-符号" class="headerlink" title="LINUX 上的 Shebang 符号(#!)"></a>LINUX 上的 <code>Shebang</code> 符号(<code>#!</code>)</h1><ul>
<li><code>#!</code>这个符号叫做 <code>Shebang</code> 或者 <code>Sha-bang</code></li>
<li><code>Shebang</code> 通常在 <code>Unix</code> 系统脚本的中 <strong>第一行开头</strong> 使用</li>
<li>指明 <strong>执行这个脚本文件</strong> 的 <strong>解释程序</strong></li>
<li><strong>使用 Shebang 的步骤</strong></li>
</ul>
<ol>
<li>使用 <code>which</code> 查询 <code>python3</code> 解释器所在路径</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> python3</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改要运行的 <strong>主 python 文件</strong>，在第一行增加以下内容</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改 <strong>主 python 文件</strong> 的文件权限，增加执行权限</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x cards_main.py</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在需要时执行程序即可</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./cards_main.py</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>auto_login</title>
    <url>/2023/05/25/Python%E5%AD%A6%E4%B9%A0/auto_login/</url>
    <content><![CDATA[<p>每次电脑连接校园网都需要输入密码。甚至有时电脑无法自动弹出上网登录界面。因而希望做一个脚本来实现自动登录。</p>
<h1 id="校园网上网原理"><a href="#校园网上网原理" class="headerlink" title="校园网上网原理"></a>校园网上网原理</h1><p>设备模仿目标服务器向客户端发送HTTP Redirect，将客户浏览器重定向到一个预先指定的Web服务器。在这个Web服务器的页面上，用户输入账号密码等信息，后台认证通过后，该服务器会向前述设备发送认证通过消息，该设备会建立认证通过表项。下一次客户Internet（不仅仅HTTP，所有）请求过来的时候，查表找到表项后，正常转发。客户即可正常上网了。</p>
<h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><ul>
<li><p>request库</p>
<ul>
<li><p>Python中可以实现简单的HTTP的模块</p>
</li>
<li><p>基本GET请求</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&quot;http://httpbin.org/get&quot;</span>)</span><br><span class="line"><span class="comment"># text输出文本内容</span></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>POST请求和GET请求</p>
<ul>
<li>GET请求和POST请求区别在于前者通常是通过url地址，而后者常见的则是form表单请求</li>
</ul>
</li>
<li><p>Tkinter库</p>
<ul>
<li><p>Python中可以实现简单窗口视窗设计的模块</p>
</li>
<li><p>创建并显示视窗基本写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk  <span class="comment"># 在代码里面导入库，起一个别名，以后代码里面就用这个别名</span></span><br><span class="line">root = tk.Tk()  <span class="comment"># 这个库里面有Tk()这个方法，这个方法的作用就是创建一个窗口</span></span><br><span class="line">root.mainloop()  <span class="comment"># 加上这一句，就可以看见窗口了，循环显示窗口</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>安徽大学校园网登录方式为GET请求。IP会随着位置的不同而可能重新分配。</p>
<ul>
<li><p>方案一</p>
<ul>
<li><p>将下列代码写入html文件并加入开机自启动计划中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;meta name=&quot;viewport&quot; content=&quot;width=, initial-scale=1.0&quot;&gt;</span><br><span class="line">	&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;script&gt;</span><br><span class="line">		onload = function()&#123;</span><br><span class="line">			window.open(&quot;url&quot;, &quot;_self&quot;) # url为请求网址</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/script&gt;	</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不足：</p>
<ul>
<li>无法识别当前IP地址，不适用于因为校园内地理位置的改变而改变IP地址的情况。</li>
<li>仅开机时html文件会运行，仅适用于电脑开机时连接校园网情况，不满足连接WiFi时自动输入账号密码的实际需求。</li>
</ul>
</li>
</ul>
</li>
<li><p>方案二</p>
<ul>
<li><p>python代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">ip, url_cmcc, url</span>):</span><br><span class="line"></span><br><span class="line">    url = re.sub(<span class="string">r&#x27;\d+\.\d+\.\d+\.\d+&amp;&#x27;</span>, ip + <span class="string">&#x27;&amp;&#x27;</span>, url, <span class="number">1</span>)</span><br><span class="line">    url_cmcc = re.sub(<span class="string">r&#x27;\d+\.\d+\.\d+\.\d+&amp;&#x27;</span>, ip + <span class="string">&#x27;&amp;&#x27;</span>, url_cmcc, <span class="number">1</span>)</span><br><span class="line">    res_cmcc = requests.get(url_cmcc)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;&quot;msg&quot;:&quot;&quot;&#x27;</span> <span class="keyword">in</span> res_cmcc.text:</span><br><span class="line">        res = requests.get(url)</span><br><span class="line">        login_gui(ip, res.text, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        login_gui(ip, res_cmcc.text, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_ip</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">        s.connect((<span class="string">&#x27;8.8.8.8&#x27;</span>, <span class="number">80</span>))</span><br><span class="line">        ip = s.getsockname()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        s.close()</span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login_gui</span>(<span class="params">ip, text, model</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> model == <span class="number">1</span>:</span><br><span class="line">        mod = <span class="string">&#x27;cmcc登录&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mod = <span class="string">&#x27;普通登录&#x27;</span></span><br><span class="line"></span><br><span class="line">    root = tk.Tk()</span><br><span class="line">    root.title(<span class="string">&#x27;校园网登录&#x27;</span>)</span><br><span class="line">    var = tk.StringVar()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;&quot;msg&quot;:&quot;&quot;&#x27;</span> <span class="keyword">in</span> text:</span><br><span class="line">        var.<span class="built_in">set</span>(<span class="string">&#x27;当前设备已登录\nip地址:%s\n%s&#x27;</span> % (ip, mod))</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">r&#x27;\u8ba4\u8bc1\u6210\u529f&#x27;</span> <span class="keyword">in</span> text:</span><br><span class="line">        var.<span class="built_in">set</span>(<span class="string">&#x27;登录成功\nip地址:%s\n%s&#x27;</span> % (ip, mod))</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;bGRhcCBhdXRoIGVycm9y&#x27;</span> <span class="keyword">in</span> text:</span><br><span class="line">        var.<span class="built_in">set</span>(<span class="string">&#x27;密码错误\nip地址:%s\n%s&#x27;</span> % (ip, mod))</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;aW51c2UsIGxvZ2luIGFnYWluL&#x27;</span> <span class="keyword">in</span> text:</span><br><span class="line">        var.<span class="built_in">set</span>(<span class="string">&#x27;其他设备已登录\nip地址:%s\n%s&#x27;</span> % (ip, mod))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        var.<span class="built_in">set</span>(<span class="string">&#x27;您可能欠费停机\nip地址:%s\n%s&#x27;</span> % (ip, mod))</span><br><span class="line">    lab = tk.Label(root, textvariable=var, font=(<span class="string">&#x27;Courier&#x27;</span>, <span class="number">15</span>), width=<span class="number">20</span>, height=<span class="number">20</span>)</span><br><span class="line">    lab.pack()  <span class="comment"># 把标签置入root界面布局</span></span><br><span class="line">    root.geometry(<span class="string">&quot;300x200+600+300&quot;</span>)  <span class="comment"># 将窗口移动到新位置（宽度为400，高度为300，上边距为100，左边距为100）</span></span><br><span class="line">    root.mainloop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    url_cmcc = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    url = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    ip = get_ip()</span><br><span class="line">    login(ip, url_cmcc, url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以改进的地方：</p>
<ul>
<li><p>可设置自动获取url来保存各个位置的<code>wlan_ac_ip</code>进而便捷地在校园任何地方都能自动连接校园网</p>
</li>
<li><p>可以进一步完善代码关于账号和密码输入部分以便于校园内同学使用</p>
</li>
</ul>
</li>
<li><p>可利用pyinstaller对文件进行打包</p>
<ul>
<li><code>pyinstaller -F -w main.py</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ul>
<li><a href="https://blog.csdn.net/m0_43404934/article/details/122331463?ops_request_misc=%7B%22request_id%22:%22168852791816782425186970%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168852791816782425186970&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122331463-null-null.142%5Ev88%5Econtrol,239%5Ev2%5Einsert_chatgpt&utm_term=request%E5%BA%93&spm=1018.2226.3001.4187">request库</a></li>
<li><a href="https://blog.csdn.net/youtufeitu/article/details/124306915?ops_request_misc=%7B%22request_id%22:%22168852796316800197099041%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168852796316800197099041&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-124306915-null-null.142%5Ev88%5Econtrol,239%5Ev2%5Einsert_chatgpt&utm_term=POST%E8%AF%B7%E6%B1%82%E5%92%8CGET%E8%AF%B7%E6%B1%82&spm=1018.2226.3001.4187">POST请求和GET请求</a></li>
<li><a href="https://blog.csdn.net/qq_46018418/article/details/105927203?ops_request_misc=%7B%22request_id%22:%22168852799516800192292061%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168852799516800192292061&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105927203-null-null.142%5Ev88%5Econtrol,239%5Ev2%5Einsert_chatgpt&utm_term=Tkinter%E5%BA%93&spm=1018.2226.3001.4187">Tkinter库</a></li>
<li><a href="https://blog.csdn.net/qq_44579321/article/details/127960439">校园网自动登陆</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/364016452">校园网自动登录全平台解决方案</a></li>
<li><a href="https://blog.csdn.net/qq_38830593/article/details/123092015?ops_request_misc=%7B%22request_id%22:%22168852774716800182194125%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168852774716800182194125&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-123092015-null-null.142%5Ev88%5Econtrol,239%5Ev2%5Einsert_chatgpt&utm_term=pyinstaller%E5%AF%B9%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8C%85&spm=1018.2226.3001.4187">pyinstaller对文件进行打包</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Linux常用命令总结</title>
    <url>/2023/03/18/Linux%E5%AD%A6%E4%B9%A0/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="文件和目录命令"><a href="#文件和目录命令" class="headerlink" title="文件和目录命令"></a>文件和目录命令</h1><ul>
<li><p>ls</p>
<ul>
<li><p><code>-a</code>显示指定目录下所有子目录和文件，包括隐藏文件</p>
</li>
<li><p><code>-l</code>纵向显示文件列表和详细信息</p>
</li>
<li><p><code>-h</code>以KB显示文件大小</p>
</li>
<li><p>通配符的使用</p>
<ul>
<li><blockquote>
<p><code>*</code>表示任意个数字符</p>
<p><code>？</code>表示任意一个字符</p>
<p><code>[]</code>表示可以匹配字符组中的任意一个</p>
<p><code>[abc]</code>匹配a，b，c中任意一个</p>
<p><code>[a-f]</code>匹配a到f范围中任意一个字符</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>cd </p>
<ul>
<li><code>cd</code> 切换到当前用户主目录&#x2F;home&#x2F;用户目录</li>
<li><code>cd ～</code> 切换到当前用户主目录&#x2F;home&#x2F;用户目录</li>
<li><code>cd . </code>保持当前目录不变</li>
<li><code>cd ..</code> 切换到上级目录</li>
<li><code>cd -</code> 可以在最近两次工作目录之间来回切换</li>
<li>绝对路径：在输入路径时最前面不是&#x2F;或～，表示相对当前目录所在的目录位置</li>
<li>相对路径：在输入路径时，最前面是&#x2F;或者～，表示从根目录&#x2F;家目录开始的具体位置</li>
</ul>
</li>
<li><p>touch</p>
<ul>
<li>文件不存在，创建文件</li>
<li>文件存在，修改末次修改时间</li>
</ul>
</li>
<li><p>mkdir</p>
<ul>
<li>创建目录，同一个目录下目录和文件都不能同名</li>
<li><code>-p</code>创建多级目录</li>
</ul>
</li>
<li><p>rm</p>
<ul>
<li>删除后无法恢复</li>
<li><code>-f</code>强制删除，忽略不存在的文件</li>
<li><code>-r</code>递归删除目录下内容，删除文件夹时使用</li>
</ul>
</li>
<li><p>tree</p>
<ul>
<li>以树状图列出文件目录结构</li>
<li><code>-d</code>只显示目录</li>
</ul>
</li>
</ul>
<h1 id="拷贝和移动命令"><a href="#拷贝和移动命令" class="headerlink" title="拷贝和移动命令"></a>拷贝和移动命令</h1><ul>
<li><p>cp</p>
<ul>
<li><code>cp 源文件 目标文件</code>复制文件或目录到另一个文件或目录中</li>
<li><code>-i</code>覆盖文件前提示</li>
<li><code>-r</code>若给出源文件是目录文件，则cp将递归复制该目录下所有子目录和文件，目标文件必须为一个目录名</li>
</ul>
</li>
<li><p>mv</p>
<ul>
<li>mv 源文件 目标文件：移动或重命名文件或目录</li>
<li><code>-i</code>覆盖前提示</li>
</ul>
</li>
</ul>
<h1 id="文件内容命令"><a href="#文件内容命令" class="headerlink" title="文件内容命令"></a>文件内容命令</h1><ul>
<li><p>cat</p>
<ul>
<li>显示文件全部内容</li>
<li><code>-b</code>为文件标行号</li>
<li><code>-n</code>为所有行标行号（包括空行）</li>
</ul>
</li>
<li><p>more</p>
<ul>
<li>分屏显示文件</li>
<li><code>Space</code>显示下一页</li>
<li><code>Enter</code>一次滚动一行</li>
<li><code>b</code>回滚一屏</li>
<li><code>f</code>前滚一屏</li>
<li><code>q</code>退出</li>
</ul>
</li>
<li><p>grep</p>
<ul>
<li>文本搜索工具</li>
<li><code>-n</code>显示匹配行及行号</li>
<li><code>-v</code>显示不含不包含目标文本的行</li>
<li><code>-i</code>忽略大小写</li>
<li><code>^a</code>行首，搜索以a开始的行</li>
<li><code>ke$</code>行尾，搜索以ke为结尾的行</li>
</ul>
</li>
<li><p>echo</p>
<ul>
<li>显示参数指定的文字</li>
<li><code>&gt;</code>表示输出，会覆盖文件原有内容</li>
<li><code>&gt;&gt;</code>表示输入，会将内容追加到已有文件的</li>
</ul>
</li>
<li><p>管道<code>|</code></p>
<ul>
<li>将一个命令的输出通过管道作为另一个命令的输入</li>
<li>more</li>
<li>grep</li>
</ul>
</li>
</ul>
<h1 id="远程操作命令"><a href="#远程操作命令" class="headerlink" title="远程操作命令"></a>远程操作命令</h1><ul>
<li><p>shutdown</p>
<ul>
<li><code>shutdown</code> 选项 时间</li>
<li><code>-r</code>重新启动</li>
<li><code>-c</code>取消关机计划</li>
</ul>
</li>
<li><p>ifconfig</p>
<ul>
<li>查看配置网卡设置信息</li>
<li><code>127.0.0.1</code>本地回环地址</li>
</ul>
</li>
<li><p>ping</p>
<ul>
<li>检测计算机到计算机网络连接是否正常，数值越大，速度越慢</li>
</ul>
</li>
<li><p>scp</p>
<ul>
<li>远程拷贝命令</li>
<li><code>scp -P port  filename user@remote:Desktop/filename</code><ul>
<li>复制当前目录下文件到远程文件夹</li>
</ul>
</li>
<li><code>scp -P port  user@remote:Desktop/filename filename</code><ul>
<li>从远程文件夹复制文件到当前目录</li>
</ul>
</li>
<li>WIN scp command<ul>
<li><code>scp -rp .\Desktop\Notes logo@192.168.142.128:Desktop/</code></li>
<li>复制当前目录下文件夹到远程目录</li>
<li><code>scp -p logo@192.168.142.128:Desktop/linuxNotes/Command.md C:\Users\admin\Desktop</code><ul>
<li>从远程文件夹复制文件到当前目录</li>
</ul>
</li>
</ul>
</li>
<li><code>-r</code>复制文件夹</li>
</ul>
</li>
<li><p>ssh</p>
<ul>
<li><p><code>ssh -p 22 user@remote</code></p>
</li>
<li><p><code>ssh-keygen</code>生成ssh钥匙</p>
</li>
<li><p><code>ssh-copy-id -p port user@remote</code>让远程服务器记住公匙</p>
</li>
<li><p>添加别名：在<code>~/.ssh/config</code>中追加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host logo_ubuntu</span><br><span class="line">	Hostname 172.***.***.***</span><br><span class="line">	User logo</span><br><span class="line">	Port 22</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="用户权限命令"><a href="#用户权限命令" class="headerlink" title="用户权限命令"></a>用户权限命令</h1><ul>
<li><p>ls -l 拓展</p>
<ul>
<li><blockquote>
<p>r 可读 4</p>
<p>w 可写 2</p>
<p>x 可执行 1</p>
</blockquote>
</li>
<li><blockquote>
<p>第一列（一个字符）：是否是文件夹标记</p>
<p>第二列（三个字符）：文件拥有者权限</p>
<p>第三列（三个字符）：组权限</p>
<p>第四列（三个字符）：其他用户权限</p>
<p>第五列（数字）：硬连接数</p>
<ul>
<li>硬连接数：有多少种方式可以访问当前目录&#x2F;文件</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>chmod</p>
<ul>
<li>修改用户&#x2F;组对文件&#x2F;目录权限</li>
<li><code>chmod +/- rwx 文件|目录名</code><ul>
<li>执行文件：<code>./文件名</code></li>
</ul>
</li>
</ul>
</li>
<li><p>sudo</p>
<ul>
<li>以其他身份来执行命令，预设的身份为root</li>
</ul>
</li>
</ul>
<h1 id="组管理命令"><a href="#组管理命令" class="headerlink" title="组管理命令"></a>组管理命令</h1><ul>
<li>创建组&#x2F;删除组都需要<code>sudo</code></li>
<li><code>groupadd 组名</code>添加组</li>
<li><code>groupdel 组名</code>删除组</li>
<li><code>cat/etc/group</code>确认组信息</li>
<li>组信息保存在<code>/etc/group</code>文件中</li>
<li><code>/etc</code>目录是专门用来保存系统配置信息的目录</li>
<li><code>chgrp -R 组名 文件/目录名</code>递归修改文件&#x2F;目录的所属组</li>
</ul>
<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><ul>
<li><p><code>useradd -m -g 组</code>添加新用户</p>
<ul>
<li>-m 自动建立用户家目录</li>
<li>-g 指定用户所在的组，否则会建立一个和用户同名的组</li>
</ul>
</li>
<li><p><code>passwd 用户名</code>设置用户密码</p>
</li>
<li><p><code>userdel -r 用户名</code>删除信息</p>
<ul>
<li>-r 删除用户家目录</li>
</ul>
</li>
<li><p><code>cat /etc/passwd | grep 用户名</code>确认用户信息，新建用户后，用户信息会保存在&#x2F;etc&#x2F;passwd中</p>
</li>
<li><p><code>id 用户名</code>查看用户UID（用户标识）和GID（组标识）信息</p>
</li>
<li><p><code>who</code>查看当前所有登陆的用户列表</p>
</li>
<li><p><code>whoami</code>查看当前登陆用户的账户名</p>
</li>
<li><p>passwd文件：<code>/etc/passwd</code>文件保存的是用户的信息，由6个分号组成的7个信息</p>
<ul>
<li><blockquote>
<p>用户名</p>
<p>密码（x，表示加密的密码）</p>
<p>UID</p>
<p>GID</p>
<p>用户全名或本地账号</p>
<p>家目录</p>
<p>登陆使用的Shell，就是登陆之后使用的终端命令，ubuntu默认的是dash</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>usermod -g 组 用户名</code>修改用户主组</p>
</li>
<li><p><code>usermod -G 组 用户名</code>修改用户附加组</p>
<ul>
<li><code>usermod -G sudo 用户名</code>给用户添加sudo权限</li>
</ul>
</li>
<li><p><code>usermod -s /bin/bash</code>修改用户登陆Shell为bash，XShell下dash存在缺陷</p>
</li>
<li><p>which</p>
<ul>
<li><code>which 命令</code>查看执行命令所在位置<ul>
<li><blockquote>
<p><code>/user/passwd</code>用于保存用户信息的文件</p>
<p><code>/user/bin/passwd</code>用于修改用户密码的程序</p>
<p><code>/bin</code>二进制执行文件目录，主要用于具体应用</p>
<p><code>/sbin</code>系统管理员专用的二进制代码存放目录，主要用于系统管理</p>
<p><code>/usr/bin</code>后期安装的一些软件</p>
<p><code>/usr/sbin</code>超级用户的一些管理程序</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>su</p>
<ul>
<li><code>su - 用户名</code>切换用户和目录</li>
<li><code>exit</code>退出当前登陆目录</li>
<li><code>su</code>切换到root，但不安全</li>
</ul>
</li>
<li><p>修改文件权限</p>
<ul>
<li><code>chown 用户名 文件名|目录名</code>修改文件的拥有者</li>
<li><code>chgrp -R 组名 文件名|目录名</code>递归修改文件的组</li>
<li><code>chmod -R 755</code>递归修改文件权限，三个数字分别代表拥有者&#x2F;组&#x2F;其他用户的权限</li>
<li>r -&gt; 4  w -&gt; 2  x -&gt; 1,例如755-&gt;rwx r-x r-x</li>
</ul>
</li>
</ul>
<h1 id="系统信息相关命令"><a href="#系统信息相关命令" class="headerlink" title="系统信息相关命令"></a>系统信息相关命令</h1><ul>
<li><p><code>date</code>查看当前系统时间</p>
</li>
<li><p><code>cal </code>查看日历</p>
<ul>
<li><code>-y</code>查看一年的日历</li>
</ul>
</li>
<li><p><code>df -h</code>显示磁盘剩余空间</p>
</li>
<li><p><code>du -h[目录名]</code>显示目录下文件大小</p>
</li>
<li><p><code>ps aux</code>查看进程的详细状况</p>
<ul>
<li><p><code>ps</code>默认只会显示当前用户通过终端启动的应用程序</p>
</li>
<li><blockquote>
<p>a 显示终端上的所有进程，包括其他用户的进程</p>
<p>u 显示进程的详细状态</p>
<p>x 显示没有控制终端的进程</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>top</code>动态显示运行中的进程并排序</p>
</li>
<li><p><code>kill [-9] 进程代号</code>终止指定代号的进程，-9表示强行终止</p>
<ul>
<li>使用<code>kill</code>时不要终止root身份开启的进程</li>
</ul>
</li>
</ul>
<h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ul>
<li><p>find</p>
<ul>
<li><code>find[路径] -name &quot;*.py&quot;</code>查找文件</li>
</ul>
</li>
<li><p>ln</p>
<ul>
<li><code>ln -s 被链接的源文件 链接文件</code>建立文件的软链接</li>
<li>无<code>-s</code>建立的是硬链接文件（两个文件占用相同大小的硬盘空间）</li>
<li>源文件要使用绝对路经，方便移动链接文件后仍能正常使用</li>
<li>在Linux中文件名和文件数据是分开存储的</li>
</ul>
</li>
</ul>
<h1 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h1><ul>
<li><p><code>tar -cvf 打包文件.tar</code>打包文件</p>
</li>
<li><p><code>tar -xvf 打包文件.tar</code>解包文件</p>
</li>
<li><blockquote>
<p>c 生成档案文件，创建打包文件</p>
<p>x 解开档案文件</p>
<p>v 列出归档解档的详细过程，显示进度</p>
<p>f 指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后</p>
</blockquote>
</li>
<li><p>gzip</p>
<ul>
<li><p>tar只负责打包文件，但不压缩</p>
</li>
<li><p>用gzip压缩打包后文件扩展名为<code>filename.tar.gz</code></p>
</li>
<li><p><code>tar -zcvf 打包文件.tar.gz 被压缩的文件/路径...</code>压缩文件</p>
</li>
<li><p><code>tar -zxvf 打包文件.tar.gz </code>解压缩文件</p>
</li>
<li><p><code>tar -zxvf 打包文件.tar.gz -C 目标路径</code>解压缩文件到指定路径（指定路径必须存在）</p>
</li>
</ul>
</li>
<li><p>bzip2</p>
<ul>
<li><code>tar -jcvf 打包文件.tar.gz 被压缩的文件/路径...</code>压缩文件</li>
<li><code>tar -jxvf 打包文件.tar.gz </code>解压缩文件</li>
</ul>
</li>
</ul>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><ul>
<li><p><code>sudo apt install 软件包</code></p>
</li>
<li><p><code>sudo apt remove 软件包</code></p>
</li>
<li><p><code>sudo apt upgrade</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Add Binary</title>
    <url>/2022/11/10/LeetCode/Add%20Binary/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/add-binary/description/">67.Add Binary</a></p>
<p>Given two binary strings <code>a</code> and <code>b</code>, return <em>their sum as a binary string</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">Output: &quot;100&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">Output: &quot;10101&quot;</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    string ans_str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> a_size = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> b_size = b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (a_size &lt; b_size) &#123;</span><br><span class="line">        <span class="type">int</span> temp = b_size - a_size;</span><br><span class="line">        <span class="keyword">while</span> (temp--)a += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> temp = a_size - b_size;</span><br><span class="line">        <span class="keyword">while</span> (temp--)b += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> carry = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a_size || i&lt;b_size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] + b[i] + carry == <span class="number">144</span>) &#123;<span class="comment">//&#x27;0&#x27;+&#x27;0&#x27;+&#x27;0&#x27; ASCII</span></span><br><span class="line">            ans_str += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            carry = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] + b[i] + carry == <span class="number">145</span>) &#123;<span class="comment">//&#x27;1&#x27;+&#x27;0&#x27;+&#x27;0&#x27; ASCII</span></span><br><span class="line">            ans_str += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            carry = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] + b[i] + carry == <span class="number">146</span>) &#123;<span class="comment">//&#x27;1&#x27;+&#x27;1&#x27;+&#x27;0&#x27; ASCII</span></span><br><span class="line">            ans_str += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            carry = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] + b[i] + carry == <span class="number">147</span>) &#123;<span class="comment">//&#x27;1&#x27;+&#x27;1&#x27;+&#x27;1&#x27; ASCII</span></span><br><span class="line">            ans_str += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            carry = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;mistake&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="string">&#x27;1&#x27;</span>)ans_str += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(ans_str.<span class="built_in">begin</span>(), ans_str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans_str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">empty</span>()) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (b.<span class="built_in">empty</span>()) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="type">int</span> index_a = a.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> index_b = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bit_a = <span class="number">0</span>, bit_b = <span class="number">0</span>;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> radix = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (index_a &gt;= <span class="number">0</span> || index_b &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        bit_a = <span class="number">0</span>, bit_b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (index_a &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            bit_a = a[index_a] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index_b &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            bit_b = b[index_b] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> sum = bit_a + bit_b + carry;</span><br><span class="line">        <span class="keyword">auto</span> bit = sum % radix;</span><br><span class="line">        carry = sum / radix;</span><br><span class="line">        result += bit + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        --index_a;</span><br><span class="line">        --index_b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        result += carry + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">begin</span>(result), <span class="built_in">end</span>(result));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Add Digits</title>
    <url>/2023/02/12/LeetCode/Add%20Digits/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/add-digits/description/">258.Add Digits</a></p>
<p>Given an integer <code>num</code>, repeatedly add all its digits until the result has only one digit, and return it.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num = 38</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The process is</span><br><span class="line">38 --&gt; 3 + 8 --&gt; 11</span><br><span class="line">11 --&gt; 1 + 1 --&gt; 2 </span><br><span class="line">Since 2 has only one digit, return it.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num = 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(log <em>num</em>)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">addDigits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += num%<span class="number">10</span>;</span><br><span class="line">                num/=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = sum;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(num &gt; <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/add-digits/solutions/1301157/ge-wei-xiang-jia-by-leetcode-solution-u4kj/">进阶：</a></p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">addDigits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Add Strings</title>
    <url>/2023/03/20/LeetCode/Add%20Strings/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/add-strings/description/">415.Add Strings</a></p>
<p>Given two non-negative integers, <code>num1</code> and <code>num2</code> represented as string, return <em>the sum of</em> <code>num1</code> <em>and</em> <code>num2</code> <em>as a string</em>.</p>
<p>You must solve the problem without using any built-in library for handling large integers (such as <code>BigInteger</code>). You must also not convert the inputs to integers directly.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num1 = &quot;11&quot;, num2 = &quot;123&quot;</span><br><span class="line">Output: &quot;134&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num1 = &quot;456&quot;, num2 = &quot;77&quot;</span><br><span class="line">Output: &quot;533&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num1 = &quot;0&quot;, num2 = &quot;0&quot;</span><br><span class="line">Output: &quot;0&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(max(len1,len2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = num1.<span class="built_in">length</span>() - <span class="number">1</span>, j = num2.<span class="built_in">length</span>() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x = i &gt;= <span class="number">0</span> ? num1[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> y = j &gt;= <span class="number">0</span> ? num2[j] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> result = x + y + add;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span> + result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i -= <span class="number">1</span>;</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Assign Cookies</title>
    <url>/2023/03/23/LeetCode/Assign%20Cookies/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/assign-cookies/">455.Assign Cookies</a></p>
<p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p>
<p>Each child <code>i</code> has a greed factor <code>g[i]</code>, which is the minimum size of a cookie that the child will be content with; and each cookie <code>j</code> has a size <code>s[j]</code>. If <code>s[j] &gt;= g[i]</code>, we can assign the cookie <code>j</code> to the child <code>i</code>, and the child <code>i</code> will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: g = [1,2,3], s = [1,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. </span><br><span class="line">And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.</span><br><span class="line">You need to output 1.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: g = [1,2], s = [1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. </span><br><span class="line">You have 3 cookies and their sizes are big enough to gratify all of the children, </span><br><span class="line">You need to output 2.</span><br></pre></td></tr></table></figure>

<p>排序法：</p>
<p>时间复杂度：O(nlogn+mlogm)<br>空间复杂度：O(logn+logm)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> j = g.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] &gt;= g[j]) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    g[j] = INT_MAX;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> m = g.<span class="built_in">size</span>(), n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n; i++, j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; g[i] &gt; s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Balanced Binary Tree</title>
    <url>/2022/12/24/LeetCode/Balanced%20Binary%20Tree/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/balanced-binary-tree/">110.Balanced Binary Tree</a></p>
<p>Given a binary tree, determine if it is <strong>height-balanced</strong></p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,2,3,3,null,null,4,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">height</span>(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left_height = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right_height = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (left_height == <span class="number">-1</span> || right_height == <span class="number">-1</span> || <span class="built_in">abs</span>(left_height - right_height) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Binary Tree In order Traversal</title>
    <url>/2022/11/15/LeetCode/Binary%20Tree%20In%20order%20Traversal/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">94.Binary Tree In order Traversal</a></p>
<p>Given the <code>root</code> of a binary tree, return <em>the in order traversal of its nodes’ values</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,null,2,3]</span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left, res);</span><br><span class="line">    res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">inorder</span>(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/same-tree/solutions/363636/xiang-tong-de-shu-by-leetcode-solution/">Morris 中序遍历：</a></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    TreeNode *predecessor = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">            predecessor = root-&gt;left;</span><br><span class="line">            <span class="keyword">while</span> (predecessor-&gt;right != <span class="literal">nullptr</span> &amp;&amp; predecessor-&gt;right != root) &#123;</span><br><span class="line">                predecessor = predecessor-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">            <span class="keyword">if</span> (predecessor-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                predecessor-&gt;right = root;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                predecessor-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Binary Tree Paths</title>
    <url>/2023/02/11/LeetCode/Binary%20Tree%20Paths/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-paths/description/">257.Binary Tree Paths</a></p>
<p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p>
<p>A <strong>leaf</strong> is a node with no children.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3,null,5]</span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [&quot;1&quot;]</span><br></pre></td></tr></table></figure>

<p>深度优先遍历：</p>
<p>时间复杂度：O(n2)</p>
<p>空间复杂度：O(n2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ret;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* root, string path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            path += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> || root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">                <span class="built_in">next</span>(root-&gt;left, path);</span><br><span class="line">                <span class="built_in">next</span>(root-&gt;right, path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">next</span>(root,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>广度优先遍历：</p>
<p>时间复杂度：O(n2)</p>
<p>空间复杂度：O(n2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; paths;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> paths;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; node_queue;</span><br><span class="line">        queue&lt;string&gt; path_queue;</span><br><span class="line"></span><br><span class="line">        node_queue.<span class="built_in">push</span>(root);</span><br><span class="line">        path_queue.<span class="built_in">push</span>(<span class="built_in">to_string</span>(root-&gt;val));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!node_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = node_queue.<span class="built_in">front</span>(); </span><br><span class="line">            string path = path_queue.<span class="built_in">front</span>();</span><br><span class="line">            node_queue.<span class="built_in">pop</span>();</span><br><span class="line">            path_queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                paths.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    node_queue.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                    path_queue.<span class="built_in">push</span>(path + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(node-&gt;left-&gt;val));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    node_queue.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                    path_queue.<span class="built_in">push</span>(path + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(node-&gt;right-&gt;val));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Binary Tree Postorder Traversal</title>
    <url>/2023/01/11/LeetCode/Binary%20Tree%20Postorder%20Traversal/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">145.Binary Tree Postorder Traversal</a></p>
<p>Given the <code>root</code> of a binary tree, return <em>the postorder traversal of its nodes’ values</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,null,2,3]</span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;ans_v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">postorder</span>(root-&gt;left,ans_v);</span><br><span class="line">            <span class="built_in">postorder</span>(root-&gt;right,ans_v);</span><br><span class="line">            ans_v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans_v;</span><br><span class="line">        <span class="built_in">postorder</span>(root,ans_v);</span><br><span class="line">        <span class="keyword">return</span> ans_v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == prev) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/solutions/431066/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/">Morris遍历：</a></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addPath</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec, TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(vec.<span class="built_in">end</span>() - count, vec.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *p1 = root, *p2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p2 = p1-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p2-&gt;right != <span class="literal">nullptr</span> &amp;&amp; p2-&gt;right != p1) &#123;</span><br><span class="line">                    p2 = p2-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p2-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    p2-&gt;right = p1;</span><br><span class="line">                    p1 = p1-&gt;left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p2-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="built_in">addPath</span>(res, p1-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addPath</span>(res, root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Best Time to Buy and Sell Stock</title>
    <url>/2022/12/29/LeetCode/Best%20Time%20to%20Buy%20and%20Sell%20Stock/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121.Best Time to Buy and Sell Stock</a></p>
<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p>
<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>
<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</span><br><span class="line">Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transactions are done and the max profit = 0.</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (price &lt; min) &#123;</span><br><span class="line">                min = price;</span><br><span class="line">                max = price;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (price &gt; max)max = price;</span><br><span class="line">            <span class="keyword">if</span> (ans &lt; (max - min))ans = max - min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Binary Tree Preorder Traversal</title>
    <url>/2023/01/10/LeetCode/Binary%20Tree%20Preorder%20Traversal/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144.Binary Tree Preorder Traversal</a></p>
<p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes’ values</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,null,2,3]</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;ans_v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans_v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">preorder</span>(root-&gt;left,ans_v);</span><br><span class="line">            <span class="built_in">preorder</span>(root-&gt;right,ans_v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans_v;</span><br><span class="line">        <span class="built_in">preorder</span>(root,ans_v);</span><br><span class="line">        <span class="keyword">return</span> ans_v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() || node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">                stk.<span class="built_in">emplace</span>(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/solutions/461821/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/">Morris 遍历：</a></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *p1 = root, *p2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p2 = p1-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p2-&gt;right != <span class="literal">nullptr</span> &amp;&amp; p2-&gt;right != p1) &#123;</span><br><span class="line">                    p2 = p2-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p2-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(p1-&gt;val);</span><br><span class="line">                    p2-&gt;right = p1;</span><br><span class="line">                    p1 = p1-&gt;left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p2-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(p1-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Binary Watch</title>
    <url>/2023/03/14/LeetCode/Binary%20Watch/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-watch/">401.Binary Watch</a></p>
<p>A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.</p>
<ul>
<li>For example, the below binary watch reads <code>&quot;4:51&quot;</code>.</li>
</ul>
<p><img src="https://assets.leetcode.com/uploads/2021/04/08/binarywatch.jpg" alt="img"></p>
<p>Given an integer <code>turnedOn</code> which represents the number of LEDs that are currently on (ignoring the PM), return <em>all possible times the watch could represent</em>. You may return the answer in <strong>any order</strong>.</p>
<p>The hour must not contain a leading zero.</p>
<ul>
<li>For example, <code>&quot;01:00&quot;</code> is not valid. It should be <code>&quot;1:00&quot;</code>.</li>
</ul>
<p>The minute must be consist of two digits and may contain a leading zero.</p>
<ul>
<li>For example, <code>&quot;10:2&quot;</code> is not valid. It should be <code>&quot;10:02&quot;</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: turnedOn = 1</span><br><span class="line">Output: [&quot;0:01&quot;,&quot;0:02&quot;,&quot;0:04&quot;,&quot;0:08&quot;,&quot;0:16&quot;,&quot;0:32&quot;,&quot;1:00&quot;,&quot;2:00&quot;,&quot;4:00&quot;,&quot;8:00&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: turnedOn = 9</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p>枚举法：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="type">int</span> turnedOn)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>; h &lt; <span class="number">12</span>; ++h) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">60</span>; ++m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (__builtin_popcount(h) + __builtin_popcount(m) == turnedOn) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(h) + <span class="string">&quot;:&quot;</span> + (m &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;&quot;</span>) + <span class="built_in">to_string</span>(m));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二进制枚举：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="type">int</span> turnedOn)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> h = i &gt;&gt; <span class="number">6</span>, m = i &amp; <span class="number">63</span>; <span class="comment">// 用位运算取出高 4 位和低 6 位</span></span><br><span class="line">            <span class="keyword">if</span> (h &lt; <span class="number">12</span> &amp;&amp; m &lt; <span class="number">60</span> &amp;&amp; __builtin_popcount(i) == turnedOn) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(h) + <span class="string">&quot;:&quot;</span> + (m &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;&quot;</span>) + <span class="built_in">to_string</span>(m));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Climbing Stairs</title>
    <url>/2022/11/12/LeetCode/Climbing%20Stairs/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/climbing-stairs/description/">70.Climbing Stairs</a></p>
<p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p>
<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure>

<p>动态规划：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p = q; </span><br><span class="line">        q = r; </span><br><span class="line">        r = p + q;<span class="comment">//爬到第r阶楼梯可能用1步或2步故第r阶楼梯等于第r-1阶加第r-2阶</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/">快速矩阵幂：</a></p>
<ul>
<li>时间复杂度：O(log ⁡n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">multiply</span>(vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; &amp;a, vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; &amp;b) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">c</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">matrixPow</span>(vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; a, <span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; ret = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = <span class="built_in">multiply</span>(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = <span class="built_in">multiply</span>(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; ret = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; res = <span class="built_in">matrixPow</span>(ret, n);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Contains Duplicate II</title>
    <url>/2023/02/03/LeetCode/Contains%20Duplicate%20II/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/contains-duplicate-ii/description/">219.Contains Duplicate II</a></p>
<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> <em>if there are two <strong>distinct indices</strong></em> <code>i</code> <em>and</em> <code>j</code> <em>in the array such that</em> <code>nums[i] == nums[j]</code> <em>and</em> <code>abs(i - j) &lt;= k</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,1], k = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,0,1,1], k = 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,1,2,3], k = 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums_size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(num) &amp;&amp; i - hash[num] &lt;= k)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            hash[num] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>滑动窗口：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(k+1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums_size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; k)hash.<span class="built_in">erase</span>(nums[i - k - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(nums[i]))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            hash.<span class="built_in">emplace</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Contains Duplicate</title>
    <url>/2023/02/02/LeetCode/Contains%20Duplicate/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/contains-duplicate/">217.Contains Duplicate</a></p>
<p>Given an integer array <code>nums</code>, return <code>true</code> if any value appears <strong>at least twice</strong> in the array, and return <code>false</code> if every element is distinct.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>排序法：</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums_size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(num))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> hash.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Counting Bits</title>
    <url>/2023/02/21/LeetCode/Counting%20Bits/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/counting-bits/description/">338.Counting Bits</a></p>
<p>Given an integer <code>n</code>, return <em>an array</em> <code>ans</code> <em>of length</em> <code>n + 1</code> <em>such that for each</em> <code>i</code> (<code>0 &lt;= i &lt;= n</code>)<em>,</em> <code>ans[i]</code> <em>is the <strong>number of</strong></em> <code>1</code><em><strong>‘s</strong> in the binary representation of</em> <code>i</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: [0,1,1]</span><br><span class="line">Explanation:</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 5</span><br><span class="line">Output: [0,1,1,2,1,2]</span><br><span class="line">Explanation:</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br><span class="line">3 --&gt; 11</span><br><span class="line">4 --&gt; 100</span><br><span class="line">5 --&gt; 101</span><br></pre></td></tr></table></figure>

<p>Brian Kernighan 算法：</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countOnes</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x &amp;= (x - <span class="number">1</span>);</span><br><span class="line">            ones++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = <span class="built_in">countOnes</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/counting-bits/solutions/627418/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/">动态规划：</a></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                highBit = i;</span><br><span class="line">            &#125;</span><br><span class="line">            bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Convert Sorted Array to Binary Search Tree</title>
    <url>/2022/12/23/LeetCode/Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108. Convert Sorted Array to Binary Search Tree</a></p>
<p>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a</em> </p>
<p><strong>height-balanced</strong> binary search tree.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line">Explanation: [0,-10,5,null,-3,null,9] is also accepted:</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,3]</span><br><span class="line">Output: [3,1]</span><br><span class="line">Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/solutions/312607/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-33/">中序遍历：</a></p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(log⁡ n)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总是选择中间位置左边的数字作为根节点</span></span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">helper</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">helper</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Convert a Number to Hexadecimal</title>
    <url>/2023/03/16/LeetCode/Convert%20a%20Number%20to%20Hexadecimal/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/convert-a-number-to-hexadecimal/">405.Convert a Number to Hexadecimal</a></p>
<p>Given an integer <code>num</code>, return <em>a string representing its hexadecimal representation</em>. For negative integers, <a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fr=aladdin">two’s complement</a> method is used.</p>
<p>All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.</p>
<p><strong>Note:</strong> You are not allowed to use any built-in library method to directly solve this problem.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num = 26</span><br><span class="line">Output: &quot;1a&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num = -1</span><br><span class="line">Output: &quot;ffffffff&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">toHex</span><span class="params">(<span class="type">int</span> num )</span> </span>&#123;</span><br><span class="line">        string pos = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> _num = num;</span><br><span class="line">        <span class="keyword">while</span> (_num)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += pos[_num % <span class="number">16</span>];</span><br><span class="line">            _num = _num / <span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>位运算：</p>
<p>时间复杂度：O(k)，k是整数的十六进制数的位数</p>
<p>空间复杂度：O(k)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">toHex</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string sb;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="type">int</span> val = (num &gt;&gt; (<span class="number">4</span> * i)) &amp; <span class="number">0xf</span>;</span><br><span class="line">            <span class="keyword">if</span> (sb.<span class="built_in">length</span>() &gt; <span class="number">0</span> || val &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">char</span> digit = val &lt; <span class="number">10</span> ? (<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + val) : (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + val - <span class="number">10</span>);</span><br><span class="line">                sb.<span class="built_in">push_back</span>(digit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Find the Difference</title>
    <url>/2023/03/11/LeetCode/Find%20the%20Difference/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/find-the-difference/description/">389.Find the Difference</a></p>
<p>You are given two strings <code>s</code> and <code>t</code>.</p>
<p>String <code>t</code> is generated by random shuffling string <code>s</code> and then add one more letter at a random position.</p>
<p>Return the letter that was added to <code>t</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abcd&quot;, t = &quot;abcde&quot;</span><br><span class="line">Output: &quot;e&quot;</span><br><span class="line">Explanation: &#x27;e&#x27; is the letter that was added.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;&quot;, t = &quot;y&quot;</span><br><span class="line">Output: &quot;y&quot;</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(S)，S表示字符集大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s)set[ch]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set[ch])set[ch]--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>求和：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> as = <span class="number">0</span>, at = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            as += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: t) &#123;</span><br><span class="line">            at += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> at - as;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>位运算：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            ret ^= ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: t) &#123;</span><br><span class="line">            ret ^= ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Excel Sheet Column Number</title>
    <url>/2023/01/15/LeetCode/Excel%20Sheet%20Column%20Number/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/excel-sheet-column-number/description/">171.Excel Sheet Column Number</a></p>
<p>Given a string <code>columnTitle</code> that represents the column title as appears in an Excel sheet, return <em>its corresponding column number</em>.</p>
<p>For example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: columnTitle = &quot;A&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: columnTitle = &quot;AB&quot;</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: columnTitle = &quot;ZY&quot;</span><br><span class="line">Output: 701</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">titleToNumber</span><span class="params">(string columnTitle)</span> </span>&#123;</span><br><span class="line">		<span class="type">long</span> n = <span class="built_in">pow</span>(<span class="number">26</span>, (columnTitle.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">char</span> c : columnTitle) &#123;</span><br><span class="line">			ans += (c - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>) * n;</span><br><span class="line">			n /= <span class="number">26</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Excel Sheet Column Title</title>
    <url>/2023/01/13/LeetCode/Excel%20Sheet%20Column%20Title/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/excel-sheet-column-title/description/">168.Excel Sheet Column Title</a></p>
<p>Given an integer <code>columnNumber</code>, return <em>its corresponding column title as it appears in an Excel sheet</em>.</p>
<p>For example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: columnNumber = 1</span><br><span class="line">Output: &quot;A&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: columnNumber = 28</span><br><span class="line">Output: &quot;AB&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: columnNumber = 701</span><br><span class="line">Output: &quot;ZY&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(log26<em>columnNumber</em>)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        string ans_s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (columnNumber != <span class="number">0</span>) &#123;</span><br><span class="line">            ans_s += (columnNumber - <span class="number">1</span>) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            columnNumber = (columnNumber - (columnNumber - <span class="number">1</span>) % <span class="number">26</span> - <span class="number">1</span>) / <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans_s.<span class="built_in">begin</span>(), ans_s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans_s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码优化：</p>
<p>时间复杂度：O(log26<em>columnNumber</em>)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (columnNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            --columnNumber;</span><br><span class="line">            ans += columnNumber % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            columnNumber /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Find All Numbers Disappeared in an Array</title>
    <url>/2023/03/22/LeetCode/Find%20All%20Numbers%20Disappeared%20in%20an%20Array/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/">448.Find All Numbers Disappeared in an Array</a></p>
<p>Given an array <code>nums</code> of <code>n</code> integers where <code>nums[i]</code> is in the range <code>[1, n]</code>, return <em>an array of all the integers in the range</em> <code>[1, n]</code> <em>that do not appear in</em> <code>nums</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,3,2,7,8,2,3,1]</span><br><span class="line">Output: [5,6]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nlogn)<br>空间复杂度：O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans_vec;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; count)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">while</span>(num &gt; count) &#123;</span><br><span class="line">                ans_vec.<span class="built_in">push_back</span>(count);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (count &lt;= nums_size) &#123;</span><br><span class="line">            ans_vec.<span class="built_in">push_back</span>(count);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原地修改：</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> x = (num - <span class="number">1</span>) % n;</span><br><span class="line">            nums[x] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= n) &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>First Bad Version</title>
    <url>/2023/02/15/LeetCode/First%20Bad%20Version/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/first-bad-version/description/">278.First Bad Version</a></p>
<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>
<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API <code>bool isBadVersion(version)</code> which returns whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 5, bad = 4</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line">Then 4 is the first bad version.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 1, bad = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>二分法：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The API isBadVersion is defined for you.</span></span><br><span class="line"><span class="comment">// bool isBadVersion(int version);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; </span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isBadVersion</span>(mid)) &#123;</span><br><span class="line">                right = mid; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>First Unique Character in a String</title>
    <url>/2023/03/10/LeetCode/First%20Unique%20Character%20in%20a%20String/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/first-unique-character-in-a-string/description/">387.First Unique Character in a String</a></p>
<p>Given a string <code>s</code>, <em>find the first non-repeating character in it and return its index</em>. If it does not exist, return <code>-1</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;leetcode&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;loveleetcode&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aabb&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>

<p>哈希表存储频数：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(S)，S为字符集大小，本题中S不大于26。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; frequency;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            ++frequency[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (frequency[s[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表存储索引：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(S)，S为字符集大小，本题中S不大于26。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; position;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (position.<span class="built_in">count</span>(s[i])) &#123;</span><br><span class="line">                position[s[i]] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                position[s[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> first = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [_, pos]: position) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos != <span class="number">-1</span> &amp;&amp; pos &lt; first) &#123;</span><br><span class="line">                first = pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first == n) &#123;</span><br><span class="line">            first = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>队列：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(S)，S为字符集大小，本题中S不大于26。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; position;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!position.<span class="built_in">count</span>(s[i])) &#123;</span><br><span class="line">                position[s[i]] = i;</span><br><span class="line">                q.<span class="built_in">emplace</span>(s[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                position[s[i]] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; position[q.<span class="built_in">front</span>().first] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>() ? <span class="number">-1</span> : q.<span class="built_in">front</span>().second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Fizz Buzz</title>
    <url>/2023/03/18/LeetCode/Fizz%20Buzz/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/fizz-buzz/description/">412.Fizz Buzz</a></p>
<p>Given an integer <code>n</code>, return <em>a string array</em> <code>answer</code> <em>(<strong>1-indexed</strong>) where</em>:</p>
<ul>
<li><code>answer[i] == &quot;FizzBuzz&quot;</code> if <code>i</code> is divisible by <code>3</code> and <code>5</code>.</li>
<li><code>answer[i] == &quot;Fizz&quot;</code> if <code>i</code> is divisible by <code>3</code>.</li>
<li><code>answer[i] == &quot;Buzz&quot;</code> if <code>i</code> is divisible by <code>5</code>.</li>
<li><code>answer[i] == i</code> (as a string) if none of the above conditions are true.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 5</span><br><span class="line">Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 15</span><br><span class="line">Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;7&quot;,&quot;8&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;11&quot;,&quot;Fizz&quot;,&quot;13&quot;,&quot;14&quot;,&quot;FizzBuzz&quot;]</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans_vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> == <span class="number">0</span>)ans_vec.<span class="built_in">push_back</span>(<span class="string">&quot;FizzBuzz&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)ans_vec.<span class="built_in">push_back</span>(<span class="string">&quot;Fizz&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>)ans_vec.<span class="built_in">push_back</span>(<span class="string">&quot;Buzz&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> ans_vec.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Guess Number Higher or Lower</title>
    <url>/2023/03/08/LeetCode/Guess%20Number%20Higher%20or%20Lower/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/guess-number-higher-or-lower/description/">374.Guess Number Higher or Lower</a></p>
<p>We are playing the Guess Game. The game is as follows:</p>
<p>I pick a number from <code>1</code> to <code>n</code>. You have to guess which number I picked.</p>
<p>Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.</p>
<p>You call a pre-defined API <code>int guess(int num)</code>, which returns three possible results:</p>
<ul>
<li><code>-1</code>: Your guess is higher than the number I picked (i.e. <code>num &gt; pick</code>).</li>
<li><code>1</code>: Your guess is lower than the number I picked (i.e. <code>num &lt; pick</code>).</li>
<li><code>0</code>: your guess is equal to the number I picked (i.e. <code>num == pick</code>).</li>
</ul>
<p>Return <em>the number that I picked</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 10, pick = 6</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 1, pick = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 2, pick = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>二分法：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">guessNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">guess</span>(mid) == <span class="number">1</span>)left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">guess</span>(mid) == <span class="number">-1</span>) right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Hamming Distance</title>
    <url>/2023/03/29/LeetCode/Hamming%20Distance/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/hamming-distance/description/">461.Hamming Distance</a></p>
<p>The <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>
<p>Given two integers <code>x</code> and <code>y</code>, return <em>the <strong>Hamming distance</strong> between them</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = 1, y = 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line">The above arrows point to positions where the corresponding bits are different.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = 3, y = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>位运算：</p>
<p>时间复杂度：O(log⁡C)，本题中logC &#x3D; log2^31</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">0</span> || y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((x &amp; <span class="number">1</span>) != (y &amp; <span class="number">1</span>))ans++;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = x ^ y, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s) &#123;</span><br><span class="line">            ret += s &amp; <span class="number">1</span>;</span><br><span class="line">            s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内置位运算：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __builtin_popcount(x ^ y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Brian Kernighan 算法：</p>
<p>时间复杂度：O(log⁡C)，本题中logC &#x3D; log2^31</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = x ^ y, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s) &#123;</span><br><span class="line">            s &amp;= s - <span class="number">1</span>;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Implement Stack using Queues</title>
    <url>/2023/02/04/LeetCode/Implement%20Stack%20using%20Queues/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225.Implement Stack using Queues</a></p>
<p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p>
<p>Implement the <code>MyStack</code> class:</p>
<ul>
<li><code>void push(int x)</code> Pushes element x to the top of the stack.</li>
<li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li>
<li><code>int top()</code> Returns the element on the top of the stack.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <strong>only</strong> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // return 2</span><br><span class="line">myStack.pop(); // return 2</span><br><span class="line">myStack.empty(); // return False</span><br></pre></td></tr></table></figure>

<p>两个队列：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que2;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que2.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(!que1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(que1,que2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r = que1.<span class="built_in">front</span>();</span><br><span class="line">        que1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>一个队列：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> que_size = que.<span class="built_in">size</span>();</span><br><span class="line">        que.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(que_size--) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Happy Number</title>
    <url>/2023/01/19/LeetCode/Happy%20Number/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/happy-number/description/">202.Happy Number</a></p>
<p>Write an algorithm to determine if a number <code>n</code> is happy.</p>
<p>A <strong>happy number</strong> is a number defined by the following process:</p>
<ul>
<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>
<li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li>
<li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li>
</ul>
<p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 19</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">                n /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(sum))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hash.<span class="built_in">insert</span>(sum);</span><br><span class="line">                n = sum;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>快慢指针：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_next</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (value) &#123;</span><br><span class="line">            sum += (value % <span class="number">10</span>) * (value % <span class="number">10</span>);</span><br><span class="line">            value /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = n;</span><br><span class="line">        <span class="type">int</span> fast = <span class="built_in">get_next</span>(n);</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="number">1</span> &amp;&amp; fast != slow) &#123;</span><br><span class="line">            slow = <span class="built_in">get_next</span>(slow);</span><br><span class="line">            fast = <span class="built_in">get_next</span>(<span class="built_in">get_next</span>(fast));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Implement Queue using Stacks</title>
    <url>/2023/02/08/LeetCode/Implement%20Queue%20using%20Stacks/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232.Implement Queue using Stacks</a></p>
<p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p>
<p>Implement the <code>MyQueue</code> class:</p>
<ul>
<li><code>void push(int x)</code> Pushes element x to the back of the queue.</li>
<li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li>
<li><code>int peek()</code> Returns the element at the front of the queue.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code> otherwise.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <strong>only</strong> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure>

<p>两个堆栈：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk2;</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stk1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            stk2.<span class="built_in">push</span>(stk1.<span class="built_in">top</span>());</span><br><span class="line">            stk1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        stk2.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(!stk2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            stk1.<span class="built_in">push</span>(stk2.<span class="built_in">top</span>());</span><br><span class="line">            stk2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> value = stk1.<span class="built_in">top</span>();</span><br><span class="line">        stk1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk1.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Intersection of Two Arrays II</title>
    <url>/2023/02/26/LeetCode/Intersection%20of%20Two%20Arrays%20II/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/">350.Intersection of Two Arrays II</a></p>
<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must appear as many times as it shows in both arrays and you may return the result in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2,2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">Output: [4,9]</span><br><span class="line">Explanation: [9,4] is also accepted.</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<p>时间复杂度：O(mlogm+nlogn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> length1 = nums1.<span class="built_in">size</span>(), length2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;</span><br><span class="line">            <span class="type">int</span> num1 = nums1[index1], num2 = nums2[index2];</span><br><span class="line">            <span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">                intersection.<span class="built_in">push_back</span>(num1);</span><br><span class="line">                index1++;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(m+n)</p>
<p>空间复杂度：O(min(m,n))</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.<span class="built_in">size</span>() &gt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">intersect</span>(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1) &#123;</span><br><span class="line">            ++m[num];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(num)) &#123;</span><br><span class="line">                intersection.<span class="built_in">push_back</span>(num);</span><br><span class="line">                --m[num];</span><br><span class="line">                <span class="keyword">if</span> (m[num] == <span class="number">0</span>) &#123;</span><br><span class="line">                    m.<span class="built_in">erase</span>(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Intersection of Two Arrays</title>
    <url>/2023/02/25/LeetCode/Intersection%20of%20Two%20Arrays/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349.Intersection of Two Arrays</a></p>
<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">Output: [9,4]</span><br><span class="line">Explanation: [4,9] is also accepted.</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n+m)</p>
<p>空间复杂度：O(n+m)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set1;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1)set1.<span class="built_in">insert</span>(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2)set2.<span class="built_in">insert</span>(num);</span><br><span class="line">        <span class="keyword">if</span> (set1.<span class="built_in">size</span>() &gt; set2.<span class="built_in">size</span>())<span class="built_in">swap</span>(set1, set2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : set1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set2.<span class="built_in">count</span>(num))ans.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<p>时间复杂度：O(nlogn+mlogm)</p>
<p>空间复杂度：O(nlogn+mlogm)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> length1 = nums1.<span class="built_in">size</span>(), length2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;</span><br><span class="line">            <span class="type">int</span> num1 = nums1[index1], num2 = nums2[index2];</span><br><span class="line">            <span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">                <span class="comment">// 保证加入元素的唯一性</span></span><br><span class="line">                <span class="keyword">if</span> (!intersection.<span class="built_in">size</span>() || num1 != intersection.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                    intersection.<span class="built_in">push_back</span>(num1);</span><br><span class="line">                &#125;</span><br><span class="line">                index1++;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Intersection of Two Linked Lists</title>
    <url>/2023/01/12/LeetCode/Intersection%20of%20Two%20Linked%20Lists/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">160.Intersection of Two Linked Lists</a></p>
<p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p>
<p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_statement.png" alt="img"></p>
<p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p>
<p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p>
<p><strong>Custom Judge:</strong></p>
<p>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):</p>
<ul>
<li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li>
<li><code>listA</code> - The first linked list.</li>
<li><code>listB</code> - The second linked list.</li>
<li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li>
<li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li>
</ul>
<p>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">Output: Intersected at &#x27;8&#x27;</span><br><span class="line">Explanation: The intersected node&#x27;s value is 8 (note that this must not be 0 if the two lists intersect).</span><br><span class="line">From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</span><br><span class="line">- Note that the intersected node&#x27;s value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">Output: Intersected at &#x27;2&#x27;</span><br><span class="line">Explanation: The intersected node&#x27;s value is 2 (note that this must not be 0 if the two lists intersect).</span><br><span class="line">From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">Output: No intersection</span><br><span class="line">Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.</span><br><span class="line">Explanation: The two lists do not intersect, so return null.</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n+m)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; hashtable;</span><br><span class="line">        <span class="keyword">while</span>(headA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            hashtable.<span class="built_in">insert</span>(headA);</span><br><span class="line">            headA = headA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(headB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashtable.<span class="built_in">count</span>(headB))<span class="keyword">return</span> headB;</span><br><span class="line">            headB = headB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solutions/811625/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/">双指针：</a></p>
<p>时间复杂度：O(n+m)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">nullptr</span> ? headB : pA-&gt;next;</span><br><span class="line">            pB = pB == <span class="literal">nullptr</span> ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Invert Binary Tree</title>
    <url>/2023/02/05/LeetCode/Invert%20Binary%20Tree/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/invert-binary-tree/description/">226.Invert Binary Tree</a></p>
<p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [4,2,7,1,3,6,9]</span><br><span class="line">Output: [4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: [2,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tree_next</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">tree_next</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">tree_next</span>(root-&gt;right);</span><br><span class="line">        TreeNode* temp;</span><br><span class="line">        temp = root-&gt;right;</span><br><span class="line">        root-&gt;right = root-&gt;left;</span><br><span class="line">        root-&gt;left = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">tree_next</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* left = <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        TreeNode* right = <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Is Subsequence</title>
    <url>/2023/03/13/LeetCode/Is%20Subsequence/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/is-subsequence/description/">392.Is Subsequence</a></p>
<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>s</code> <em>is a <strong>subsequence</strong> of</em> <code>t</code><em>, or</em> <code>false</code> <em>otherwise</em>.</p>
<p>A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<p>时间复杂度：O(n+m)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>(), m = t.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/is-subsequence/solutions/346539/pan-duan-zi-xu-lie-by-leetcode-solution/">动态规划：</a></p>
<p>时间复杂度：O(m*S+n)，S为字符集大小</p>
<p>空间复杂度：O(m*s)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">f</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            f[m][i] = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i] == j + <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                    f[i][j] = i;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i][j] = f[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[add][s[i] - <span class="string">&#x27;a&#x27;</span>] == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            add = f[add][s[i] - <span class="string">&#x27;a&#x27;</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Linked List Cycle</title>
    <url>/2023/01/09/LeetCode/Linked%20List%20Cycle/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/linked-list-cycle/description/">141.Linked List Cycle</a></p>
<p>Given head, the head of a linked list, determine if the linked list has a cycle in it.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s next pointer is connected to. Note that <code>pos</code> is not passed as a parameter.</p>
<p>Return true if there is a cycle in the linked list. Otherwise, return false.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2], pos = 0</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1], pos = -1</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; hashtable;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashtable.<span class="built_in">count</span>(head))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            hashtable.<span class="built_in">insert</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/linked-list-cycle/solutions/440042/huan-xing-lian-biao-by-leetcode-solution/">快慢指针：</a></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Isomorphic Strings</title>
    <url>/2023/01/31/LeetCode/Isomorphic%20Strings/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/isomorphic-strings/">205.Isomorphic Strings</a></p>
<p>Given two strings <code>s</code> and <code>t</code>, <em>determine if they are isomorphic</em>.</p>
<p>Two strings <code>s</code> and <code>t</code> are isomorphic if the characters in <code>s</code> can be replaced to get <code>t</code>.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;egg&quot;, t = &quot;add&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;foo&quot;, t = &quot;bar&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;paper&quot;, t = &quot;title&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(m)，m为字符串字符集数目</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">		unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt;<span class="type">s_t</span>;</span><br><span class="line">		unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt;t_s; </span><br><span class="line">		<span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="type">char</span> x = s[i];</span><br><span class="line">			<span class="type">char</span> y = t[i];</span><br><span class="line">			<span class="keyword">if</span> ((<span class="type">s_t</span>.<span class="built_in">count</span>(x) &amp;&amp; <span class="type">s_t</span>[x] != y) </span><br><span class="line">                || (t_s.<span class="built_in">count</span>(y) &amp;&amp; t_s[y] != x))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="type">s_t</span>[x] = y;</span><br><span class="line">			t_s[y] = x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Length of Last Word</title>
    <url>/2022/11/08/LeetCode/Length%20of%20Last%20Word/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/length-of-last-word/description/">58.Length of Last Word</a></p>
<p>Given a string <code>s</code> consisting of words and spaces, return <em>the length of the <strong>last</strong> word in the string.</em></p>
<p>A <strong>word</strong> is a maximal substring consisting of non-space characters only.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;Hello World&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The last word is &quot;World&quot; with length 5.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;   fly me   to   the moon  &quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The last word is &quot;moon&quot; with length 4.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;luffy is still joyboy&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The last word is &quot;joyboy&quot; with length 6.</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s_size = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s_size; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[i]))</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;<span class="comment">//单词前不存在空格的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Longest Common Prefix</title>
    <url>/2022/11/02/LeetCode/Longest%20Common%20Prefix/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/longest-common-prefix/description/">14.Longest Common Prefix</a></p>
<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string “”.</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    string ans_string = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> nums_string = <span class="built_in">size</span>(strs);<span class="comment">//字符串的数目</span></span><br><span class="line">    <span class="type">int</span> min_lenth_string = strs[<span class="number">0</span>].<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums_string; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs[i].<span class="built_in">length</span>() &lt; min_lenth_string)min_lenth_string = strs[i].<span class="built_in">length</span>();<span class="comment">//找到最短的字符串的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; min_lenth_string; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums_string; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[<span class="number">0</span>][i] != strs[j][i])<span class="keyword">return</span> ans_string;</span><br><span class="line">        &#125;</span><br><span class="line">        ans_string += strs[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans_string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestCommonPerfix</span><span class="params">(vector&lt;string&gt; strs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">begin</span>(strs), <span class="built_in">end</span>(strs));</span><br><span class="line">    <span class="type">int</span> size = strs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">min</span>(strs[<span class="number">0</span>].<span class="built_in">size</span>(), strs[size<span class="number">-1</span>].<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs[<span class="number">0</span>][index] == strs[size<span class="number">-1</span>][index]) ++index;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Longest Palindrome</title>
    <url>/2023/03/17/LeetCode/Longest%20Palindrome/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/longest-palindrome/description/">409.Longest Palindrome</a></p>
<p>Given a string <code>s</code> which consists of lowercase or uppercase letters, return <em>the length of the <strong>longest palindrome</strong></em> that can be built with those letters.</p>
<p>Letters are <strong>case sensitive</strong>, for example, <code>&quot;Aa&quot;</code> is not considered a palindrome here.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abccccdd&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;a&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The longest palindrome that can be built is &quot;a&quot;, whose length is 1.</span><br></pre></td></tr></table></figure>

<p>贪心：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(S)，S为字符集大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s)</span><br><span class="line">            ++count[c];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : count) &#123;</span><br><span class="line">            <span class="type">int</span> v = p.second;</span><br><span class="line">            ans += v / <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (v % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; ans % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Majority Element</title>
    <url>/2023/01/14/LeetCode/Majority%20Element/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/majority-element/description/">169.Majority Element</a></p>
<p>Given an array <code>nums</code> of size <code>n</code>, return <em>the majority element</em>.</p>
<p>The majority element is the element that appears more than <code>⌊n / 2⌋</code> times. You may assume that the majority element always exists in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>排序法：</p>
<p>时间复杂度：<em>O</em>(<em>n</em>log<em>n</em>)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> times = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums_size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                times++;</span><br><span class="line">                <span class="keyword">if</span> (times &gt; nums_size / <span class="number">2</span>)<span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> times = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：<em>O</em>(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">        <span class="type">int</span> majority = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            ++counts[num];</span><br><span class="line">            <span class="keyword">if</span> (counts[num] &gt; cnt) &#123;</span><br><span class="line">                majority = num;</span><br><span class="line">                cnt = counts[num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>随机法：</p>
<p>时间复杂度：<em>O</em>(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> candidate = nums[<span class="built_in">rand</span>() % nums_size];</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">                <span class="keyword">if</span> (num == candidate)</span><br><span class="line">                    ++count;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; nums_size / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>分治：</p>
<p>时间复杂度：<em>O</em>(<em>n</em>log<em>n</em>)</p>
<p>空间复杂度：O(log<em>n</em>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count_in_range</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lo; i &lt;= hi; ++i)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target)</span><br><span class="line">                ++count;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majority_element_rec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi)</span><br><span class="line">            <span class="keyword">return</span> nums[lo];</span><br><span class="line">        <span class="type">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> left_majority = <span class="built_in">majority_element_rec</span>(nums, lo, mid);</span><br><span class="line">        <span class="type">int</span> right_majority = <span class="built_in">majority_element_rec</span>(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">count_in_range</span>(nums, left_majority, lo, hi) &gt; (hi - lo + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> left_majority;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">count_in_range</span>(nums, right_majority, lo, hi) &gt; (hi - lo + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> right_majority;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">majority_element_rec</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/">Boyer-Moore 投票算法：</a></p>
<p>时间复杂度：<em>O</em>(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> candidate = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == candidate)</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (--count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Maximum Depth of Binary Tree</title>
    <url>/2022/11/18/LeetCode/Maximum%20Depth%20of%20Binary%20Tree/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104.Maximum Depth of Binary Tree</a></p>
<p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>
<p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,null,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>深度优选搜索：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：<em>O</em>(<em>height</em>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>广度优先搜索：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：<em>O</em>(<em>n</em>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> sz = Q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (sz &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode* node = Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            sz -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Merge Sorted Array</title>
    <url>/2022/11/14/LeetCode/Merge%20Sorted%20Array/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/merge-sorted-array/description/">88.Merge Sorted Array</a></p>
<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p>
<p><strong>Merge</strong> <code>nums1</code> and <code>nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.</p>
<p>The final sorted array should not be returned by the function, but instead be <em>stored inside the array</em> <code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">Output: [1,2,2,3,5,6]</span><br><span class="line">Explanation: The arrays we are merging are [1,2,3] and [2,5,6].</span><br><span class="line">The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The arrays we are merging are [1] and [].</span><br><span class="line">The result of the merge is [1].</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The arrays we are merging are [] and [1].</span><br><span class="line">The result of the merge is [1].</span><br><span class="line">Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：<em>O</em>((<em>m</em>+<em>n</em>)log(<em>m</em>+<em>n</em>))（套用快速排序）</p>
<p>空间复杂度：<em>O</em>(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">        nums1[m + i] = nums2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逆向双指针：</p>
<p>时间复杂度：O(m+n)。</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p1 = m - <span class="number">1</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> tail = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="number">-1</span>) &#123;</span><br><span class="line">            cur = nums2[p2--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == <span class="number">-1</span>) &#123;</span><br><span class="line">            cur = nums1[p1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">            cur = nums1[p1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = nums2[p2--];</span><br><span class="line">        &#125;</span><br><span class="line">        nums1[tail--] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Missing Number</title>
    <url>/2023/02/14/LeetCode/Missing%20Number/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/missing-number/description/">268.Missing Number</a></p>
<p>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3,0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure>

<p>排序法：</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums_size<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i + <span class="number">1</span>] - <span class="number">1</span>)<span class="keyword">return</span> nums[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] != <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> nums_size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums_size; i++) &#123;</span><br><span class="line">            hash.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> missing = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nums_size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hash.<span class="built_in">count</span>(i)) &#123;</span><br><span class="line">                missing = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> missing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>数学：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> total = n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> arrSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arrSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total - arrSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>位运算：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Merge Two Sorted Lists</title>
    <url>/2022/11/04/LeetCode/Merge%20Two%20Sorted%20Lists/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">21.Merge Two Sorted Lists</a></p>
<p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p>
<p>Merge the two lists in a one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p>
<p>Return <em>the head of the merged linked list</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: list1 = [1,2,4], list2 = [1,3,4]</span><br><span class="line">Output: [1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: list1 = [], list2 = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: list1 = [], list2 = [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    ListNode* ans_list = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode* node = ans_list;</span><br><span class="line">    <span class="keyword">while</span> (list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">            node-&gt;next = list1;</span><br><span class="line">            list1 = list1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;next = list2;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;next = list1 == <span class="literal">nullptr</span> ? list2 : list1;<span class="comment">//将未合并完的一个链表直接接在ans_list之后</span></span><br><span class="line">    <span class="keyword">return</span> ans_list-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">        l1-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Minimum Depth of Binary Tree</title>
    <url>/2022/12/25/LeetCode/Minimum%20Depth%20of%20Binary%20Tree/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111.Minimum Depth of Binary Tree</a></p>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,null,3,null,4,null,5,null,6]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p>深度优先遍历：</p>
<p>时间复杂度：O(N)，N为节点数</p>
<p>空间复杂度：O(H)，H为树高度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> min_depth = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            min_depth = <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            min_depth = <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;right), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/solutions/382646/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/">广度优先遍历：</a></p>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(N)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;pair&lt;TreeNode *, <span class="type">int</span>&gt; &gt; que;</span><br><span class="line">        que.<span class="built_in">emplace</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *node = que.<span class="built_in">front</span>().first;</span><br><span class="line">            <span class="type">int</span> depth = que.<span class="built_in">front</span>().second;</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> depth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que.<span class="built_in">emplace</span>(node-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que.<span class="built_in">emplace</span>(node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Move Zeroes</title>
    <url>/2023/02/16/LeetCode/Move%20Zeroes/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/move-zeroes/description/">283.Move Zeroes</a></p>
<p>Given an integer array <code>nums</code>, move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Note</strong> that you must do this in-place without making a copy of the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[left], nums[right]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Number of Segments in a String</title>
    <url>/2023/03/21/LeetCode/Number%20of%20Segments%20in%20a%20String/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/number-of-segments-in-a-string/">434.Number of Segments in a String</a></p>
<p>Given a string <code>s</code>, return <em>the number of segments in the string</em>.</p>
<p>A <strong>segment</strong> is defined to be a contiguous sequence of <strong>non-space characters</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;Hello, my name is John&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The five segments are [&quot;Hello,&quot;, &quot;my&quot;, &quot;name&quot;, &quot;is&quot;, &quot;John&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;Hello&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>上锁：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSegments</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch != <span class="string">&#x27; &#x27;</span> &amp;&amp; flag) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>)flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原地法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSegments</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> segmentCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i == <span class="number">0</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                segmentCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> segmentCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Nim Game</title>
    <url>/2023/02/18/LeetCode/Nim%20Game/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/nim-game/description/">292.Nim Game</a></p>
<p>You are playing the following <a href="https://baike.baidu.com/item/Nim%E6%B8%B8%E6%88%8F/6737105">Nim</a> Game with your friend:</p>
<ul>
<li>Initially, there is a heap of stones on the table.</li>
<li>You and your friend will alternate taking turns, and <strong>you go first</strong>.</li>
<li>On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.</li>
<li>The one who removes the last stone is the winner.</li>
</ul>
<p>Given <code>n</code>, the number of stones in the heap, return <code>true</code> <em>if you can win the game assuming both you and your friend play optimally, otherwise return</em> <code>false</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 4</span><br><span class="line">Output: false</span><br><span class="line">Explanation: These are the possible outcomes:</span><br><span class="line">1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.</span><br><span class="line">2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.</span><br><span class="line">3. You remove 3 stones. Your friend removes the last stone. Your friend wins.</span><br><span class="line">In all outcomes, your friend wins.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)<br>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Number of 1 Bits</title>
    <url>/2023/01/17/LeetCode/Number%20of%201%20Bits/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/number-of-1-bits/">191.Number of 1 Bits</a></p>
<p>Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F">Hamming weight</a>.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</li>
<li>In Java, the compiler represents the signed integers using <a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fromtitle=%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81&fromid=5295284">2’s complement notation</a>. Therefore, in <strong>Example 3</strong>, the input represents the signed integer. <code>-3</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 00000000000000000000000000001011</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The input binary string 00000000000000000000000000001011 has a total of three &#x27;1&#x27; bits.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 00000000000000000000000010000000</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The input binary string 00000000000000000000000010000000 has a total of one &#x27;1&#x27; bit.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 11111111111111111111111111111101</span><br><span class="line">Output: 31</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &#x27;1&#x27; bits.</span><br></pre></td></tr></table></figure>

<p>位操作：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>)sum += <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Palindrome Linked List</title>
    <url>/2023/02/09/LeetCode/Palindrome%20Linked%20List/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/palindrome-linked-list/description/">234.Palindrome Linked List</a></p>
<p>Given the <code>head</code> of a singly linked list, return <code>true</code> if it is a <em>palindrome</em> <em>or</em> <code>false</code> <em>otherwise</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* frontPointer;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recursivelyCheck</span><span class="params">(ListNode* currentNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">recursivelyCheck</span>(currentNode-&gt;next)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currentNode-&gt;val != frontPointer-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            frontPointer = frontPointer-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        frontPointer = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursivelyCheck</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方法不仅使用了 O(n)的空间，且比将链表复制到数组方法更差，因为在许多语言中，堆栈帧的开销很大（如 Python），并且最大的运行时堆栈深度为 1000（可以增加，但是有可能导致底层解释程序内存出错）。为每个节点创建堆栈帧极大的限制了算法能够处理的最大链表大小。</p>
<p><a href="https://leetcode.cn/problems/palindrome-linked-list/solutions/457059/hui-wen-lian-biao-by-leetcode-solution/">快慢指针：</a></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        ListNode* firstHalfEnd = <span class="built_in">endOfFirstHalf</span>(head);</span><br><span class="line">        ListNode* secondHalfStart = <span class="built_in">reverseList</span>(firstHalfEnd-&gt;next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否回文</span></span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        ListNode* p2 = secondHalfStart;</span><br><span class="line">        <span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val) &#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">        firstHalfEnd-&gt;next = <span class="built_in">reverseList</span>(secondHalfStart);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* nextTemp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">endOfFirstHalf</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Pascal&#39;s Triangle II</title>
    <url>/2022/12/28/LeetCode/Pascal&#39;s%20Triangle%20II/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/pascals-triangle-ii/description/">119. Pascal’s Triangle II</a></p>
<p>Given an integer <code>rowIndex</code>, return the <code>rowIndexth</code> (<strong>0-indexed</strong>) row of the <strong>Pascal’s triangle</strong>.</p>
<p>In <strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>
<p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: rowIndex = 3</span><br><span class="line">Output: [1,3,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: rowIndex = 0</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: rowIndex = 1</span><br><span class="line">Output: [1,1]</span><br></pre></td></tr></table></figure>
<p>个人解答：</p>
<p>时间复杂度：O(rowIndex)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans_v</span><span class="params">(rowIndex+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class="line">            ans_v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            ans_v[i] = <span class="number">1</span>;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;temp_v = ans_v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                ans_v[j] = temp_v[j] + temp_v[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>进一步优化（一个数组）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(rowIndex + <span class="number">1</span>)</span></span>;</span><br><span class="line">        row[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">                row[j] += row[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> row;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Palindrome Number</title>
    <url>/2022/10/31/LeetCode/Palindrome%20Number/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/palindrome-number/description/">9.Palindrome Number</a></p>
<p>Given an integer x, return true if x is palindrome integer.</p>
<p>An integer is a palindrome when it reads the same backward as forward.</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = 121</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 121 reads as 121 from left to right and from right to left.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//x位数</span></span><br><span class="line">	<span class="type">int</span> temp = x;</span><br><span class="line">	<span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">		temp /= <span class="number">10</span>;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> first = <span class="built_in">pow</span>(<span class="number">10</span>, count<span class="number">-1</span>);<span class="comment">//选中首位时所需除数</span></span><br><span class="line">	count /= <span class="number">2</span>;<span class="comment">//只需遍历数字一半</span></span><br><span class="line">	<span class="keyword">while</span> (count--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x / first != x % <span class="number">10</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			x %= first;</span><br><span class="line">			x /= <span class="number">10</span>;</span><br><span class="line">			first /= <span class="number">100</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_palindrome</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> divdend = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (divdend &lt; value) &#123;</span><br><span class="line">            divdend *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        divdend /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> first = value / divdend;</span><br><span class="line">            <span class="type">int</span> last = value % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (first != last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            value = (value % divdend) / <span class="number">10</span>;</span><br><span class="line">            divdend /= <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_palindrome_str</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(value);</span><br><span class="line">        string backup = s;</span><br><span class="line">        <span class="built_in">reverse</span>(<span class="built_in">begin</span>(s), <span class="built_in">end</span>(s));</span><br><span class="line">        <span class="keyword">return</span> s == backup;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; value) &#123;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">&quot; is palindrome: &quot;</span> &lt;&lt; boolalpha &lt;&lt; sol.<span class="built_in">is_palindrome_str</span>(value) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Pascal&#39;s Triangle</title>
    <url>/2022/12/27/LeetCode/Pascal&#39;s%20Triangle/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/pascals-triangle/description/">118.Pascal’s Triangle</a></p>
<p>Given an integer <code>numRows</code>, return the first <code>numRows</code> of <strong>Pascal’s triangle</strong>.</p>
<p>In <strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: numRows = 5</span><br><span class="line">Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: numRows = 1</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(numRows^2^)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans_v</span>(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">            ans_v[i].<span class="built_in">resize</span>(i + <span class="number">1</span>);</span><br><span class="line">            ans_v[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            ans_v[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                ans_v[i][j] = ans_v[i - <span class="number">1</span>][j] + ans_v[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Path Sum</title>
    <url>/2022/12/26/LeetCode/Path%20Sum/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/path-sum/description/">112.Path Sum</a></p>
<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>
<p>A <strong>leaf</strong> is a node with no children.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The root-to-leaf path with the target sum is shown.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3], targetSum = 5</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There two root-to-leaf paths in the tree:</span><br><span class="line">(1 --&gt; 2): The sum is 3.</span><br><span class="line">(1 --&gt; 3): The sum is 4.</span><br><span class="line">There is no root-to-leaf path with sum = 5.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [], targetSum = 0</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Since the tree is empty, there are no root-to-leaf paths.</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：<em>O</em>(<em>N</em>),其中N是树的节点数</p>
<p>空间复杂度：O(H),其中H是树的高度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetSum == root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) ||</span><br><span class="line">               <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/path-sum/solutions/318487/lu-jing-zong-he-by-leetcode-solution/">广度优先遍历：</a></p>
<p>时间复杂度：<em>O</em>(<em>N</em>)</p>
<p>空间复杂度：O(N)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode *&gt; que_node;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que_val;</span><br><span class="line">        que_node.<span class="built_in">push</span>(root);</span><br><span class="line">        que_val.<span class="built_in">push</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">while</span> (!que_node.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *now = que_node.<span class="built_in">front</span>();</span><br><span class="line">            <span class="type">int</span> temp = que_val.<span class="built_in">front</span>();</span><br><span class="line">            que_node.<span class="built_in">pop</span>();</span><br><span class="line">            que_val.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;left == <span class="literal">nullptr</span> &amp;&amp; now-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp == sum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que_node.<span class="built_in">push</span>(now-&gt;left);</span><br><span class="line">                que_val.<span class="built_in">push</span>(now-&gt;left-&gt;val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que_node.<span class="built_in">push</span>(now-&gt;right);</span><br><span class="line">                que_val.<span class="built_in">push</span>(now-&gt;right-&gt;val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Power of Three</title>
    <url>/2023/02/20/LeetCode/Power%20of%20Three/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/power-of-three/">326.Power of Three</a></p>
<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of three. Otherwise, return <code>false</code></em>.</p>
<p>An integer <code>n</code> is a power of three, if there exists an integer <code>x</code> such that <code>n == 3x</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 27</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 27 = 33</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 0</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no x where 3x = 0.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = -1</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no x where 3x = (-1).</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (n &amp;&amp; n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最大约数法：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Plus One</title>
    <url>/2022/11/09/LeetCode/Plus%20One/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/plus-one/description/description/">66.Plus One</a></p>
<p>You are given a <strong>large integer</strong> represented as an integer array <code>digits</code>, where each <code>digits[i]</code> is the <code>ith</code> digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading <code>0</code>‘s.</p>
<p>Increment the large integer by one and return <em>the resulting array of digits</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: digits = [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br><span class="line">Incrementing by one gives 123 + 1 = 124.</span><br><span class="line">Thus, the result should be [1,2,4].</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: digits = [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br><span class="line">Incrementing by one gives 4321 + 1 = 4322.</span><br><span class="line">Thus, the result should be [4,3,2,2].</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: digits = [9]</span><br><span class="line">Output: [1,0]</span><br><span class="line">Explanation: The array represents the integer 9.</span><br><span class="line">Incrementing by one gives 9 + 1 = 10.</span><br><span class="line">Thus, the result should be [1,0].</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> digits_size = digits.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (digits[digits_size - <span class="number">1</span>] != <span class="number">9</span>) &#123;</span><br><span class="line">        digits[digits_size - <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits_size == <span class="number">1</span>)<span class="keyword">return</span>&#123; <span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">int</span> index = digits_size - <span class="number">2</span>;</span><br><span class="line">        digits[digits_size - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (digits[index] == <span class="number">9</span>) &#123;</span><br><span class="line">            digits[index] = <span class="number">0</span>;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">digits</span><span class="params">(digits_size + <span class="number">1</span>)</span></span>;</span><br><span class="line">                digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (digits_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    digits[digits_size] = <span class="number">0</span>;</span><br><span class="line">                    digits_size--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits[index] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Power of Four</title>
    <url>/2023/02/22/LeetCode/Power%20of%20Four/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/power-of-four/description/">342.Power of Four</a></p>
<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of four. Otherwise, return <code>false</code></em>.</p>
<p>An integer <code>n</code> is a power of four, if there exists an integer <code>x</code> such that <code>n == 4x</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 5</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n &amp;&amp; n % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二进制中1的位置：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; (n &amp; <span class="number">0xaaaaaaaa</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>取模性质：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; n % <span class="number">3</span> == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Power of Two</title>
    <url>/2023/02/07/LeetCode/Power%20of%20Two/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/power-of-two/description/">231.Power of Two</a></p>
<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of two. Otherwise, return <code>false</code></em>.</p>
<p>An integer <code>n</code> is a power of two, if there exists an integer <code>x</code> such that <code>n == 2x</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 20 = 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 16</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 24 = 16</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            num *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>位运算：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; -n) == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>约数法：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> BIG = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; BIG % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Range Sum Query - Immutable</title>
    <url>/2023/02/19/LeetCode/Range%20Sum%20Query%20-%20Immutable/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/range-sum-query-immutable/description/">303.Range Sum Query - Immutable</a></p>
<p>Given an integer array <code>nums</code>, handle multiple queries of the following type:</p>
<ol>
<li>Calculate the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> where <code>left &lt;= right</code>.</li>
</ol>
<p>Implement the <code>NumArray</code> class:</p>
<ul>
<li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>
<li><code>int sumRange(int left, int right)</code> Returns the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> (i.e. <code>nums[left] + nums[left + 1] + ... + nums[right]</code>).</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</span><br><span class="line">[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</span><br><span class="line">Output</span><br><span class="line">[null, 1, -1, -3]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);</span><br><span class="line">numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1</span><br><span class="line">numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1</span><br><span class="line">numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n2)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        arr = nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right) &#123;</span><br><span class="line">            sum += arr[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前缀和：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sums;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        sums.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j + <span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Ransom Note</title>
    <url>/2023/03/09/LeetCode/Ransom%20Note/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/ransom-note/description/">383.Ransom Note</a></p>
<p>Given two strings <code>ransomNote</code> and <code>magazine</code>, return <code>true</code> <em>if</em> <code>ransomNote</code> <em>can be constructed by using the letters from</em> <code>magazine</code> <em>and</em> <code>false</code> <em>otherwise</em>.</p>
<p>Each letter in <code>magazine</code> can only be used once in <code>ransomNote</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)<br>空间复杂度：O(S)，S为字符集大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; c : magazine) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; c : ransomNote) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Remove Duplicates from Sorted Array</title>
    <url>/2022/11/05/LeetCode/Remove%20Duplicates%20from%20Sorted%20Array/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">26.Remove Duplicates from Sorted Array</a></p>
<p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates <a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"><strong>in-place</strong></a> such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>.</p>
<p>return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p>
<p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1,2]</span><br><span class="line">Output: 2, nums = [1,2,_]</span><br><span class="line">Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]</span><br><span class="line">Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (nums_size == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums_size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[right] != nums[left]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left &gt; <span class="number">1</span>) &#123;<span class="comment">//right和left相邻不用复制</span></span><br><span class="line">                nums[left + <span class="number">1</span>] = nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val != arr[index]) &#123;</span><br><span class="line">            arr[++index] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Remove Duplicates from Sorted List</title>
    <url>/2022/11/13/LeetCode/Remove%20Duplicates%20from%20Sorted%20List/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/description/">83.Remove Duplicates from Sorted List</a></p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,1,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,1,2,3,3]</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>双指针</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* node1 = head;</span><br><span class="line">    ListNode* node2 = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (node2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node2-&gt;val == node1-&gt;val) &#123;</span><br><span class="line">            node1-&gt;next = node2-&gt;next;</span><br><span class="line">            node2 = node2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node1 = node1-&gt;next;</span><br><span class="line">            node2 = node2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Remove Element</title>
    <url>/2022/11/06/LeetCode/Remove%20Element/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/remove-element/description/">27.Remove Element</a></p>
<p>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"><strong>in-place</strong></a>. The relative order of the elements may be changed.</p>
<p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the <strong>first part</strong> of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code> should hold the final result. It does not matter what you leave beyond the first <code>k</code> elements.</p>
<p>Return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p>
<p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3,2,2,3], val = 3</span><br><span class="line">Output: 2, nums = [2,2,_,_]</span><br><span class="line">Explanation: Your function should return k = 2, with the first two elements of nums being 2.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">Output: 5, nums = [0,1,4,0,3,_,_,_]</span><br><span class="line">Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.</span><br><span class="line">Note that the five elements can be returned in any order.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator pos = <span class="built_in">find</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), val);</span><br><span class="line">    <span class="keyword">while</span> (pos != nums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        nums.<span class="built_in">erase</span>(pos);</span><br><span class="line">        pos = <span class="built_in">find</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">            nums[left] = nums[right - <span class="number">1</span>];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left++;<span class="comment">//直到right指针指向数据不等于val,left左移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Remove Linked List Elements</title>
    <url>/2023/01/30/LeetCode/Remove%20Linked%20List%20Elements/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203.Remove Linked List Elements</a></p>
<p>Given the <code>head</code> of a linked list and an integer <code>val</code>, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return <em>the new head</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">Output: [1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [], val = 1</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [7,7,7,7], val = 7</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;val == val)head = head-&gt;next;</span><br><span class="line">        ListNode* t = head;</span><br><span class="line">        ListNode* in = head;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;val == val) &#123;</span><br><span class="line">                in-&gt;next = t-&gt;next;</span><br><span class="line">                t = t-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            in = t;</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* temp = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = <span class="built_in">removeElements</span>(head-&gt;next, val);</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Repeated Substring Pattern</title>
    <url>/2023/03/27/LeetCode/Repeated%20Substring%20Pattern/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">459.Repeated Substring Pattern</a></p>
<p>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abab&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: It is the substring &quot;ab&quot; twice.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aba&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abcabcabcabc&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: It is the substring &quot;abc&quot; four times or the substring &quot;abcabc&quot; twice.</span><br></pre></td></tr></table></figure>

<p>枚举法：</p>
<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">bool</span> match = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[j] != s[j - i]) &#123;</span><br><span class="line">                        match = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>字符串匹配：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (s + s).<span class="built_in">find</span>(s, <span class="number">1</span>) != s.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/repeated-substring-pattern/solutions/386481/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/">KMP算法：</a></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string&amp; query, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = query.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fail</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> match = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (match != <span class="number">-1</span> &amp;&amp; pattern[match + <span class="number">1</span>] != query[i]) &#123;</span><br><span class="line">                match = fail[match];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[match + <span class="number">1</span>] == query[i]) &#123;</span><br><span class="line">                ++match;</span><br><span class="line">                <span class="keyword">if</span> (match == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kmp</span>(s + s, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = pattern.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fail</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fail[n - <span class="number">1</span>] != <span class="number">-1</span> &amp;&amp; n % (n - fail[n - <span class="number">1</span>] - <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kmp</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Reverse Bits</title>
    <url>/2023/01/16/LeetCode/Reverse%20Bits/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/reverse-bits/description/">190.Reverse Bits</a></p>
<p>Reverse bits of a given 32 bits unsigned integer.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</li>
<li>In Java, the compiler represents the signed integers using <a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fromtitle=%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81&fromid=5295284">2’s complement notation</a>. Therefore, in <strong>Example 2</strong> above, the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 00000010100101000001111010011100</span><br><span class="line">Output:    964176192 (00111001011110000010100101000000)</span><br><span class="line">Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 11111111111111111111111111111101</span><br><span class="line">Output:   3221225471 (10111111111111111111111111111111)</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.</span><br></pre></td></tr></table></figure>

<p>位操作：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> r ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span> &amp;&amp; n &gt; <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            ans |= (n &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>分治：</p>
<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M1 = <span class="number">0x55555555</span>; <span class="comment">// 01010101010101010101010101010101</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M2 = <span class="number">0x33333333</span>; <span class="comment">// 00110011001100110011001100110011</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M4 = <span class="number">0x0f0f0f0f</span>; <span class="comment">// 00001111000011110000111100001111</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> M8 = <span class="number">0x00ff00ff</span>; <span class="comment">// 00000000111111110000000011111111</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span> &amp; M1 | (n &amp; M1) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        n = n &gt;&gt; <span class="number">2</span> &amp; M2 | (n &amp; M2) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        n = n &gt;&gt; <span class="number">4</span> &amp; M4 | (n &amp; M4) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">        n = n &gt;&gt; <span class="number">8</span> &amp; M8 | (n &amp; M8) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">return</span> n &gt;&gt; <span class="number">16</span> | n &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Reverse Linked List</title>
    <url>/2023/02/01/LeetCode/Reverse%20Linked%20List/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/reverse-linked-list/">206.Reverse Linked List</a></p>
<p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5]</span><br><span class="line">Output: [5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2]</span><br><span class="line">Output: [2,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)<span class="keyword">return</span> head;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">resize</span>(i);</span><br><span class="line">            vec.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ans_head, * node, * end;</span><br><span class="line">        i--;</span><br><span class="line">        ans_head = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ans_head-&gt;val = vec[i];</span><br><span class="line">        end = ans_head;</span><br><span class="line">        <span class="keyword">while</span>(--i) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> ListNode;</span><br><span class="line">            node-&gt;val = vec[i];</span><br><span class="line">            end-&gt;next = node;</span><br><span class="line">            end = node;</span><br><span class="line">        &#125;</span><br><span class="line">        end-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ans_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            ListNode* next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Reverse String</title>
    <url>/2023/02/23/LeetCode/Reverse%20String/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/reverse-string/description/">344.Reverse String</a></p>
<p>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p>
<p>You must do this by modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a> with <code>O(1)</code> extra memory.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n&#x2F;2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s_size = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s_size / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[s_size - i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Reverse Vowels of a String</title>
    <url>/2023/02/24/LeetCode/Reverse%20Vowels%20of%20a%20String/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/reverse-vowels-of-a-string/description/">345.Reverse Vowels of a String</a></p>
<p>Given a string <code>s</code>, reverse only all the vowels in the string and return it.</p>
<p>The vowels are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>, and they can appear in both lower and upper cases, more than once.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;hello&quot;</span><br><span class="line">Output: &quot;holle&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;leetcode&quot;</span><br><span class="line">Output: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(10)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseVowels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set = &#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;U&#x27;</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>; </span><br><span class="line">             left &lt; right; left++, right--) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!set.<span class="built_in">count</span>(s[left])&amp;&amp;(left &lt; right))left++;</span><br><span class="line">            <span class="keyword">while</span>(!set.<span class="built_in">count</span>(s[right])&amp;&amp;(left &lt; right))right--;</span><br><span class="line">            <span class="built_in">swap</span>(s[left], s[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Roman to Integer</title>
    <url>/2022/11/01/LeetCode/Roman%20to%20Integer/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/roman-to-integer/description/">13.Roman to Integer</a></p>
<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>


<p>For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<p><strong>I can be placed before V (5) and X (10) to make 4 and 9.</strong><br><strong>X can be placed before L (50) and C (100) to make 40 and 90.</strong><br><strong>C can be placed before D (500) and M (1000) to make 400 and 900.</strong><br>Given a roman numeral, convert it to an integer.</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;III&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: III = 3.</span><br></pre></td></tr></table></figure>


<p>Example 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure>


<p>Example 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum_int = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> is_double = <span class="literal">true</span>;<span class="comment">//两个字符转换</span></span><br><span class="line">    <span class="keyword">while</span> (is_double) &#123;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;IV&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">4</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;IX&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">9</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">40</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">90</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;CD&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">400</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;CM&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">900</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        is_double = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (s != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">5</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;L&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">50</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">500</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;M&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">1000</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;I&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">1</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">10</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            sum_int += <span class="number">100</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum_int;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; romanToInt_table = &#123;</span><br><span class="line">        &#123; <span class="string">&#x27;I&#x27;</span>, <span class="number">1</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;V&#x27;</span>, <span class="number">5</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;X&#x27;</span>, <span class="number">10</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;L&#x27;</span>, <span class="number">50</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;C&#x27;</span>, <span class="number">100</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;D&#x27;</span>, <span class="number">500</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> sum_int = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> s_size = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s_size; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> value = romanToInt_table[s[i]];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; s_size - <span class="number">1</span> &amp;&amp; value &lt; romanToInt_table[s[i + <span class="number">1</span>]]) &#123;</span><br><span class="line">            sum_int -= value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sum_int += value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum_int;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Same Tree</title>
    <url>/2022/11/16/LeetCode/Same%20Tree/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/same-tree/description/">100.Same Tree</a></p>
<p>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: p = [1,2,3], q = [1,2,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: p = [1,2], q = [1,null,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<p><img src="/assets/ex3.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: p = [1,2,1], q = [1,1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p> 深度优先搜索：</p>
<p>时间复杂度：O(min⁡(m,n))</p>
<p>空间复杂度：O(min⁡(m,n))</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>广度优先搜索：</p>
<p>时间复杂度：O(min⁡(m,n))</p>
<p>空间复杂度：O(min⁡(m,n))</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue &lt;TreeNode*&gt; queue1, queue2;</span><br><span class="line">    queue1.<span class="built_in">push</span>(p);</span><br><span class="line">    queue2.<span class="built_in">push</span>(q);</span><br><span class="line">    <span class="keyword">while</span> (!queue1.<span class="built_in">empty</span>() &amp;&amp; !queue2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node1 = queue1.<span class="built_in">front</span>();</span><br><span class="line">        queue1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">auto</span> node2 = queue2.<span class="built_in">front</span>();</span><br><span class="line">        queue2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node1-&gt;val != node2-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> left1 = node1-&gt;left, right1 = node1-&gt;right, left2 = node2-&gt;left, right2 = node2-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> ((left1 == <span class="literal">nullptr</span>) ^ (left2 == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((right1 == <span class="literal">nullptr</span>) ^ (right2 == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            queue1.<span class="built_in">push</span>(left1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            queue1.<span class="built_in">push</span>(right1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            queue2.<span class="built_in">push</span>(left2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            queue2.<span class="built_in">push</span>(right2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue1.<span class="built_in">empty</span>() &amp;&amp; queue2.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Search Insert Position</title>
    <url>/2022/11/07/LeetCode/Search%20Insert%20Position/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/search-insert-position/description/">35.Search Insert Position</a></p>
<p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,3,5,6], target = 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,3,5,6], target = 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,3,5,6], target = 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度O(logn)；</p>
<p>空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, ans = n;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Single Number</title>
    <url>/2023/01/06/LeetCode/Single%20Number/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/single-number/description/">136.Single Number</a></p>
<p>Given a <strong>non-empty</strong> array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.</p>
<p>You must implement a solution with a linear runtime complexity and use only constant extra space.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = *it;</span><br><span class="line">            it++;</span><br><span class="line">            <span class="keyword">if</span> (it == nums.<span class="built_in">end</span>()||temp != *it)<span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>位运算：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e: nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Sqrt(x)</title>
    <url>/2022/11/11/LeetCode/Sqrt(x)/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/sqrtx/description/">69.Sqrt(x)</a></p>
<p>Given a non-negative integer <code>x</code>, return <em>the square root of</em> <code>x</code> <em>rounded down to the nearest integer</em>. The returned integer should be <strong>non-negative</strong> as well.</p>
<p>You <strong>must not use</strong> any built-in exponent function or operator.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 4 is 2, so we return 2.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i*i &lt;= x)i++;</span><br><span class="line">        <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>二分查找：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = x, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)mid * mid &lt;= x) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/sqrtx/solutions/238553/x-de-ping-fang-gen-by-leetcode-solution/">牛顿迭代：</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> C = x, x0 = x;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">double</span> xi = <span class="number">0.5</span> * (x0 + C / x0);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x0 - xi) &lt; <span class="number">1e-7</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x0 = xi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(x0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Symmetric Tree</title>
    <url>/2022/11/17/LeetCode/Symmetric%20Tree/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/symmetric-tree/description/">101.Symmetric Tree</a></p>
<p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,2,null,3,null,3]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode *u, TreeNode *v)</span> </span>&#123;</span><br><span class="line">    queue &lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(u); q.<span class="built_in">push</span>(v);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        v = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!u &amp;&amp; !v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((!u || !v) || (u-&gt;val != v-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">push</span>(u-&gt;left); </span><br><span class="line">        q.<span class="built_in">push</span>(v-&gt;right);</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">push</span>(u-&gt;right); </span><br><span class="line">        q.<span class="built_in">push</span>(v-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归法：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">check</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">check</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Sum of Left Leaves</title>
    <url>/2023/03/15/LeetCode/Sum%20of%20Left%20Leaves/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/sum-of-left-leaves/description/">404.Sum of Left Leaves</a></p>
<p>Given the <code>root</code> of a binary tree, return <em>the sum of all left leaves.</em></p>
<p>A <strong>leaf</strong> is a node with no children. A <strong>left leaf</strong> is a leaf that is the left child of another node.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: 24</span><br><span class="line">Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p>深度优先遍历：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isLeafNode</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !node-&gt;left &amp;&amp; !node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            ans += <span class="built_in">isLeafNode</span>(node-&gt;left) ? node-&gt;left-&gt;val : <span class="built_in">dfs</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right &amp;&amp; !<span class="built_in">isLeafNode</span>(node-&gt;right)) &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? <span class="built_in">dfs</span>(root) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>广度优先遍历：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isLeafNode</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !node-&gt;left &amp;&amp; !node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isLeafNode</span>(node-&gt;left)) &#123;</span><br><span class="line">                    ans += node-&gt;left-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isLeafNode</span>(node-&gt;right)) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Summary Ranges</title>
    <url>/2023/02/06/LeetCode/Summary%20Ranges/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/summary-ranges/description/">228.Summary Ranges</a></p>
<p>You are given a <strong>sorted unique</strong> integer array <code>nums</code>.</p>
<p>A <strong>range</strong> <code>[a,b]</code> is the set of all integers from <code>a</code> to <code>b</code> (inclusive).</p>
<p>Return <em>the <strong>smallest sorted</strong> list of ranges that <strong>cover all the numbers in the array exactly</strong></em>. That is, each element of <code>nums</code> is covered by exactly one of the ranges, and there is no integer <code>x</code> such that <code>x</code> is in one of the ranges but not in <code>nums</code>.</p>
<p>Each range <code>[a,b]</code> in the list should be output as:</p>
<ul>
<li><code>&quot;a-&gt;b&quot;</code> if <code>a != b</code></li>
<li><code>&quot;a&quot;</code> if <code>a == b</code></li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,1,2,4,5,7]</span><br><span class="line">Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">Explanation: The ranges are:</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,2,3,4,6,8,9]</span><br><span class="line">Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">Explanation: The ranges are:</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(nums_size == <span class="number">0</span>)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span>(nums_size == <span class="number">1</span>)<span class="keyword">return</span> &#123;<span class="built_in">to_string</span>(nums[<span class="number">0</span>])&#125;;</span><br><span class="line">        vector&lt;string&gt; ans_vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums_size<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i + <span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">                ans_vec.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[i]));</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> temp = nums[i];</span><br><span class="line">                <span class="keyword">while</span> (i &lt; nums_size - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>] - <span class="number">1</span>)i++;</span><br><span class="line">                ans_vec.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(temp) + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(nums[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[nums_size<span class="number">-1</span>]!=nums[nums_size<span class="number">-2</span>]+<span class="number">1</span>)</span><br><span class="line">            ans_vec.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[nums_size<span class="number">-1</span>]));</span><br><span class="line">        <span class="keyword">return</span> ans_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ret;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> low = i;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">            string temp = <span class="built_in">to_string</span>(nums[low]);</span><br><span class="line">            <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">                temp.<span class="built_in">append</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                temp.<span class="built_in">append</span>(<span class="built_in">to_string</span>(nums[high]));</span><br><span class="line">            &#125;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(<span class="built_in">move</span>(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Third Maximum Number</title>
    <url>/2023/03/19/LeetCode/Third%20Maximum%20Number/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/third-maximum-number/description/">414.Third Maximum Number</a></p>
<p>Given an integer array <code>nums</code>, return <em>the <strong>third distinct maximum</strong> number in this array. If the third maximum does not exist, return the <strong>maximum</strong> number</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3,2,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">The first distinct maximum is 3.</span><br><span class="line">The second distinct maximum is 2.</span><br><span class="line">The third distinct maximum is 1.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The first distinct maximum is 2.</span><br><span class="line">The second distinct maximum is 1.</span><br><span class="line">The third distinct maximum does not exist, so the maximum (2) is returned instead.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,2,3,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">The first distinct maximum is 3.</span><br><span class="line">The second distinct maximum is 2 (both 2&#x27;s are counted together since they have the same value).</span><br><span class="line">The third distinct maximum is 1.</span><br></pre></td></tr></table></figure>

<p>排序：</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), greater&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, diff = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i - <span class="number">1</span>] &amp;&amp; ++diff == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有序集合：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>() == <span class="number">3</span> ? *s.<span class="built_in">begin</span>() : *s.<span class="built_in">rbegin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一次遍历：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> a = LONG_MIN, b = LONG_MIN, c = LONG_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; a) &#123;</span><br><span class="line">                c = b;</span><br><span class="line">                b = a;</span><br><span class="line">                a = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; num &amp;&amp; num &gt; b) &#123;</span><br><span class="line">                c = b;</span><br><span class="line">                b = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &gt; num &amp;&amp; num &gt; c) &#123;</span><br><span class="line">                c = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c == LONG_MIN ? a : c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *a = <span class="literal">nullptr</span>, *b = <span class="literal">nullptr</span>, *c = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || num &gt; *a) &#123;</span><br><span class="line">                c = b;</span><br><span class="line">                b = a;</span><br><span class="line">                a = &amp;num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*a &gt; num &amp;&amp; (b == <span class="literal">nullptr</span> || num &gt; *b)) &#123;</span><br><span class="line">                c = b;</span><br><span class="line">                b = &amp;num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b != <span class="literal">nullptr</span> &amp;&amp; *b &gt; num &amp;&amp; (c == <span class="literal">nullptr</span> || num &gt; *c)) &#123;</span><br><span class="line">                c = &amp;num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c == <span class="literal">nullptr</span> ? *a : *c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Ugly Number</title>
    <url>/2023/02/13/LeetCode/Ugly%20Number/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/ugly-number/description/">263.Ugly Number</a></p>
<p>An <strong>ugly number</strong> is a positive integer whose prime factors are limited to <code>2</code>, <code>3</code>, and <code>5</code>.</p>
<p>Given an integer <code>n</code>, return <code>true</code> <em>if</em> <code>n</code> <em>is an <strong>ugly number</strong></em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 6</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 6 = 2 × 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 14</span><br><span class="line">Output: false</span><br><span class="line">Explanation: 14 is not ugly since it includes the prime factor 7.</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUgly</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)n /= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">3</span> == <span class="number">0</span>)n /= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">5</span> == <span class="number">0</span>)n /= <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUgly</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; factors = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> factor : factors) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n % factor == <span class="number">0</span>) &#123;</span><br><span class="line">                n /= factor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Valid Anagram</title>
    <url>/2023/02/10/LeetCode/Valid%20Anagram/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/valid-anagram/">242.Valid Anagram</a></p>
<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code> <em>otherwise</em>.</p>
<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>排序法：</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(s)，s为字符集大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() != t.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">table</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch: s) &#123;</span><br><span class="line">            table[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch: t) &#123;</span><br><span class="line">            table[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (table[ch - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Valid Palindrome</title>
    <url>/2022/12/30/LeetCode/Valid%20Palindrome/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/valid-palindrome/description/">125.Valid Palindrome</a><br>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p>
<p>Given a string <code>s</code>, return <code>true</code> <em>if it is a <strong>palindrome</strong>, or</em> <code>false</code> <em>otherwise</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;amanaplanacanalpanama&quot; is a palindrome.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;race a car&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;raceacar&quot; is not a palindrome.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot; &quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: s is an empty string &quot;&quot; after removing non-alphanumeric characters.</span><br><span class="line">Since an empty string reads the same forward and backward, it is a palindrome.</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (string::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>();) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*it &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; *it &lt;= <span class="string">&#x27;Z&#x27;</span>)*it += <span class="number">32</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((*it &lt; <span class="string">&#x27;a&#x27;</span> || *it&gt;<span class="string">&#x27;z&#x27;</span>)  &amp;&amp; (*it &lt; <span class="string">&#x27;0&#x27;</span> || *it&gt;<span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">                s.<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        string backup = s;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> backup == s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string sgood;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalnum</span>(ch)) &#123;</span><br><span class="line">                sgood += <span class="built_in">tolower</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">sgood_rev</span><span class="params">(sgood.rbegin(), sgood.rend())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> sgood == sgood_rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[left])) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[right])) &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[left]) != <span class="built_in">tolower</span>(s[right])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Valid Parentheses</title>
    <url>/2022/11/03/LeetCode/Valid%20Parentheses/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/valid-parentheses/description/">20.Valid Parentheses</a></p>
<p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
<li>Every close bracket has a corresponding open bracket of the same type.</li>
</ol>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>个人解答：</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s_size = s.<span class="built_in">size</span>();</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; stack_char;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c:s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>)stack_char.<span class="built_in">push</span>(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!stack_char.<span class="built_in">empty</span>() &amp;&amp; c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stack_char.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>)stack_char.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!stack_char.<span class="built_in">empty</span>() &amp;&amp; c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; stack_char.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>)stack_char.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!stack_char.<span class="built_in">empty</span>() &amp;&amp; c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stack_char.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>)stack_char.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack_char.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; m&#123;&#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;, &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;, &#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: s) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || m[c] != st.<span class="built_in">top</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    st.<span class="built_in">push</span>(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Valid Perfect Square</title>
    <url>/2023/02/27/LeetCode/Valid%20Perfect%20Square/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/valid-perfect-square/description/">367.Valid Perfect Square</a></p>
<p>Given a positive integer <code>num</code>, return <code>true</code> <em>if</em> <code>num</code> <em>is a perfect square or</em> <code>false</code> <em>otherwise</em>.</p>
<p>A <strong>perfect square</strong> is an integer that is the square of an integer. In other words, it is the product of some integer with itself.</p>
<p>You must not use any built-in library function, such as <code>sqrt</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num = 16</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We return true because 4 * 4 = 16 and 4 is an integer.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num = 14</span><br><span class="line">Output: false</span><br><span class="line">Explanation: We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer.</span><br></pre></td></tr></table></figure>

<p>暴力法：</p>
<p>时间复杂度：O(√n)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n*n&lt;=num) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n*n == num)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内置函数法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = (<span class="type">int</span>) <span class="built_in">sqrt</span>(num);</span><br><span class="line">        <span class="keyword">return</span> x * x == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二分法：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = num;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="type">long</span> square = (<span class="type">long</span>) mid * mid;</span><br><span class="line">            <span class="keyword">if</span> (square &lt; num) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (square &gt; num) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>牛顿迭代法：</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> x0 = num;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">double</span> x1 = (x0 + num / x0) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (x0 - x1 &lt; <span class="number">1e-6</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x0 = x1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = (<span class="type">int</span>) x0;</span><br><span class="line">        <span class="keyword">return</span> x * x == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Word Pattern</title>
    <url>/2023/02/17/LeetCode/Word%20Pattern/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/word-pattern/description/">290.Word Pattern</a></p>
<p>Given a <code>pattern</code> and a string <code>s</code>, find if <code>s</code> follows the same pattern.</p>
<p>Here <strong>follow</strong> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <strong>non-empty</strong> word in <code>s</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: pattern = &quot;abba&quot;, s = &quot;dog cat cat fish&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: pattern = &quot;aaaa&quot;, s = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>哈希表：</p>
<p>时间复杂度：O(n+m)，<code>n</code>为<code>pattern</code>长度，<code>m</code>为<code>s</code>长度</p>
<p>空间复杂度：O(n+m)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordPattern</span><span class="params">(string pattern, string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s_size = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, string&gt;pattern_s;</span><br><span class="line">        unordered_map&lt;string, <span class="type">char</span>&gt;s_pattern;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : pattern) &#123;</span><br><span class="line">            string str;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; s_size;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">                str += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(pattern_s.<span class="built_in">count</span>(ch)&amp;&amp;pattern_s[ch]!=str||</span><br><span class="line">               (s_pattern.<span class="built_in">count</span>(str))&amp;&amp;s_pattern[str]!=ch)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            pattern_s[ch] = str;</span><br><span class="line">            s_pattern[str] = ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == s_size+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第一章 计算机系统基础</title>
    <url>/2024/08/12/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h1><h2 id="数的转换"><a href="#数的转换" class="headerlink" title="数的转换"></a>数的转换</h2><ul>
<li><p>数制及其特征</p>
<table>
<thead>
<tr>
<th align="center">数制</th>
<th align="center">基本数码</th>
<th align="center">基数</th>
<th align="center">位权</th>
<th align="center">形式表示符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">十进制</td>
<td align="center">0,1,2,3…9</td>
<td align="center">r&#x3D;10</td>
<td align="center">10<sup>n</sup></td>
<td align="center">D</td>
</tr>
<tr>
<td align="center">二进制</td>
<td align="center">0,1</td>
<td align="center">r&#x3D;2</td>
<td align="center">2<sup>n</sup></td>
<td align="center">B</td>
</tr>
<tr>
<td align="center">八进制</td>
<td align="center">0,1,2,3,4…7</td>
<td align="center">r&#x3D;8</td>
<td align="center">8<sup>n</sup></td>
<td align="center">O</td>
</tr>
<tr>
<td align="center">十六进制</td>
<td align="center">0-9,A,B,C,D,E,F</td>
<td align="center">r&#x3D;16</td>
<td align="center">16<sup>n</sup></td>
<td align="center">H</td>
</tr>
</tbody></table>
</li>
<li><p>R进制-&gt;十进制</p>
<ul>
<li>使用<strong>位权展开法</strong></li>
<li>将R进制的每一位数值用R<sup>k</sup>形式表示</li>
<li>R为底数&#x2F;基数</li>
<li>k为指数</li>
</ul>
</li>
<li><p>十进制-&gt;R进制</p>
<ul>
<li>使用<strong>短除法</strong></li>
</ul>
</li>
<li><p>二进制&lt;–&gt;八进制</p>
</li>
<li><p>二进制&lt;–&gt;十六进制</p>
</li>
</ul>
<h2 id="数据的存储单位"><a href="#数据的存储单位" class="headerlink" title="数据的存储单位"></a>数据的存储单位</h2><ul>
<li>在计算机中，数据的最小存储单位为BIT，1比特为1个二进制位。字节（Byte），1个字节为8个二进制位</li>
<li>二进制有两个数：0,1</li>
<li>位（Bit）</li>
<li>字节（Byte）<ul>
<li>1B&#x3D;8bit</li>
<li>1KB&#x3D;1024B</li>
<li>1MB&#x3D;1024KB</li>
<li>1GB&#x3D;1024MB</li>
</ul>
</li>
<li>除字节Byte外，还有千字节（KB），兆字节（MB），吉字节（GB），太字节（TB）</li>
</ul>
<h2 id="二进制的运算"><a href="#二进制的运算" class="headerlink" title="二进制的运算"></a>二进制的运算</h2><ul>
<li>二进制的算术运算：加、减、乘、除</li>
<li>二进制的逻辑运算：与、或、非、异或</li>
</ul>
<h1 id="数据的表示"><a href="#数据的表示" class="headerlink" title="数据的表示"></a>数据的表示</h1><h2 id="数的表示"><a href="#数的表示" class="headerlink" title="数的表示"></a>数的表示</h2><ul>
<li><p>机器数和真值：两者之间的区别是真值的符号在机器数中用二进制符号位表示</p>
</li>
<li><p>码制</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">数值+1</th>
<th align="center">数值-1</th>
<th align="center">1+（-1）</th>
<th align="center">整数数值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">原码</td>
<td align="center">0000 0001</td>
<td align="center">1000 0001</td>
<td align="center">1000 0010</td>
<td align="center">-（2<sup>n-1</sup>-1）~2<sup>n-1</sup>-1</td>
</tr>
<tr>
<td align="center">反码</td>
<td align="center">0000 0001</td>
<td align="center">1111 1110</td>
<td align="center">1111 1111</td>
<td align="center">-（2<sup>n-1</sup>-1）~2<sup>n-1</sup>-1</td>
</tr>
<tr>
<td align="center">补码</td>
<td align="center">0000 00001</td>
<td align="center">1111 1111</td>
<td align="center">0000 0000</td>
<td align="center">-2<sup>n-1</sup>~2<sup>n-1</sup>-1</td>
</tr>
<tr>
<td align="center">移码</td>
<td align="center">1000 0001</td>
<td align="center">0111 1111</td>
<td align="center">1000 0000</td>
<td align="center">-2<sup>n-1</sup>~2<sup>n-1</sup>-1</td>
</tr>
</tbody></table>
<ul>
<li>原码：第一位为符号位，其余组成真值</li>
<li>反码：正数与原码相同；负数除第一位外其余数值位按位取反</li>
<li>补码：正数与原码相同；负数在反码基础上加一（常用于加减法运算，部分计算机数的表示、存储）</li>
<li>移码：在补码基础上数值不变，符号位取反（常用于浮点数的阶码）</li>
</ul>
</li>
</ul>
<h2 id="定点数和浮点数"><a href="#定点数和浮点数" class="headerlink" title="定点数和浮点数"></a>定点数和浮点数</h2><ul>
<li>定点数：小数点的位置固定不变的数，小数点不需要占用一位二进制<ul>
<li>定点整数：小数点固定在最右边</li>
<li>定点小数：小数点固定在某一位</li>
</ul>
</li>
<li>浮点数：N&#x3D;R<sup>e</sup>*M，其中M称为尾数，e是指数（阶码，用移码表示），R为基数（阶码的底）<ul>
<li>阶符</li>
<li>阶码：决定数值表示的范围</li>
<li>数符</li>
<li>尾数：决定数值表示的精度</li>
<li>流程：对阶-&gt;尾数计算-&gt;结果格式化</li>
</ul>
</li>
</ul>
<h1 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h1><h2 id="计算机的结构"><a href="#计算机的结构" class="headerlink" title="计算机的结构"></a>计算机的结构</h2><ul>
<li><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240812173413.png" alt="image-20240812173410572"></li>
<li>运算器<ul>
<li>算术逻辑单元ALU：数据的算术运算和逻辑运算</li>
<li>累加寄存器AC：通用寄存器，为ALU提供一个工作区，用来暂时保存数据</li>
<li>数据缓冲寄存器DR：写内存时，暂存指令或数据</li>
<li>状态条件寄存器PSW：存状态标志与控制标志（<strong>争议</strong>：也有将其归为控制的）</li>
</ul>
</li>
<li>控制器<ul>
<li>程序计数器PC：存储下一条要执行指令的地址（<strong>地址</strong>不同于指令组成中的<strong>地址码</strong>）</li>
<li>指令寄存器IR：存储即将要执行的指令</li>
<li>指令译码器ID：对指令进行分析解释</li>
<li>时序部件：提供时序控制信号指令中的操作码字段</li>
</ul>
</li>
</ul>
<h2 id="计算机基本概念"><a href="#计算机基本概念" class="headerlink" title="计算机基本概念"></a>计算机基本概念</h2><ul>
<li>CPU的性能指标：主频、字长、CPU缓存、核心数量</li>
<li>总线的分类：数据总线、控制总线、地址总线</li>
<li>总线的性能指标：带宽、位宽、工作频率</li>
<li>BIOS&#x2F;CMOS</li>
<li>系统性能评测方法：时钟频率、指令执行、等效指令速度法、数据处理速率（PDR）、核心程序法、基准测试程序</li>
</ul>
<h2 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h2><ul>
<li>一条总线同一时刻仅允许一个设备发送，但允许多个设备接收</li>
<li>总线的分类<ul>
<li>数据总线：在CPU与RAM之间来回传送需要处理或是需要存储的数据</li>
<li>地址总线：用来指定在RAM之中存储的数据的地址</li>
<li>控制总线：将微处理器控制单元的信号传送到周边设备</li>
</ul>
</li>
<li>总线的性能指标：带宽、位宽、工作频率（带宽&#x3D;位宽*工作频率）</li>
</ul>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ul>
<li>一条指令就是机器语言的一个语句，是一组有意义的二进制代码</li>
<li>组成<ul>
<li>操作码字段OP：指出了计算机要执行什么性质的操作</li>
<li>地址码字段A：包含各操作数的地址及操作结果的存放地址等</li>
</ul>
</li>
</ul>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><ul>
<li>立即寻址方式：操作数直接在指令中，速度快，灵活性差</li>
<li>直接寻址方式：指令中存放的是操作数的地址</li>
<li>间接寻址方式：指令中存放了一个地址，这个地址对应的内容是操作数的地址</li>
<li>寄存器寻址方式：寄存器存放操作数</li>
<li>寄存器间接寻址方式：寄存器内存放的是操作数的地址</li>
</ul>
<h1 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h1><ul>
<li>流水线：多条指令重叠进行操作的一种准并行处理实现技术</li>
<li>流水线周期：执行时间最长的一段</li>
<li>流水线计算公式<ul>
<li>1条指令执行时间+（指令条数-1）*流线线周期<ul>
<li>理论公式：(t<sub>1</sub>+t<sub>2</sub>+…+t<sub>k</sub>)+(n-1)*Δt</li>
<li>实践公式：k * Δt + (n-1) * Δt</li>
</ul>
</li>
</ul>
</li>
<li>流水线的吞吐率（TP）计算的最基本的公式为：TP&#x3D;n&#x2F;T<sub>k</sub>（T<sub>k</sub>表示总共花费时间）</li>
<li>流水线的最大吞吐率：流水线周期的倒数</li>
</ul>
<h1 id="多级存储器结构"><a href="#多级存储器结构" class="headerlink" title="多级存储器结构"></a>多级存储器结构</h1><h2 id="金字塔形层次结构"><a href="#金字塔形层次结构" class="headerlink" title="金字塔形层次结构"></a>金字塔形层次结构</h2><ul>
<li>存储器被组织成金字塔形的层次结构，自上而下组成6个层次结构，依次变得更慢、访问频率更低、容量更大、每字节的造价更便宜<ul>
<li>S0：寄存器。CPU寄存器保存来自cache的字</li>
<li>S1：芯片内的高速缓存（cache）。芯片内的cache保存取自芯片外cache的cache行</li>
<li>S2：芯片外的高速缓存（SRAM，DRAM，DDRAM）。芯片外的cache保存取自主存储器上的cache行</li>
<li>S3：主存储器（Flash，PROM，EPROM，E2PROM）。主存储器保存取自外部存储器上的文件</li>
<li>S4：外部存储器（磁盘，光盘，CF卡，SD卡）外部存储器保存远程二级存储器上的文件</li>
<li>S5：远程二级存储器（分布式文件系统，Web服务器）</li>
</ul>
</li>
</ul>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><ul>
<li><p>功能：提高CPU数据输入输出的速率，突破所谓的“冯诺依曼瓶颈”</p>
</li>
<li><p>速度：在计算机的存储系统体系中，Cache是访问速度较快的层次</p>
</li>
<li><p>原理：使用Cache改善系统性能的依据是程序的局部性原理</p>
</li>
<li><p>组成：Cache由两部分组成：控制部分和Cache存储器部分</p>
</li>
<li><p>平均系统周期时间（以读操作为例：使用“Cache+主存储器”）t<sub>3</sub>&#x3D;hxt<sub>1</sub>+(1-h)xt<sub>2</sub></p>
<ul>
<li>h代表对Cache的访问命中率</li>
<li>t<sub>1</sub>表示Cache的周期时间</li>
<li>t<sub>2</sub>表示主存储器周期时间</li>
<li>t<sub>3</sub>表示系统的平均周期</li>
<li>(1-h)又称为失效率（未命中率）</li>
</ul>
</li>
<li><p>地址映像</p>
<ul>
<li>通常由SRAM（Static Random Access Memory，静态存储器）组成，其访问速度远高于主存，接近CPU</li>
<li>其功能是提高CPU数据输入输出的速率。其理论依据是程序的局部性原理。实现基础是将主存和Cache划分成大小相同的块&#x2F;页</li>
<li>装入缓存时将主存块与Cache块的映射关系存入相联存储表（硬件实现）中</li>
<li>CPU通过主存地址访问时先访问Cache（命中可提升速度，所以其关键性能指标是命中率），依据主存地址关联相联存储表转换为Cache地址。如果在Cache没有，才需要访问主存（Cache页置换，置换算法会影响命中率）</li>
</ul>
</li>
<li><p>直接映像和变换</p>
<ul>
<li>主存储器中一块只能映像到cache的一个特定块中</li>
<li>主存和缓存分为相同大小的数据块</li>
<li>主存空间按缓存容量分为区，每一区的块数与缓存的总块数相等</li>
<li>主存中某区的一块存入缓存时只能存入缓存中块号相同的位置</li>
<li>特点：<ul>
<li>地址变换电路简单，访问速度快</li>
<li>空间利用率低，冲突概率高</li>
<li>对页面置换算法依赖度高，且Cache空间利用率较低，命中率较低</li>
</ul>
</li>
</ul>
</li>
<li><p>全相联地址映像和变换</p>
<ul>
<li>主存中任意一块可以映像到Cache中的任意一块的位置上</li>
<li>主存和缓存分成相同大小的数据块</li>
<li>主存的某一数据块可以装入缓存的任意一块空间中</li>
<li>特点：<ul>
<li>空间利用率高</li>
<li>冲突概率低</li>
<li>实现复杂，速度慢，适合小容量cache</li>
</ul>
</li>
</ul>
</li>
<li><p>组相联地址映像和变换</p>
<ul>
<li>主存和cache按同样大小分块</li>
<li>cache分为若干组，如两块一组，主存按cache组数分区</li>
<li>每个组采用<strong>直接映射方式</strong></li>
<li>组内的块则采用<strong>全相连映像方式</strong></li>
<li>特点：<ul>
<li>是以上两种方式的折衷</li>
<li>实现难度和造价要比直接映像方式高</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h1><ul>
<li>直接程序控制：无条件传送方式、程序查询方式</li>
<li>中断方式</li>
<li>直接存储器存取方式（DMA）：在传送数据块的过程中不需要CPU干涉</li>
<li>输入输出处理机（IOP）</li>
</ul>
<h1 id="可靠性和校验码"><a href="#可靠性和校验码" class="headerlink" title="可靠性和校验码"></a>可靠性和校验码</h1><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><ul>
<li>串联系统R&#x3D;R<sub>1</sub>xR<sub>2</sub>x…xR<sub>n</sub>，R为可靠度，R<sub>1</sub>~R<sub>n</sub>每个串联部分可靠度</li>
<li>并联系统R&#x3D;1-(1-R<sub>1</sub>)x(1-R<sub>2</sub>)x…x(1-R<sub>n</sub>)，（1-R）又称为失效率</li>
<li>混合系统为串联和并联的叠加</li>
</ul>
<h2 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h2><ul>
<li><p>码距：一个编码系统的码距就是整个编码系统中任意（所有）两个码字（合法编码）的最小距离</p>
<ul>
<li>举例：要对A，B两个字母进行编码<ul>
<li>若用1位长度的二进制编码，若A&#x3D;1，B&#x3D;0。这样A，B之间的最小码距为1</li>
<li>若用1位长度的二进制编码，若A&#x3D;11，B&#x3D;00。这样A，B之间的最小码距为2</li>
<li>若用1位长度的二进制编码，若A&#x3D;111，B&#x3D;000。这样A，B之间的最小码距为3</li>
</ul>
</li>
</ul>
</li>
<li><p>奇偶校验码：</p>
<ul>
<li>通过在编码中增加一位校验位来使编码中的1的个数为奇数（奇校验）或者为偶数（偶校验），从而使码距变为2</li>
<li>仅可检错，可检测1（奇数）位错</li>
</ul>
</li>
<li><p>CRC（循环冗余码）：</p>
<ul>
<li><p>利用生成多项式为K个数据位产生r个校验位来进行编码，其编码长度为k+r</p>
</li>
<li><p>三者中<strong>唯一</strong>用到模2运算</p>
</li>
<li><p>仅可检错，可检测多位错</p>
</li>
</ul>
</li>
<li><p>海明码：</p>
<ul>
<li>在数据位之间插入K个校验位，通过扩大码距来实现检查和纠错</li>
<li>设数据位是n位，校验位是k位，则n和k必须满足 2<sup>k</sup>-1&gt;&#x3D;n+k</li>
<li>可检错，且可纠1位错</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>第三章 操作系统知识</title>
    <url>/2024/10/24/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h1><ul>
<li>通过资源管理（软硬件资源管理），提高计算机系统的效率改善人机界面，向用户提供友好的工作环境。</li>
</ul>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><ul>
<li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。它由程序块、进程控制块（PCB）和数据块三部分组成。</li>
<li>进程与程序的区别<ul>
<li>进程是程序的一次执行过程，没有程序就没有进程</li>
<li>程序是完成某个特定功能的一系列程序语句的集合，只要不被破坏，它就永远存在</li>
<li>程序是一个静态的概念，而进程是一个动态的概念，它由创建而产生，完成任务后因撤销而消亡；进程是系统进行资源分配和调度的独立单位，而程序不是</li>
</ul>
</li>
</ul>
<h2 id="进程状态：三态模型"><a href="#进程状态：三态模型" class="headerlink" title="进程状态：三态模型"></a>进程状态：三态模型</h2><ul>
<li>运行态：占有处理器正在运行</li>
<li>就绪态：指具备运行条件，等待系统分配处理器以便运行</li>
<li>等待态：又称为阻塞态或睡眠态，指不具备运行条件，正在等待某个事件的完成<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240902090949.png" alt="三态模型"></li>
<li>运行态–等待态：等待使用资源，如等待外设传输，等待人工干预</li>
<li>等待态–就绪态：资源得到满足，如外设传输结束，人工干预完成</li>
<li>运行态–就绪态：运行时间片到，出现有更高优先权进程</li>
<li>就绪态–运行态：CPU空闲时选择一个就绪进程</li>
</ul>
<h2 id="进程状态：五态模型"><a href="#进程状态：五态模型" class="headerlink" title="进程状态：五态模型"></a>进程状态：五态模型</h2><ul>
<li>挂起：将进程调出内存，保存到外存队列中，并释放资源</li>
<li>激活：恢复挂起进程，重新调入内存<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240902091000.png" alt="五态模型"></li>
<li>目的：释放进程占用的资源以缓解资源不足</li>
<li>原因：终端用户的请求，父进程的请求、OS的需要（如负荷调节、对换等）</li>
</ul>
<h2 id="前驱图"><a href="#前驱图" class="headerlink" title="前驱图"></a>前驱图</h2><ul>
<li>出度：多少箭头出</li>
<li>入度：多少箭头入</li>
</ul>
<h2 id="进程的同步和互斥"><a href="#进程的同步和互斥" class="headerlink" title="进程的同步和互斥"></a>进程的同步和互斥</h2><ul>
<li>互斥：间接制约</li>
<li>同步：直接制约</li>
</ul>
<h2 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h2><ul>
<li>临界资源：诸进程间需要互斥方式对其进行共享的资源，如打印机、磁带机等</li>
<li>临界区：每个进程中访问临界资源的那段代码称为临界区</li>
<li>信号量：是一种特殊的变量</li>
<li>P操作：申请资源，阻塞进程</li>
<li>V操作：释放资源，唤醒进程<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240902091015.png" alt="PV操作"></li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul>
<li>进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一个不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。</li>
<li>死锁的预防：打破四大条件<ul>
<li>互斥</li>
<li>保持和等待</li>
<li>不剥夺</li>
<li>环路等待</li>
</ul>
</li>
<li>死锁的避免<ul>
<li>有序资源分配法</li>
<li><strong>银行家算法</strong></li>
</ul>
</li>
<li>银行家算法：分配资源的原则<ul>
<li>当一个进程对资源的最大需求量不超过系统中的资源数时可以接纳该进程</li>
<li>进程可以分期请求资源，但请求的总数不能超过最大需求量</li>
<li>当系统现有的资源不能满足进程尚需资源数时，对进程的请求可以推迟分配，但总能使进程在有限的时间里得到资源</li>
</ul>
</li>
</ul>
<h2 id="任务的调度的概述"><a href="#任务的调度的概述" class="headerlink" title="任务的调度的概述"></a>任务的调度的概述</h2><ul>
<li>任务的调度要解决的问题：<ul>
<li>WHEN：何时分配CPU<ul>
<li>任务调度的时机，5种情形</li>
</ul>
</li>
<li>HOW：如何分配CPU<ul>
<li>任务调度方式，不可抢占，可抢占</li>
</ul>
</li>
<li>WHAT：按什么原则分配CPU<ul>
<li>任务调度算法，先来先服务、短作业优先、时间片轮转调度、优先级算法</li>
<li>调度算法的性能指标</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><ul>
<li>定义：调度用来确定多任务环境下任务执行的顺序和在获得CPU资源后能够执行的时间长度。</li>
<li>操作系统通过一个<strong>调度程序</strong>来实现调度功能<ul>
<li>调度程序以函数的形式存在，用来实现操作系统的调度算法</li>
<li>调度程序本身并不是一个任务，是一个函数调用，可在内核的各个部分进行调用</li>
</ul>
</li>
<li>调度程序：可以看作CPU的资源管理者<ul>
<li>从就绪队列中选择一个任务去执行</li>
<li>调度算法：调度程序在决策过程中所采用的算法，是在一个特定时刻用来确定将要运行的任务的一组规则</li>
</ul>
</li>
</ul>
<h2 id="任务调度的时机"><a href="#任务调度的时机" class="headerlink" title="任务调度的时机"></a>任务调度的时机</h2><ul>
<li>一般来说有5种情形可能会发生任务的调度。<ul>
<li>当一个新的任务被创建时，需要做出一个调度决策，是立即执行这个新任务还是继续执行父任务</li>
<li>当一个任务运行结束时，它不再占用CPU，这时调度器必须做出一个决策，从就绪队列中选择某个任务去运行</li>
<li>当一个任务由于I&#x2F;O操作、信号量或其他原因被阻塞时，也必须另选一个任务运行</li>
<li>当一个I&#x2F;O操作已经完成，而等待该I&#x2F;O操作的任务将从阻塞状态变为就绪状态</li>
<li>当一个时钟中断发生时，会唤醒一些延时任务或者可能会发现当前任务的时间片已用完，从而把它变为就绪状态</li>
</ul>
</li>
</ul>
<h2 id="任务调度的方式"><a href="#任务调度的方式" class="headerlink" title="任务调度的方式"></a>任务调度的方式</h2><ul>
<li>不可抢占调度方式（Non-Preemptive）：<ul>
<li>如果一个任务被调度程序选中，就会一直运行下去</li>
<li>直到它因为某种原因（如I&#x2F;O操作或任务间的同步）被阻塞了，或者它主动地交出了CPU的使用权。</li>
<li>调度时机中的前3种情况（任务创建、任务运行结束、任务被阻塞），都可能会发生调度。第4、5种情况（即发生中断），不会发生调度</li>
</ul>
</li>
<li>可抢占调度方式（Preemptive）：<ul>
<li>当一个任务正在运行的时候，调度程序可以去打断它，并安排其他的任务去运行</li>
<li>调度时机中所有的5种情况，都可能会发生调度</li>
</ul>
</li>
<li>实时操作系统大都采用可抢占调度方式<ul>
<li>使关键任务能够打断非关键任务的执行，确保关键任务的截止时间能够得到满足</li>
</ul>
</li>
</ul>
<h2 id="任务调度算法的性能指标"><a href="#任务调度算法的性能指标" class="headerlink" title="任务调度算法的性能指标"></a>任务调度算法的性能指标</h2><ul>
<li>CPU的使用率（CPU utilization）</li>
<li>响应时间（responsive time）：调度器为一个就绪任务进行上下文切换时所需的时间，以及任务在就绪队列中的等待时间</li>
<li>周转时间：一个任务从提交到完成所经历的时间</li>
<li>调度开销：调度器在做出调度决策时所需要的时间和空间开销</li>
<li>公平性：大致相当的两个任务所得到的CPU时间应该大致相同。要防止饥饿，即一个任务始终得不到处理器去运行</li>
<li>均衡性：尽可能使整个系统的各个部分（CPU、I&#x2F;O）都忙起来，提高系统资源的使用效率</li>
<li>吞吐量：单位时间内完成的任务数量</li>
<li><strong>这些性能指标之间具有一定的冲突性</strong><ul>
<li>比如可通过让更多的任务处于就绪状态来提高CPU的使用率，但这显然会降低系统的响应时间</li>
<li>调度程序的设计需要优先考虑最重要的需求，然后在各种因素之间进行折中处理</li>
</ul>
</li>
</ul>
<h2 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h2><ul>
<li>先来先服务算法（First Come First Served，FCFS）：也叫先进先出算法（First In First Out，FIFO）按照任务到达的先后次序进行调度，是不可抢占的调度方式<ul>
<li>若当前任务占用CPU在运行，一直等到它执行完或被阻塞，才释放CPU</li>
<li>被阻塞的任务，唤醒后，放在就绪队列的末尾，重新开始排队</li>
</ul>
</li>
<li>先来先服务算法特点：<ul>
<li>简单，易于理解，易于实现</li>
<li>一批任务的平均周转时间取决于各个任务到达的顺序，如果短任务位于长任务之后，将增大平均周转时间</li>
</ul>
</li>
</ul>
<h2 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h2><ul>
<li>短作业优先算法（Shortest Job First，SJF）：各个任务开始执行之前，事先预计好它的执行时间，从中选择用时较短的任务优先执行</li>
<li>短作业优先算法有2种实现方案：<ul>
<li>不可抢占方式：任务正在运行时，即使来了一个更短的任务，也不会被打断，只有当它运行完毕或被阻塞时，才会让出CPU，进行新的调度</li>
<li>可抢占方式：如果一个新的短任务到了，且它的运行时间要小于当前正在运行的任务的剩余时间，则新任务会抢占CPU去运行。也称为最短剩余时间优先算法（Shortest Remaining Time First，SRTF）</li>
</ul>
</li>
</ul>
<h2 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h2><ul>
<li><p>时间片轮转调度（round-robin scheduing RR）算法：</p>
<ul>
<li>所有的就绪任务按照先来先服务的原则排成一个队列</li>
<li>在每次调度的时候，把处理器分派给队列当中的第一个任务，让它去执行一小段时间（时间片）。在这个时间段里任务被阻塞或结束，或者任务的时间片用完了，它会被送到就绪队列的末尾，然后调度器再执行当前队列的第一个任务</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>时间片轮转调度（round-robin scheduing RR）算法的优点：<ul>
<li>公平性：每个就绪任务平均地分配使用CPU的时间</li>
<li>活动性：每个就绪任务都能一直保持着活动性</li>
</ul>
</li>
<li>采用时间片轮转调度算法，任务的时间片大小要适当选择</li>
<li>时间片大小的选择会影响系统的性能和效率<ul>
<li>时间片太大，时间片轮转调度就没有意义</li>
<li>时间片太小，任务切换过于频繁，处理器开销大，真正用于运行应用程序的时间会减小</li>
</ul>
</li>
</ul>
</li>
<li><p>时间片轮转法有一个默认前提，即位于就绪队列中的各个任务时同等重要的</p>
<ul>
<li>任务按照先来后到的顺序排成一个队列</li>
<li>大家轮流执行相同长度的时间片</li>
</ul>
</li>
</ul>
<h2 id="优先级算法："><a href="#优先级算法：" class="headerlink" title="优先级算法："></a>优先级算法：</h2><ul>
<li><p>给每个任务都设置一个优先级</p>
</li>
<li><p>在任务调度的时候，让所有处于就绪状态的任务中选择优先级最高的那个任务去运行</p>
</li>
<li><p>优先级算法分为：可抢占式和不可抢占式</p>
<ul>
<li>可抢占式：当一个任务正在运行，一个优先级更高的新任务进入就绪状态，会立即抢占CPU运行新任务</li>
<li>不可抢占式：当一个任务正在运行，一个优先级更高的新任务进入就绪状态，等当前任务执行完再决定</li>
</ul>
</li>
<li><p>优先级算法确定方式：</p>
<ul>
<li>静态方式<ul>
<li>在创建任务的时候就确定任务的优先级，且一直保持不变直到任务结束</li>
<li>缺点：高优先级的任务会一直占用着CPU运行，低优先级的任务可能会长时间地得不到CPU，一直处于“饥饿”状态</li>
</ul>
</li>
<li>动态方式<ul>
<li>在创建任务的时候确定任务的优先级，但该优先级可以在任务的运行过程中动态改变，以获得更好的调度性能</li>
</ul>
</li>
</ul>
</li>
<li><p>在优先级算法中，把任务按照不同的优先级进行分组，不同组的任务之间使用优先级算法，同一组的各任务之间使用时间片轮转法</p>
</li>
<li><p>采用优先级调度算法还有一个问题是可能会发生<strong>优先级反转</strong>（priority inversion），出现任务“饥饿”现象</p>
</li>
<li><p>理想情况下，高优先级任务就绪后，能够立即抢占低优先级任务而得到执行</p>
</li>
<li><p>实际系统中，但在有多个任务需要使用共享资源的情况下，可能会出现高优先级任务被低优先级任务阻塞，并等待低优先级任务执行的现象</p>
</li>
<li><p>优先级反转（priority inversion）</p>
<ul>
<li>高优先级任务需要等待低优先级任务释放资源，而低优先级任务又正在等待中等优先级任务的现象</li>
</ul>
</li>
</ul>
<h2 id="任务间通信"><a href="#任务间通信" class="headerlink" title="任务间通信"></a>任务间通信</h2><ul>
<li><p>任务间通信（intertask communication）：任务之间为了协调工作，需要相互交换数据和控制信息</p>
</li>
<li><p>任务之间的通信可以分为两种类型：</p>
<ul>
<li>低级通信：只能传递状态和整数值等控制信息，例如信号量机制、异步信号机制</li>
<li>高级通信：能够传输任意数量的数据，主要有三类：<strong>共享内存</strong>、<strong>消息传递</strong>和<strong>管道</strong></li>
</ul>
</li>
<li><p>共享内存（shared memory）：各个任务共享其地址空间中的某些部分，在此区域，可以任意读写和使用任意的数据结构，把它看成一个通用的缓冲区</p>
<ul>
<li>使用共享内存来传递数据时，通常需和任务间的互斥机制结合起来，以免产生竞争条件，确保数据顺利传送</li>
</ul>
</li>
<li><p>消息：内存空间中一段长度可变的缓冲区，其长度和内容均可以由用户定义，其内容可以是实际的数据、数据块的指针或空</p>
</li>
<li><p>对消息内容的解释由应用完成</p>
<ul>
<li>从操作系统观点看，消息没有定义的格式，所有的消息都是字节流，没有特定的含义</li>
<li>从应用观点看，根据应用定义的消息格式，消息被解释成特定的含义</li>
<li>应用可以只把消息当成一个标志，这时消息机制用于实现同步</li>
</ul>
</li>
<li><p>消息传递：任务与任务之间通过发送和接受消息来交换信息</p>
</li>
<li><p>消息机制由操作系统来维护，包括定义寻址方式、认证协议、消息的数量等，一般提供两个基本操作</p>
<ul>
<li>send操作：发送一条消息</li>
<li>receive操作：接受一条消息</li>
</ul>
</li>
<li><p>任务间的通信方式：</p>
<ul>
<li>直接通信。在通信过程中双方必须明确地知道（命名）彼此：<ul>
<li>Send（p，message）发送一个消息到任务p</li>
<li>Receive（Q，message）从任务Q接受一个消息</li>
</ul>
</li>
<li>间接通信。通信双方不需要指出消息的来源或去向，而通过中间机制来通信。如：<ul>
<li>snend（A，message）发送一个消息给邮箱A</li>
<li>receive（A，message）从邮箱A接受一个消息</li>
</ul>
</li>
</ul>
</li>
<li><p>一些操作系统内核把消息进一步分为：邮箱和消息队列</p>
<ul>
<li>邮箱仅能存放单条消息，它提供了一种低开销的机制来传递信息。每个邮箱可以保存一条大小为若干个字节的消息</li>
<li>消息队列可存放若干消息，提供了一种任务间缓冲通信的方法，间接通信方式</li>
</ul>
</li>
<li><p>管道（pipe）是提供非结构化数据交换和实现任务间同步的内核对象。在传统的实现中，管道是单向数据交换设施</p>
<ul>
<li>数据在管道中像一个非结构字节流，按FIFO的次序从管道中读出</li>
<li>当管道空时，阻塞读者，当管道满时，阻塞写者</li>
</ul>
</li>
<li><p>管道和消息队列的区别</p>
<ul>
<li>管道不存储多个消息，它存储的数据是非结构化的字节流</li>
<li>管道中的数据严格地遵循先进先出的顺序</li>
<li>管道支持选择（select）操作，而消息队列不支持</li>
</ul>
</li>
</ul>
<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="文件组织结构"><a href="#文件组织结构" class="headerlink" title="文件组织结构"></a>文件组织结构</h2><ul>
<li>逻辑结构<ul>
<li>流式文件</li>
<li>记录式文件</li>
</ul>
</li>
<li>物理结构<ul>
<li>顺序结构</li>
<li>链接结构</li>
<li>索引结构</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20241024101241.png" alt="微信图片_20241024101151"></p>
<h2 id="树形目录结构"><a href="#树形目录结构" class="headerlink" title="树形目录结构"></a>树形目录结构</h2><ul>
<li>绝对路径</li>
<li>相对路径</li>
</ul>
<p><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20241024101305.png" alt="微信图片_20241024101129"></p>
<h2 id="空闲存储空间的管理"><a href="#空闲存储空间的管理" class="headerlink" title="空闲存储空间的管理"></a>空闲存储空间的管理</h2><ul>
<li>位示图法</li>
</ul>
<p><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20241024101328.png" alt="微信图片_20241024101207"></p>
<h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="虚设备与SPOOLING技术"><a href="#虚设备与SPOOLING技术" class="headerlink" title="虚设备与SPOOLING技术"></a>虚设备与SPOOLING技术</h2><p><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20241024101339.png" alt="微信图片_20241024101201"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>第十二章 嵌入式系统的存储体系</title>
    <url>/2024/10/25/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="存储器部件的分类"><a href="#存储器部件的分类" class="headerlink" title="存储器部件的分类"></a>存储器部件的分类</h1><ul>
<li>按在系统中的<strong>地位分类</strong>：<ul>
<li>主存储器（Main Memory简称<strong>内存</strong>或主存）</li>
<li>辅助存储器（Auxiliary Memory，Secondary Memory，简称辅存或<strong>外存</strong>）</li>
</ul>
</li>
<li><strong>内存</strong>通常用来容纳当前正在使用的或要经常使用的程序和数据，CPU可以直接对内存进行访问<ul>
<li>内存一般都用快速存储器件来构成，内存的存取速度很快，但内存空间的大小受到地址总线位数的限制</li>
<li>系统软件中如引导程序、监控程序或者操作系统中的基本输入&#x2F;输出部分BIOS都是必须常驻内存</li>
<li>更多的系统软件和全部应用软件则在用到时由外存传送到内存</li>
</ul>
</li>
<li><strong>外存</strong>也是用来存储各种信息的，存放的是相对来说不经常使用的程序和数据，其特点是容量大<ul>
<li>外存总是和某个外部设备相关的，常见的外存有软盘、硬盘、U盘、光盘等</li>
<li>CPU要使用外存的这些信息时，必须要通过专门的设备将信息先传送到内存中</li>
</ul>
</li>
<li>按<strong>存储介质</strong>分类<ul>
<li>磁存储器（Magnetic Memory）</li>
<li>半导体存储器</li>
<li>光存储器（Optical Memory）</li>
<li>激光光盘存储器（Laser Optical Disk）</li>
</ul>
</li>
<li>按信<strong>息存取方式</strong>分类<ul>
<li>随机存取存储器（Random Access Memory，RAM）</li>
<li>只读存储器（Read Only Memory，ROM）</li>
</ul>
</li>
<li>随机存取存储器是一种在机器运行期间可读、可写的存储器，又称读写存储器</li>
</ul>
<h2 id="存储器的组织和结构"><a href="#存储器的组织和结构" class="headerlink" title="存储器的组织和结构"></a>存储器的组织和结构</h2><ul>
<li>存储器的参数：容量、数据宽度</li>
<li>存储器的容量是描述存储器的最基本参数，如4MB。存储器的表示不唯一，不同表示方法有不同的数据宽度</li>
<li>在存储器内部，数据是存放在二维阵列存储单元中<ul>
<li>阵列以二维的形式存储，给出的n位地址被分成行地址和列地址（n&#x3D;r+c）。r是行地址数，c是列地址数</li>
<li>行列选定一个特定存储单元</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20241025090721.png" alt="存储器的组织和结构"></p>
<h1 id="常见的嵌入式系统存储设备"><a href="#常见的嵌入式系统存储设备" class="headerlink" title="常见的嵌入式系统存储设备"></a>常见的嵌入式系统存储设备</h1><h2 id="RAM（随机存储器）"><a href="#RAM（随机存储器）" class="headerlink" title="RAM（随机存储器）"></a>RAM（随机存储器）</h2><ul>
<li><p>RAM可以被读和写，地址可以以任意次序被读</p>
</li>
<li><p>常见RAM的种类有</p>
<ul>
<li>SRAM（Static RAM，静态随机存储器）</li>
<li>DRAM（Dynamic RAM，动态随机存储器）</li>
<li>DDRAM（Double Data Rate SDRAM，双倍速率随机存储器）</li>
</ul>
</li>
<li><p>SRAM比DRAM运行速度快，SRAM比DRAM耗电多，DRAM需要周期性刷新</p>
</li>
<li><p>DDRAM是SDRAM的下一代产品，与SDRAM本质相同</p>
<ul>
<li>SDRAM：Synchronous Dynamic Random Access Memory，同步动态随机存储器</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20241025091109.png" alt="随机存储器"></p>
<h3 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h3><ul>
<li>SRAM表示静态随机存取存储器</li>
<li>只要供电它就会保持一个值，<strong>没有刷新周期</strong></li>
<li>由触发器构成基本单元，集成度低</li>
<li>每个SRAM存储单元由6个晶体管组成，成本较高</li>
<li>速率较高，常用于高速缓冲存储器</li>
<li>通常SRAM有4种引脚<ul>
<li>CE：片选信号，低电平有效</li>
<li>R&#x2F;W’：读写控制信号</li>
<li>ADDRESS：一组地址线</li>
<li>DATA：用于数据传输的一组双向信号线</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20241025090659.png" alt="SRAM"></p>
<h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><ul>
<li>DRAM表示动态随机存取存储器</li>
<li>是一种以电荷形式进行存储的半导体存储器</li>
<li>存储单元由1个晶体管和1个电容器组成，数据存储在电容器中</li>
<li><strong>必须定时刷新</strong>，因此DRAM在使用时必须配合DRAM控制器</li>
<li>为了提高系统的数据吞吐能力，可以采用多种技术提高DRAM系统的性能，包括：页模式、ECO、同步DRAM</li>
</ul>
<p><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20241025090628.png" alt="DRAM"></p>
<ul>
<li>DRAM的接口比较复杂，通常有以下引脚<ul>
<li>CE：片选信号，低电平有效</li>
<li>R&#x2F;W’：读写控制信号</li>
<li>RAS’：行地址选通信号，通常接地址的高位部分</li>
<li>CAS’：列地址选通信号，通常接地址的低位部分</li>
<li>ADDRESS：一组地址线</li>
<li>DATA：用于数据传输的一组双向信号线</li>
</ul>
</li>
</ul>
<h3 id="SDRAM"><a href="#SDRAM" class="headerlink" title="SDRAM"></a>SDRAM</h3><ul>
<li>SDRAM表示同步动态随机存取存储器</li>
<li>同步是指内存工作需要同步时钟，内部的命令发送和数据的传输都以它为基准</li>
<li>动态是指存储器阵列<strong>需要不断地刷新</strong>来保证数据不丢失</li>
<li>通常只能工作在133MHz的主频</li>
<li>SDRAM可读&#x2F;可写，不具有掉电保持数据的特性，但其存取速度大大高于Flash存储器</li>
</ul>
<h3 id="DDRAM"><a href="#DDRAM" class="headerlink" title="DDRAM"></a>DDRAM</h3><ul>
<li>DDRAM表示双倍率同步动态随机存取存储器，也称为DDR</li>
<li>基于SDRAM技术</li>
<li>双倍预取技术，即在内存芯片内部的数据宽度是外部接口数据宽度的2倍，使峰值的读写速度达到输入时钟速率的2倍</li>
<li>允许在时钟脉冲的上升沿和下降沿均传输数据</li>
<li>在133MHz的主频下，DDR内存带宽可以达到133x64b&#x2F;8x2&#x3D;2.1GB&#x2F;s</li>
<li>差分输入方式</li>
</ul>
<h2 id="ROM（只读存储器）"><a href="#ROM（只读存储器）" class="headerlink" title="ROM（只读存储器）"></a>ROM（只读存储器）</h2><ul>
<li>ROM在烧入数据后，无需外加电源来保存数据，断电后数据不丢失，但速度较慢，适合存储需长期保留的不变数据</li>
<li>在嵌入式洗系统中，ROM用于固定数据和程序</li>
<li>常见ROM有<ul>
<li>Mask ROM（掩膜ROM）<ul>
<li>一次性由厂家写入数据的ROM，用户无法修改</li>
</ul>
</li>
<li>PROM（Programmable ROM，可编写ROM）<ul>
<li>出厂时厂家没有写入数据，保留里面的内容为全0和全1，由<strong>用户来编程一次性写入数据</strong></li>
</ul>
</li>
<li>EPROM（Erasable Programmable ROM，可擦写ROM）<ul>
<li>可以通过紫外线光的照射，擦掉原先的程序，芯片可重复擦除和写入。<strong>写入时间较长</strong></li>
</ul>
</li>
<li>EEPROM（电可擦除可编程ROM，也可表示为E2PROM）<ul>
<li>通过加电擦除原编程数据，通过高压脉冲可以写入数据</li>
</ul>
</li>
<li>Flash ROM<ul>
<li>断电不会丢失数据，<strong>快速读取</strong>，电可擦写可编程</li>
</ul>
</li>
</ul>
</li>
<li>PROM、EPROM、EEPROM的共同之处<ul>
<li>可编程的只读存储器</li>
<li>属于非易失性元件</li>
<li>芯片为有限次写入</li>
</ul>
</li>
<li>PROM、EPROM、EEPROM的不同之处<ul>
<li>PROM为一次编程器件；EPROM为电编程、紫外线擦除器件、EEPROM电编程、电擦写</li>
<li>PROM编程元件：熔丝型开关或者非熔丝型开关（PLICE：多晶硅）</li>
<li>EPROM编程元件：叠栅型（SIMOS）浮栅</li>
<li>EEPROM编程元件：隧道型（FLOTOX）浮栅</li>
</ul>
</li>
</ul>
<h3 id="FLASH"><a href="#FLASH" class="headerlink" title="FLASH"></a>FLASH</h3><ul>
<li>Flash memory（闪速存储器）是嵌入式系统中重要的组成部分，用来存储程序和数据，掉电后数据不会丢失</li>
<li>但在使用Flash Memory时，必须根据其自身特性，对存储系统进行特殊设计，以保证系统的性能达到最优</li>
<li>Flash Memory是一种非易失性存储器NVM（Non-Volatile Memory），根据结构的不同可以分为：NOR Flash、NAND Flash</li>
</ul>
<h3 id="NOR-Flash和NAND-Flash相同特点"><a href="#NOR-Flash和NAND-Flash相同特点" class="headerlink" title="NOR Flash和NAND Flash相同特点"></a>NOR Flash和NAND Flash相同特点</h3><ul>
<li>区块结构：Flash Memory在物理结构上分成若干个区块，区块之间相互独立<ul>
<li>NOR Flash把整个存储区分成若干个<strong>扇区</strong>（Sector）</li>
<li>NAND Flash把整个存储区分为若干个<strong>块</strong>（Block）</li>
<li>可以对<strong>以块或扇区为单位</strong>的内存单元进行先擦写和再编程</li>
</ul>
</li>
<li>先擦后写：由于Flash Memory的写操作只能将数据位从1写成0，而不能从0写成1，所以在对存储器进行写入之前必须先执行擦除操作，将预写入的数据位初始化为1<ul>
<li>擦操作的最小单位是一个区块，而不是单个字节</li>
</ul>
</li>
<li>操作指令：除了NOR Flash的读，Flash Memory的其他操作不能像RAM那样，直接对目标地址进行总线操作<ul>
<li>例如执行一次写操作，它必须输出一串特殊的指令（NOR Flash），或者完成一段时序（NAND Flash）才能将数据写入到Flash Memory中</li>
</ul>
</li>
<li>位反转：<ul>
<li>所有的Flash Memory器件存在<strong>位交换现象</strong></li>
<li>Flash Memory在读写数据时，偶然会产生一位或几位数据错误，即位反转</li>
<li>位反转无法避免，只能通过其他手段对产生的结果进行事后处理</li>
<li>位反转的问题多见于NAND Flash。供货商建议使用NAND Flash的时候，同时使用EDC&#x2F;ECC（错误探测&#x2F;错误纠正）算法，以确保可靠性</li>
</ul>
</li>
<li>坏块<ul>
<li>Flash Memory在使用过程中，可能导致某些区块的损坏</li>
<li>区块一旦损坏，将无法进行修复</li>
<li>NAND Flash中的坏块是随机分布的，尤其是NAND Flash在出厂时就可能存在这样的坏块（已经被标识出）</li>
<li>NAND Flash需要对介质进行初始化扫描以发现坏块，并将坏块标记为不可用</li>
<li>如果对已损坏的区块进行操作，可能会带来不可预测的错误</li>
</ul>
</li>
</ul>
<h3 id="NOR-Flash和NAND-Flash不同特点"><a href="#NOR-Flash和NAND-Flash不同特点" class="headerlink" title="NOR Flash和NAND Flash不同特点"></a>NOR Flash和NAND Flash不同特点</h3><ul>
<li>应用程序可以直接在<strong>NOR Flash内运行</strong>，不需要再把代码读到系统RAM中运行</li>
<li>NOR Flash的传输速率很高，在1~4MB的小容量时具有很高的成本效益，但是很低的写入和擦除速度大大影响了它的性能</li>
<li>NAND Flash结构可以达到高存储器密度，写入和擦除的速度很快，应用NAND Flash的困难在于<strong>需要特殊的系统接口</strong></li>
<li>性能比较<ul>
<li>NAND Flash执行擦除操作是十分简单的</li>
<li>NOR型内存则要求在进行擦除前先要将目标内所有的位都写为0</li>
<li>由于擦除NOR Flash时是以64~128KB为单位的块进行的，执行一个写入&#x2F;擦除操作的时间为5s</li>
<li>擦除NAND Flash是以8~32KB的块进行的，执行相同的操作最多只需要4ms</li>
<li>NOR Flash的读速度比NAND Flash稍快一些</li>
<li>NAND Flash的写入速度比NOR FLash块很多</li>
<li>NAND Flash的随机读取能力差，适合大量数据的<strong>连续读取</strong></li>
<li>NAND Flash的4ms擦除速度远比NOR Flash的5s快</li>
</ul>
</li>
<li>接口差别<ul>
<li>NOR Flash带有SRAM接口，有足够的地址引脚来寻址，可以很容易地存取其内部的每一个字节</li>
<li>NAND Flash地址、数据和命令共用8位&#x2F;16位总线，每次读写都要使用复杂的I&#x2F;O接口串行地存取数据，8位总线&#x2F;16位总线用来传送控制、地址和资料信息</li>
<li>NAND Flash读和写操作采用512B的块，类似硬盘管理操作<ul>
<li>因此，基于NAND的闪存可以取代硬盘或其他块设备</li>
</ul>
</li>
</ul>
</li>
<li>容量和成本<ul>
<li>NOR Flash容量通常在1MB~8MB之间，主要应用在代码存储介质中</li>
<li>NAND Flash用在8MB以上的产品当中。使用与资料存储</li>
</ul>
</li>
<li>寿命<ul>
<li>在NAND Flash中每个块的最大擦写次数时一百万次</li>
<li>NOR Flash的擦写次数是十万次</li>
<li>NAND Flash除了具有10:1的块擦除周期优势，典型的NAND Flash块尺寸要比NOR型闪存小8倍，每个NAND Flash的内存块在给定的时间内删除次数要少一些</li>
</ul>
</li>
<li>软件支持<ul>
<li>在NOR Flash上运行代码不需要任何的软件支持</li>
<li>在NAND Flash上进行同样操作时，通常需要驱动程序，也就是内存技术驱动程序（MTD）</li>
<li>NAND Flash和NOR Flash在进行写入和擦除操作时都需要MTD</li>
</ul>
</li>
<li>市场定位<ul>
<li>NOR Flash：对数据可靠性要求较高的代码存储、通信产品、网络处理等领域，也被称为<strong>代码闪存</strong>（Code Flash）</li>
<li>NAND Flash：对存储容量要求较高的MP3、存储卡、U盘等领域，也被<strong>称为数据闪存</strong>（Data Flash）</li>
</ul>
</li>
</ul>
<h2 id="常见外存的种类"><a href="#常见外存的种类" class="headerlink" title="常见外存的种类"></a>常见外存的种类</h2><ul>
<li>外部存储器：也称为辅助存储器，简称外存或辅存<ul>
<li>容量比主存大、读取速度较慢</li>
<li>通常用来存放需要永久保存的或相对来说暂时不用的程序和数据<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20241025110923.png" alt="常见外存的种类"></li>
</ul>
</li>
</ul>
<h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><ul>
<li>硬盘存储器具有存储容量大，使用寿命长，存取速度较快的特点，也是在嵌入式系统中常用的外存</li>
<li>硬盘存储器的硬件包括<ul>
<li>硬盘控制器（适配器）</li>
<li>硬盘驱动器</li>
<li>连接电缆</li>
</ul>
</li>
<li>硬盘控制器（Hard Disk Controller，简称HDC）对硬盘进行管理，并在主机和硬盘之间传送数据。硬盘控制器以适配卡的形式插在主板上或直接集成在主板上，然后通过电缆与硬盘驱动器相连</li>
<li>硬盘驱动器（Hard Disk Drive，简称HDD）中有盘片、磁头、主轴电机（盘片旋转驱动机构）、磁头定位机构、读&#x2F;写电路和控制逻辑等</li>
<li>硬盘存储器可分为：温彻斯特盘和非温彻斯特盘两类<ul>
<li>温彻斯特盘是根据温彻斯特技术设计制造的，它的磁头、盘片、磁头定位机构、主轴、甚至连读&#x2F;写驱动电路等都被密封在一个盘盒内，构成一个头-盘组合体</li>
<li>温彻斯特盘的防尘性能好，可靠性高，对使用环境要求不高</li>
<li>非温彻斯特盘磁盘的磁头和盘片等不是密封的，通常只能用于中型、大型计算机机房中</li>
</ul>
</li>
<li>最常见的硬盘接口是IDE（ATA）和SCSI两种，一些移动硬盘采用PCMCIA或USB接口</li>
<li>SCSI（Small Computer System Interface，小型计算机系统接口）不是专为硬盘设计的，是一种总线型接口<ul>
<li>SCSI独立于系统总线工作，其系统占用率极低，但其价格昂贵</li>
<li>具有这种接口的硬盘大多用于服务器等高端应用场合</li>
</ul>
</li>
</ul>
<h3 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h3><ul>
<li>光盘：用光学方式读&#x2F;写信息的圆盘</li>
<li>光盘存储器：以光盘为存储介质的存储器</li>
<li>光盘的类型<ul>
<li>CD-RAM：Compact Disc Read Only Memory</li>
<li>CD-R：采用WORM（Write One Read Many）标准</li>
<li>CD-RW：可重复读&#x2F;写</li>
<li>DVD-ROM：通用数字化多功能光盘，简称高容量CD</li>
</ul>
</li>
</ul>
<h3 id="标准存储卡（CF卡）"><a href="#标准存储卡（CF卡）" class="headerlink" title="标准存储卡（CF卡）"></a>标准存储卡（CF卡）</h3><ul>
<li>CF存储卡是由美国SanDisk公司于1994年研制成功的</li>
<li>CF卡的大小为43mm x 36mm x 3.3mm，CF卡同时支持3.3伏和5伏的电压，可以在这两种电压下工作</li>
<li>CF卡（Compact Flash）接口具有PCMCIA-ATA功能，可以工作在IDE接口模式，也可以工作在PC Card模式</li>
<li>CF卡主要在PDA、笔记本电脑、数码相机和包括台式机在内的各种设备</li>
</ul>
<h3 id="安全数据卡（SD卡）"><a href="#安全数据卡（SD卡）" class="headerlink" title="安全数据卡（SD卡）"></a>安全数据卡（SD卡）</h3><ul>
<li>SD卡是由日本松下公司、东芝公司和美国SanDisk公司于1999年8月共同研制开发而成的</li>
<li>SD卡是根据MMC卡开发的，但是基本上两者还是不同的产品，只是在设计时考虑到兼容问题，所以在大多数情况下这两种产品能够互换，它比MMC卡多了一个进行数据著作权保护功能</li>
<li>多用于MP3、数码相机、电子图书、微型电脑和AV器材等。尺寸大小比MMC卡略厚一些，为32mm x 24mm x 2.1mm</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>第六章 嵌入式软件程序设计</title>
    <url>/2024/09/13/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="嵌入式系统开发与设计"><a href="#嵌入式系统开发与设计" class="headerlink" title="嵌入式系统开发与设计"></a>嵌入式系统开发与设计</h1><ul>
<li>一个嵌入式应用项目的开发过程是一个硬件设计和软件设计的综合过程，一般而言要经历以下几个步骤：<ul>
<li>硬件的设计与实现</li>
<li>设备驱动软件的设计与实现</li>
<li>嵌入式操作系统的选择、移植，以及API接口函数的设计</li>
<li>支撑软件的设计与调试</li>
<li>应用程序的设计与调试</li>
<li>系统联调，样机交付</li>
</ul>
</li>
<li>嵌入式应用程序的生成与加载<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240913103939.png" alt="嵌入式应用程序的生产与加载"></li>
<li>嵌入式软件开发有如下的几个特点<ul>
<li>需要交叉编译工具</li>
<li>通过仿真手段进行调试</li>
<li>开发板是中间目标机</li>
<li>可利用的资源有限</li>
<li>需要与硬件打交道</li>
</ul>
</li>
<li>嵌入式软件开发的挑战<ul>
<li>软硬件协同设计</li>
<li>嵌入式操作系统</li>
<li>代码优化</li>
<li>有限的I&#x2F;O功能</li>
</ul>
</li>
<li>嵌入式系统开发的最大特点：软硬件综合开发<ul>
<li>嵌入式产品是软硬件的结合体</li>
<li>软件针对硬件开发、固化，不能进行任意修改</li>
</ul>
</li>
<li>嵌入式软件开发模式通常是包括三种<ul>
<li>本机开发</li>
<li>交叉开发</li>
<li>模拟开发</li>
</ul>
</li>
<li>嵌入式软件开发流程<ul>
<li>嵌入式平台选型</li>
<li>软件设计</li>
<li>特性设计</li>
<li>编码</li>
<li>测试</li>
<li>下载和运行</li>
</ul>
</li>
</ul>
<h1 id="嵌入式程序设计"><a href="#嵌入式程序设计" class="headerlink" title="嵌入式程序设计"></a>嵌入式程序设计</h1><h2 id="程序设计语言"><a href="#程序设计语言" class="headerlink" title="程序设计语言"></a>程序设计语言</h2><ul>
<li><p>程序设计语言<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240913103952.png" alt="程序设计语言"></p>
</li>
<li><p>各种程序语言特点</p>
<ul>
<li>Fortran语言（科学计算，执行效率高）</li>
<li>Pascal语言（为教学而开发的，表达能力强，Delphi）</li>
<li>C语言（指针操作能力强，高效）</li>
<li>Lisp语言（函数式程序语言，符号处理，人工智能）</li>
<li>C++语言（面向对象，高效）</li>
<li>Java语言（面向对象，中间代码，跨平台）</li>
<li>C#语言（面向对象，中间代码，.Net）</li>
<li>Prolog语言（逻辑推理，简洁性，表达能力，数据库和专家系统）</li>
<li>Python语言（一种脚本语言）</li>
</ul>
</li>
</ul>
<h2 id="程序语言的数据成分"><a href="#程序语言的数据成分" class="headerlink" title="程序语言的数据成分"></a>程序语言的数据成分</h2><ul>
<li>数据是程序操作的对象，具有以下属性<ul>
<li>数据名称：由用户通过标识符命名</li>
<li>数据类型：说明数据占用内存的大小和存放形式</li>
<li>存储类别：说明数据在内存中的位置和生存期</li>
<li>作用域：说明可以使用数据的代码范围</li>
<li>生存域：说明数据占用内存的时间范围</li>
</ul>
</li>
<li>程序设计语言的基本成分包括：<ul>
<li>数据</li>
<li>运算</li>
<li>控制</li>
<li>传输</li>
</ul>
</li>
<li>数据类型<ul>
<li>基本类型：整型、字符型、实型、布尔类型</li>
<li>特殊类型：空类型（void）</li>
<li>用户定义类型：枚举类型</li>
<li>构造类型：数组、结构、联合</li>
<li>指针类型：type*</li>
<li>抽象类型：类类型</li>
</ul>
</li>
<li>数据类型转换规则：char，short-&gt;int-&gt;unsigned-&gt;long，float-&gt;double</li>
</ul>
<h2 id="程序语言的运算成分"><a href="#程序语言的运算成分" class="headerlink" title="程序语言的运算成分"></a>程序语言的运算成分</h2><ul>
<li>指明允许使用的运算符号及运算规则，运算符号要规定优先级和结合性，大多数高级程序语言的基本运算包括了<ul>
<li>算术运算</li>
<li>关系运算</li>
<li>逻辑运算</li>
<li>位运算</li>
</ul>
</li>
</ul>
<h2 id="程序语言的控制成分"><a href="#程序语言的控制成分" class="headerlink" title="程序语言的控制成分"></a>程序语言的控制成分</h2><ul>
<li>三种基本逻辑结构<ul>
<li>顺序结构：是一种线性有序的结构，由一系列依次执行的语句或模块组成</li>
<li>循环结构：是由一个或几个模块构成，程序运行时重复执行，直到满足某一条件为止</li>
<li>选择结构：是根据条件成立与否选择执行路径的结构</li>
</ul>
</li>
</ul>
<h2 id="传值-传址"><a href="#传值-传址" class="headerlink" title="传值&#x2F;传址"></a>传值&#x2F;传址</h2><ul>
<li>传值调用：实际上重新复制了一个副本给形参，不改变调用函数实参变量的内容</li>
<li>传址调用：将实参地址给形参，将改变调用函数实参变量的内容<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240913104002.png" alt="传值"></li>
</ul>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><ul>
<li>前缀表达式<code>+ab</code></li>
<li>中缀表达式<code>a+b</code></li>
<li>后缀表达式<code>ab+</code>（逆波兰式）</li>
</ul>
<h2 id="编译器的工作阶段"><a href="#编译器的工作阶段" class="headerlink" title="编译器的工作阶段"></a>编译器的工作阶段</h2><ul>
<li>词法错误：非法字符，关键字或标识符拼写错误</li>
<li>语法错误：语法结构出错，if…end if不匹配，缺分号</li>
<li>语义错误：死循环，零除数，其他逻辑错误<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240913104015.png" alt="编译器的工作阶段"></li>
</ul>
<h2 id="解释程序基本原理"><a href="#解释程序基本原理" class="headerlink" title="解释程序基本原理"></a>解释程序基本原理</h2><ul>
<li><p>解释程序是另一种语言处理程序，在词法、语法和语义分析方面与编译程序的工作原理基本相同</p>
</li>
<li><p>但在运行用户程序时，它直接执行源程序或源程序的内部形式。因此，解释程序与编译程序最大的区别就是不产生源程序的目标程序</p>
</li>
<li><p>解释程序通常可分为两部分</p>
<ul>
<li>分析部分，包括通常的词法分析、语法分析和语义分析程序。经分析后把源程序翻译成中间代码</li>
<li>解释部分，用来对第一部分所产生的中间代码进行解释执行</li>
</ul>
</li>
<li><p>解释语句实现高级语言的三种方式</p>
<p><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240913104052.png" alt="解释程序基本原理"></p>
<ul>
<li>源程序被直接解释执行的处理方式，如图标记A，这种解释程序对源程序逐个字符进行检查，然后执行语句规定的动作。如GOTO L</li>
<li>解释程序也可以先将源程序翻译成某种中间代码的形式，然后对中间代码进行解释，实现用户程序的运行。解释方式B和C的不同之处在于中间代码的级别</li>
</ul>
</li>
</ul>
<h2 id="C预处理"><a href="#C预处理" class="headerlink" title="C预处理"></a>C预处理</h2><ul>
<li><code>#define</code>：定义宏</li>
<li><code>#include</code>：包含一个源代码文件</li>
<li><code>#undef</code>：取消已定义的宏</li>
<li><code>#ifdef</code>：如果宏已经定义，则返回真</li>
<li><code>#ifndef</code>：如果宏没有定义，则返回真</li>
<li><code>#if</code>：一般含义是如果<code>#if</code>后面的常量表达式为<code>true</code>，则编译它与<code>#endif</code>之间的代码，否则跳过这些代码</li>
<li><code>#else</code>：类似C语言中的<code>else</code>，<code>#else</code>建立另一选择（<code>#if</code>失败的情况下）</li>
<li><code>#elif</code>：类似于<code>elseif</code>，它形成一个<code>if else-if</code>阶梯状语句，进行多种编译选择 </li>
<li><code>#endif</code>：标识一个<code>#if</code>块的结束</li>
<li><code>#error</code>：当遇到标准错误时，输出错误消息</li>
<li><code>#pragma</code>：使用标准化方法，向编译器发布特殊的命令到编译器中</li>
</ul>
<h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><ul>
<li><p><code>__DATE__</code>：当前源文件的编译日期，格式为“Mmm dd yyyy”的字符串字面量</p>
</li>
<li><p><code>__TIME__</code>：当前源文件的编译时间。格式为“hh:mm:ss”的字符串字面量</p>
</li>
<li><p><code>__FILE__</code>：当前源文件名称，含路径信息</p>
</li>
<li><p><code>__FUNC__</code>：当前函数名称</p>
</li>
<li><p><code>__LINE__</code>：当前程序行的行号，表示为十进制整型常量</p>
</li>
<li><p><code>__STDC__</code>：若当前编译器符合ISO标准，那么该宏的值为1，否则未定义</p>
</li>
<li><p><code>__STDC_HOSTED__</code>：（C99）如果当前是宿主系统，则该宏的值为1，否则为0</p>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>基本数据类型<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240913104125.png" alt="基本数据类型"></li>
<li>变量<ul>
<li>常量（字面量和const常量）</li>
<li>void类型（特殊类型）</li>
<li>数组（构造类型）</li>
<li>枚举类型（自定义类型）</li>
<li>结构体、位域和共用体（构造类型）</li>
</ul>
</li>
</ul>
<h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><ul>
<li>如图所示是一个程序运行时的内存分布<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240913104136.png" alt="屏幕截图 2024-09-13 095810"></li>
</ul>
<h2 id="函数调用的过程"><a href="#函数调用的过程" class="headerlink" title="函数调用的过程"></a>函数调用的过程</h2><p><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240913104158.png" alt="函数调用的例子"></p>
<ol>
<li>程序开始运行时，main函数被装入到内存，代码存放在内存的代码区域</li>
<li>全局变量区域分配了一个存储单元给变量z，并初始化为0</li>
<li>接下来，系统调用主函数main去运行</li>
<li>当这个函数调用发生时，系统就会在栈中给它分配一块内存空间（栈帧），存放main函数内部定义的局部变量x，y</li>
<li>PC跳转到主函数的第一条语句，开始执行</li>
<li>函数执行完后，首先释放栈帧，x和y所占用的空间被释放，不能再访问</li>
<li>整个程序结束，全部变量z释放，不能再访问</li>
</ol>
<h2 id="变量的存储与作用域"><a href="#变量的存储与作用域" class="headerlink" title="变量的存储与作用域"></a>变量的存储与作用域</h2><p><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240913104214.png" alt="变量的存储与作用域"></p>
<h2 id="面向对象的语言"><a href="#面向对象的语言" class="headerlink" title="面向对象的语言"></a>面向对象的语言</h2><ul>
<li>Peter Coad和Edward Yourdon提出用下面的等式来识别面向对象方法，采用这四个概念开发的软件系统是面向对象的<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240913104220.png" alt="屏幕截图 2024-09-13 101143"></li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>第二章 嵌入式系统软件</title>
    <url>/2024/08/21/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="嵌入式软件基础"><a href="#嵌入式软件基础" class="headerlink" title="嵌入式软件基础"></a>嵌入式软件基础</h1><h2 id="嵌入式软件特点"><a href="#嵌入式软件特点" class="headerlink" title="嵌入式软件特点"></a>嵌入式软件特点</h2><ul>
<li>规模较小</li>
<li>开发难度大<ul>
<li>硬件资源有限</li>
<li>嵌入式软件一般涉及到底层软件的开发，需要软、硬件基础</li>
<li>开发环境和运行环境不高</li>
</ul>
</li>
<li>实时性和可靠性要求高</li>
<li>要求固化存储</li>
</ul>
<h2 id="嵌入式软件分类"><a href="#嵌入式软件分类" class="headerlink" title="嵌入式软件分类"></a>嵌入式软件分类</h2><ul>
<li>系统软件：控制和管理嵌入式系统资源<ul>
<li>嵌入式操作系统</li>
<li>驱动程序</li>
<li>嵌入式中间件（CORBA、Java）等</li>
</ul>
</li>
<li>支撑软件：辅助软件开发的工具软件<ul>
<li>系统分析设计工具</li>
<li>仿真开发工具</li>
<li>交叉开发工具</li>
<li>测试工具</li>
<li>配置管理工具</li>
<li>维护工具等</li>
</ul>
</li>
<li>应用软件：定义嵌入式设备的主要功能和用途，负责与用户进行交互（面向应用领域）<ul>
<li>手机软件</li>
<li>路由器软件</li>
<li>交换机软件</li>
<li>飞控软件等</li>
</ul>
</li>
</ul>
<h2 id="嵌入式软件的体系结构"><a href="#嵌入式软件的体系结构" class="headerlink" title="嵌入式软件的体系结构"></a>嵌入式软件的体系结构</h2><h3 id="无操作系统阶段"><a href="#无操作系统阶段" class="headerlink" title="无操作系统阶段"></a>无操作系统阶段</h3><ul>
<li>硬件配置较低，系统应用主要集中在控制领域</li>
<li>嵌入式软件的设计是以应用为核心，应用软件直接建立在硬件上</li>
<li>无操作系统的嵌入式软件的两种实现方式：<ul>
<li>循环轮转：把系统功能分解为若干个不同的任务，然后把它们包含在一个永不结束的循环语句中。按照顺序逐一执行。执行完一轮循环后，又回到循环体</li>
<li>前后台系统（在循环轮转的基础上增加了中断处理功能）：<ul>
<li>前台程序（事件处理级）：中断服务程序，负责处理异步事件</li>
<li>后台程序（任务级）：一个无限循环，负责资源分配、管理和系统调度</li>
<li>在系统运行时，后台程序会检查每个任务是否具备运行条件，对实时性要求严格的操作通常由中断完成</li>
<li>前后台系统认为所有的任务具有相同的优先级，任务的执行是通过先进先出队列排队</li>
<li>实时性较差</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="有操作系统阶段："><a href="#有操作系统阶段：" class="headerlink" title="有操作系统阶段："></a>有操作系统阶段：</h3><p><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240820201546.png" alt="屏幕截图 2024-08-20 195845"></p>
<ul>
<li><p>开发应用程序不再直接面对嵌入式硬件设备，而是在操作系统的基础上编写。优点有：</p>
<ul>
<li><p>提高了系统的可靠性</p>
<ul>
<li>提高了系统的开发效率，降低了开发成本，缩短了开发周期<ul>
<li>可以按照软件工程的思想，将程序分解为多个任务模块，每个任务模块的调试、修改几乎不影响其他模块</li>
<li>商业软件提供了良好的多任务调试环境</li>
</ul>
</li>
</ul>
</li>
<li><p>有利于系统的扩展与移植</p>
</li>
</ul>
</li>
</ul>
<h2 id="设备驱动层"><a href="#设备驱动层" class="headerlink" title="设备驱动层"></a>设备驱动层</h2><ul>
<li><p>也叫板级支持包BSP：包含了嵌入式系统中所有与硬件相关的代码</p>
<ul>
<li>大多数的嵌入式硬件设备都需要某种类型软件的初始化和管理</li>
<li>这部分工作由设备驱动层来完成的，它负责直接与硬件打交道， 对硬件进行管理和控制，为上层软件提供所需的驱动支持，类似PC系统中的BIOS和驱动程序</li>
</ul>
</li>
<li><p>板级支持包BSP（Board Support Package）</p>
<ul>
<li>把嵌入式操作系统与具体的硬件平台隔离开来</li>
<li>即在BSP中，把所有与硬件相关的代码都封装起来，向上提供一个虚拟的硬件平台，操作系统就运行在这个虚拟的硬件平台上</li>
<li>操作系统使用一组定义好的编程接口来与BSP进行交互，并通过BSP来访问真正的硬件</li>
</ul>
</li>
<li><p>一般BSP主要包括两个方面的内容</p>
<ul>
<li>引导加载程序Boot Loader</li>
<li>设备驱动程序</li>
</ul>
</li>
<li><p>引导加载程序Boot Loader是嵌入式系统加电后运行的第一段软件代码，是在操作系统内核运行之前运行的一段小程序</p>
<ul>
<li>通过这段程序，可以初始化硬件设备、建立内存空间的映射图</li>
<li>将系统的软硬件环境设置到一个合适的状态，为最终调用操作系统内核做准备</li>
</ul>
</li>
<li><p>Boot Loader的实现高度依赖于具体的硬件平台，主要的基本功能如下</p>
<ul>
<li>片级初始化</li>
<li>板级初始化</li>
<li>加载内核</li>
</ul>
</li>
<li><p>片级初始化</p>
<ul>
<li>主要完成微处理器的初始化</li>
<li>包括设置微处理器的核心寄存器和控制寄存器、微处理器的核心工作模式、局部总线模式等</li>
<li>把微处理器从上电的默认状态设置成系统要求的工作状态</li>
<li>纯硬件初始化过程</li>
</ul>
</li>
<li><p>板级初始化</p>
<ul>
<li>设置各种硬件寄存器来完成微处理器以外的其他硬件设备的初始化</li>
<li>设置某些软件的数据结构和参数</li>
<li>同时有软件和硬件的初始化过程</li>
</ul>
</li>
<li><p>加载内核</p>
<ul>
<li>将操作系统和应用程序的映像从Flash存储器复制到系统内存中</li>
<li>然后跳转到系统内核的第一条指令处继续执行</li>
</ul>
</li>
<li><p>设备驱动程序</p>
<ul>
<li>在一个嵌入式系统中，操作系统可能有也可能无，设备驱动是必不可少的</li>
<li>设备驱动程序，是一组库函数，用来对硬件进行初始化和管理，并向上层软件提供良好的访问接口</li>
<li>大多数设备驱动程序都具备下面的基本功能：启动、关闭、停用、启用、读操作、写操作</li>
</ul>
</li>
<li><p>设备驱动程序的分层结构：把设备驱动程序中的函数分为硬件接口函数和调用接口函数</p>
<ul>
<li>硬件接口：直接操作和控制硬件</li>
<li>上层接口：为上层软件提供服务和函数接口。不直接和硬件打交道，会调用硬件接口中的函数</li>
<li>优点：把所有与硬件相关的细节都封装在硬件接口中，在硬件需要升级，需要更新设备驱动程序的时候，只需要改动接口中的函数即可，而上层调用接口中的函数不用做任何修改</li>
</ul>
</li>
<li><p>设备驱动程序的混合结构：</p>
<ul>
<li>在设备驱动程序当中，没有明确的层次关系</li>
<li>上层接口和硬件接口函数混在一起、互相调用</li>
</ul>
</li>
</ul>
<h2 id="嵌入式中间件"><a href="#嵌入式中间件" class="headerlink" title="嵌入式中间件"></a>嵌入式中间件</h2><ul>
<li>中间件：在操作系统内核、设备驱动程序和应用软件之外的所有系统软件</li>
<li>基本思路：把原本属于应用软件层的一些通用的功能模块抽取出来，形成独立的一层软件，从而为运行在它上面的那些应用软件提供一个灵活、安全、移植性好、相互通信、协同工作的平台</li>
<li>特点：<ul>
<li>可以有效地实现软件的可重用，降低应用软件的复杂性，提高系统的开发效率，缩短开发周期，节约开发成本和维护费用，保证了系统的高伸缩性、易升级性、稳定性</li>
<li>但会带来额外的开销</li>
</ul>
</li>
<li>种类：<ul>
<li>消息中间件</li>
<li>对象中间件</li>
<li>远程过程调用</li>
<li>数据库访问中间件</li>
<li>安全中间件等</li>
</ul>
</li>
</ul>
<h2 id="嵌入式软件的运行流程"><a href="#嵌入式软件的运行流程" class="headerlink" title="嵌入式软件的运行流程"></a>嵌入式软件的运行流程</h2><ul>
<li>主要分为五个阶段<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240821194125.png" alt="屏幕截图 2024-08-21 174628"></li>
</ul>
<h1 id="嵌入式操作系统概述"><a href="#嵌入式操作系统概述" class="headerlink" title="嵌入式操作系统概述"></a>嵌入式操作系统概述</h1><ul>
<li><p>基本概念：嵌入式操作系统（Embedded Operating System，EOS）：工作在嵌入式环境中的操作系统</p>
</li>
<li><p>基本功能</p>
<ul>
<li>从软件开发的角度，可以把EOS看成是一种扩展机或虚拟机。将底层的硬件细节封装起来，为运行在它上面的软件提供了一个抽象的编程接口，即操作系统对外提供的系统调用函数</li>
<li>从系统管理的角度，可以把EOS看成是系统资源的管理者，负责管理系统当中的各种软硬件资源</li>
</ul>
</li>
<li><p>特有功能</p>
<ul>
<li>非通用型操作系统</li>
<li>在性能和实时性方面可能有严格的限制</li>
<li>能源、成本和可靠性通常是影响设计的重要因素</li>
<li>占用资源少</li>
<li>可裁剪、可配置</li>
</ul>
</li>
<li><p>不同的嵌入式操作系统，包含的组件各不相同，但所有操作系统都会有一个内核（kernel），<strong>内核</strong>是指操作系统中的一个组件，它包含了<strong>OS</strong>的主要功能，即OS的各种特性及其相互之间的依赖关系</p>
</li>
<li><p>OS的主要功能：</p>
<ul>
<li>任务管理：对系统中运行的软件进行描述和管理，并完成处理器资源分配和调度</li>
<li>存储管理：提高内存的利用率，方便用户使用，提供足够的存储空间</li>
<li>I&#x2F;O设备管理：方便设备的使用，提高CPU和I&#x2F;O设备的利用率</li>
<li>文件管理：解决文件资源存储、共享、保密和保护等问题</li>
</ul>
</li>
<li><p>不同嵌入式操作系统的内核设计各不相同，不一定包含所有的4个功能模块，取决于系统设计和实际需求</p>
</li>
<li><p>嵌入式操作系统的分类</p>
<ul>
<li>按系统类型来分<ul>
<li>商业系统：商业化的嵌入式操作系统<ul>
<li>功能强大、性能稳定、应用范围相对较广、辅助软件齐全</li>
<li>价格较贵</li>
<li>如VxWorks、Windows CE、PalmOS</li>
</ul>
</li>
<li>专用系统：专业厂家为本公司产品特制的嵌入式操作系统</li>
<li>开源系统：开放源代码的嵌入式操作系统<ul>
<li>免费、开源、性能优良、资源丰富、技术支持强</li>
<li>如μC&#x2F;OS、Linux系统</li>
</ul>
</li>
</ul>
</li>
<li>按系统对响应时间的敏感程度来分<ul>
<li>硬实时系统：系统对响应时间有严格要求，若响应时间不能满足，是绝对不允许的，会引起系统的崩溃或致命的错误</li>
<li>软实时系统：系统对响应时间有要求，若响应时间不能满足，会带来额外可接受的代价</li>
<li>非实时系统：响应时间没有严格要求，如分时操作系统，基于公平性原则，各进程分享处理器，获得大致相同的运行时间</li>
</ul>
</li>
<li>按软件体系结构来分<ul>
<li><strong>单体结构（μC&#x2F;OS）</strong></li>
<li><strong>分层结构（MS-DOS）</strong></li>
<li><strong>微内核结构（Vxworks）</strong></li>
<li>这三类操作系统的差异体现在<ul>
<li>内核的设计：内核中包含的功能组件</li>
<li>在系统中集成的其他系统软件</li>
</ul>
</li>
</ul>
</li>
<li>单体结构（monolithic）：是一种常见的组织结构<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240821194218.png" alt="屏幕截图 2024-08-21 190535"><ul>
<li>中间件和设备驱动程序通常集中在系统内核中</li>
<li>系统只有一个可执行文件，包含所有功能组件，功能模块可相互调用</li>
<li>如Linux、Jbed RTOS、μC&#x2F;OS、PDOS</li>
<li>优点：性能较好、系统各模块间可相互调用、通信开销较小</li>
<li>缺点：<ul>
<li>操作系统体积庞大、高度集成、相互关联</li>
<li>系统裁剪、修改和调试都较困难</li>
</ul>
</li>
</ul>
</li>
<li>分层结构（layered）：操作系统被划分为若干个层次（0~N），各个层次之间的调用关系是单向的，即某一层次上的代码只能调用比它低层的代码<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240821194226.png" alt="屏幕截图 2024-08-21 190535"><ul>
<li>只有一个大的可执行文件，包含有设备驱动程序和中间件</li>
<li>系统的开发和维护较为简单</li>
<li>要替换系统中的某一层时，不会影响到其他的层次</li>
<li>但每个层次都要提供一组<strong>API</strong>接口函数，带来额外的开销<ul>
<li>API（APPlication Programming Interface，应用程序编程接口）：<ul>
<li>是一些预先定义的函数</li>
<li>目的是提供应用程序与开发人员基于某软件或硬件的以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>微内核结构：也称为客户&#x2F;服务（client&#x2F;server）结构，在内核中，把操作系统的大部分功能都剥离出去，只保留最核心的功能单元（如进程管理、存储管理）。如：OS-9、C Executive、VxWorks和QNX等。<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240821194234.png" alt="屏幕截图 2024-08-21 190840"><ul>
<li>优点：<ul>
<li>内核非常小</li>
<li>易于扩展、调试方便：新的功能组件可以被动态添加</li>
<li>安全性更高：大部分的系统功能被放置在内核之外</li>
<li>可移植性</li>
</ul>
</li>
<li>缺点：<ul>
<li>通过微内核构造和发送信息、接受应答并解码所花费的时间比进行一次系统调用的时间多</li>
<li>很大程度取决于微内核的大小和功能</li>
<li>客户单元和服务器单元的内存地址空间是相互独立，在切换时候，会增加额外开销</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240821194242.png" alt="屏幕截图 2024-08-21 191215"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>书</title>
    <url>/2023/07/07/%E6%82%9F/%E4%B9%A6/</url>
    <content><![CDATA[<ul>
<li><p>如果用一句话形容书我想是“润物细无声”。</p>
</li>
<li><p>读书，是为了那些不能读书的人。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>第十三章 嵌入式输入输出设备</title>
    <url>/2024/09/10/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h1 id="GPIO的原理与结构"><a href="#GPIO的原理与结构" class="headerlink" title="GPIO的原理与结构"></a>GPIO的原理与结构</h1><ul>
<li>GPIO（General Purpose I&#x2F;O，通用输入&#x2F;输出接口）也称为并行I&#x2F;O（parallel I&#x2F;O），是最基本的I&#x2F;O形式<ul>
<li>有一组输入引脚或输出引脚组成，CPU对它们能够进行存取操作</li>
<li>有些GPIO引脚能够通过软件编程改变输出&#x2F;输出方向</li>
</ul>
</li>
<li>一个双向GPIO端口（D<sub>0</sub>）的简化功能逻辑图如图所示，图中：<ul>
<li>PORT：数据寄存器</li>
<li>DDR（Data Direction Register）：数据方向寄存器<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240910140433.png" alt="GPIO"></li>
</ul>
</li>
</ul>
<h1 id="A-D接口基本原理与结构"><a href="#A-D接口基本原理与结构" class="headerlink" title="A&#x2F;D接口基本原理与结构"></a>A&#x2F;D接口基本原理与结构</h1><ul>
<li>A&#x2F;D转换器是把电模拟量转换为数字量的电路。实现A&#x2F;D转换的方法有很多，常用的方法有：<ul>
<li>计数法</li>
<li>双积分法</li>
<li>逐次逼近法<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240910140453.png" alt="AD转换"></li>
</ul>
</li>
</ul>
<h2 id="计数式A-D转换器原理"><a href="#计数式A-D转换器原理" class="headerlink" title="计数式A&#x2F;D转换器原理"></a>计数式A&#x2F;D转换器原理</h2><ul>
<li>计数式A&#x2F;D转换器电路的主要部件包括：比较器、计数器、D&#x2F;A转换器和标准电压源。转换原理图如下所示：<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240910140508.png" alt="计数式AD转换原理"></li>
<li>特点<ul>
<li>结构简单</li>
<li>但转换速度较慢</li>
<li>特别是模拟电压较高时，转换速度更慢</li>
<li>例如对一个8位A&#x2F;D转换器，若输入模拟量为最大值，计数器要从0开始计数到255，做255次D&#x2F;A转换和电压比较的工作，才能完成转换</li>
</ul>
</li>
</ul>
<h2 id="双积分A-D转换器原理"><a href="#双积分A-D转换器原理" class="headerlink" title="双积分A&#x2F;D转换器原理"></a>双积分A&#x2F;D转换器原理</h2><ul>
<li>双积分式A&#x2F;D转换法电路主要部件包括：积分器、比较器、计数器和标准电压源。转换原理图如下所示：</li>
</ul>
<p><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240910140518.png" alt="双积分AD转换原理"></p>
<ul>
<li>工作原理：<ul>
<li>对输入模拟电压和参考电压进行两次积分，将电压变换成与其成正比的时间间隔</li>
<li>利用时钟脉冲和计数器测出其时间间隔，完成A&#x2F;D转换<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240910140541.png" alt="双积分AD转换积分原理"></li>
</ul>
</li>
<li>双积分式A&#x2F;D转换器的转换过程如下：<ul>
<li>对输入待测的模拟电压V<sub>i</sub>进行固定时间的积分</li>
<li>转换至标准电压V<sub>REF</sub>进行固定斜率的反向积分（定值积分），反向积分进行到一定时间，便返回起始值。对标准电压V<sub>REF</sub>进行反向积分的时间T正比于输入模拟电压，输入模拟电压越大，反向积分回到起始值的时间T越长，有V<sub>i</sub>&#x3D;（T2&#x2F;T1）V<sub>REF</sub></li>
<li>用标准时钟脉冲测定反向积分时间（如计数器），就可以得到对应于输入模拟电压的数字量，实现A&#x2F;D转换</li>
</ul>
</li>
<li>特点：<ul>
<li>具有很强的抗工频干扰能力</li>
<li>转换精度高</li>
<li>但转换速度慢</li>
<li>通常转换速率小于10Hz，主要用于数字式测试仪表、温度测量等方面</li>
</ul>
</li>
</ul>
<h2 id="逐次逼近式A-D转换器原理"><a href="#逐次逼近式A-D转换器原理" class="headerlink" title="逐次逼近式A&#x2F;D转换器原理"></a>逐次逼近式A&#x2F;D转换器原理</h2><ul>
<li>逐次逼近式A&#x2F;D转换法电路主要部件包括：比较器、D&#x2F;A转换器、逐次逼近寄存器和基准电压源</li>
</ul>
<p><img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240910140602.png" alt="逐次逼近式AD转换器"></p>
<ul>
<li>工作原理：<ul>
<li>实质上就是对分搜索法，和天平称重的使用原理一样</li>
<li>在进行A&#x2F;D转换时，由D&#x2F;A转换器从高位到低位逐位增加转换位数，产生不同的输出电压，把输入电压与输出电压进行比较而实现</li>
<li>首先使逐次逼近寄存器的最高位为1，这相当于取出基准电压的1&#x2F;2与输入电压比较，如果在输入电压小于1&#x2F;2的基准电压，则最高位置0，反之置1。之后，次高位置1，相当于在1&#x2F;2得到范围中再作对分搜索，以此类推，逐次逼近</li>
</ul>
</li>
<li>特点：<ul>
<li>转换速度快</li>
<li>转换精度高</li>
<li>对N位A&#x2F;D转换只需N个时钟脉冲即可完成</li>
<li>可用于测量微秒级的过渡过程的变化，是目前应用最普遍的一种A&#x2F;D转换方法</li>
</ul>
</li>
</ul>
<h1 id="D-A接口基本原理与结构"><a href="#D-A接口基本原理与结构" class="headerlink" title="D&#x2F;A接口基本原理与结构"></a>D&#x2F;A接口基本原理与结构</h1><ul>
<li>D&#x2F;A转换器是把输入的数字量转换为与输入量成比例的模拟信号的器件，简称为DAC（Digital to Analog Converter）<ul>
<li>在集成化的D&#x2F;A转换器中，通常采用电阻网络实现将数字量转换为模拟电流</li>
<li>然后再用运算放大器完成模拟电流到模拟电压的转换<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240910140700.png" alt="AD转换"></li>
</ul>
</li>
<li>一个4位T型电阻网络DAC如图所示<ul>
<li>电路由R-2R电阻解码网络、模拟电子开关和求和放大电路构成，因为R和2R组成T型，故称为T型电阻网络DAC<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240910140919.png" alt="屏幕截图 2024-09-10 093116"></li>
</ul>
</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>电压输出型<ul>
<li>电压输出型D&#x2F;A转换器虽有直接从电阻阵列输出电压的，但一般采用内置输出放大器以低阻抗输出</li>
<li>直接输出电压的器件仅用于高阻抗负载，由于无输出放大器部分的延迟，故常作为高速D&#x2F;A转换器使用</li>
</ul>
</li>
<li>电流输出型<ul>
<li>电流输出型D&#x2F;A转换器直接输出电流，但应用中通常外接电流-电压转换电路得到电压输出</li>
<li>电流-电压可以直接在输出引脚上连接一个负载电阻，实现电流-电压转换</li>
<li>但多采用的是外接运算放大器的形式</li>
<li>大部分CMOS D&#x2F;A转换器当输出电压不为零时不能正确动作，所以必须外接运算放大器</li>
<li>在D&#x2F;A转换器的电流建立时间上加入了外接运算放大器的延迟，D&#x2F;A响应变慢</li>
<li>运算放大器因输出引脚的内部电容容易起振，有时必须作相位补偿</li>
</ul>
</li>
<li>乘算型：<ul>
<li>D&#x2F;A转换器中有使用恒定基准电压的，也有在基准电压输入上加交流信号的，后者由于能得到数字输入和基准电压输入相乘的结果而输出，因而称为乘算型D&#x2F;A转换器</li>
<li>乘算型D&#x2F;A转换器一般不仅可以进行乘法运算，而且可以作为使输入信号数字化衰减的衰减器及对输入信号进行调制的调制器使用</li>
</ul>
</li>
</ul>
<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><ul>
<li>分辨率（Resolution）：<ul>
<li>DAC电路所能分辨的最小输出电压与满量程输出电压之比称为DAC的分辨率</li>
<li>最小输出电压是指输入数字量只有最低有效位为1时的输出电压</li>
<li>最大输出电压是指输入数字量各位全为1时的输出电压</li>
<li>DAC的分辨率可用下式表示：<strong>分辨率&#x3D;(1&#x2F;(2<sup>n</sup>-1)) * 量程</strong>，式中，n表示数字量的二进制位数</li>
</ul>
</li>
<li>DAC产生误差的主要原因有：<ul>
<li>基准电压V<sub>REF</sub>的波动</li>
<li>运放的零点漂移</li>
<li>电阻网络中电阻阻值偏差等原因</li>
</ul>
</li>
<li>转换误差<ul>
<li>转换误差重用满量程FSR（Full Scale Range）的百分数来表示</li>
<li>例如，一个DAC的线性误差为0.05%，就是说转换误差是满量程输出的万分之五</li>
<li>有时转换误差用最低有效位LSB（Least Significant Bit）的倍数来表示</li>
<li>例如，一个DAC的转换误差是LSB&#x2F;2，则表示输出电压的绝对误差是最低有效位（LSB）为1时输出电压的1&#x2F;2</li>
</ul>
</li>
<li>DAC的转换误差主要有<strong>失调误差</strong>和<strong>满值误差</strong></li>
<li>失调误差<ul>
<li>输入数字量全为0时，模拟输出值与理论输出值的偏差</li>
<li>在一定温度下的失调误差可以通过外部电路调整措施进行补偿，也有些DAC芯片本身有调零端进行调零</li>
<li>对于没有设置调零端的芯片，可以采用外接校正偏置电路加到运放求和端</li>
</ul>
</li>
<li>满值误差<ul>
<li>又称增益误差，是指输入数字量全为1时，实际输出电压不等于满值的偏差</li>
<li>调整运放的反馈电阻</li>
</ul>
</li>
<li>DAC的分辨率和转换误差共同决定了DAC的精度<ul>
<li>要使DAC的精度高，不仅要选择位数高的DAC，还要选用稳定度高的参考电压源V<sub>REF</sub>和低漂移的运算放大器与其配合</li>
</ul>
</li>
<li>建立时间（Setting Time）<ul>
<li>是描述DAC转换速度快慢的一个重要参数，一般是指输入数字量变化后，输出模拟量稳定到相应数值范围所经历的时间</li>
<li>DAC中的电阻网络，模拟开关等是非理想器件，各种寄生参数及开关延迟等都会限制转换速度</li>
<li>一般电流输出D&#x2F;A转换建立时间较短，电压输出D&#x2F;A转换建立时间较长</li>
<li>实际上建立时间的长短不仅与DAC本身的转换速度有关，还与数字量变化范围有关</li>
<li>输入数字量从全0变到全1（或者从全1变到全0）时，建立时间最长，称为满量程变化建立时间</li>
<li>一般产品手册上给出的是满量程变化建立时间</li>
</ul>
</li>
<li>精度（Accuracy）<ul>
<li>绝对精度：在一个转换器中，对应于一个数字量的实际模拟输入电压和理想的模拟输入电压之差并非是一个常数。把它们之间的差的最大值，定义为“绝对误差”。通常以数字量的最小有效位（LSB）的分数值来表示绝对精度，如±1LSB。绝对误差包括量化精度和其他所有精度</li>
<li>相对精度：是指整个转换范围内，任一数字量所对应的模拟输入量的实际值与理论值之差，用模拟电压满量程的百分比表示</li>
<li>例如，满量程为10V，10位A&#x2F;D芯片，若其绝对精度为±1&#x2F;2LSB，则其最小有效位的量化单位为9.77mV，其绝对精度为4.88mV，其相对精度为0.048%</li>
</ul>
</li>
<li>量程<ul>
<li>量程是指所能转换的模拟输入电压范围，分单极性、双极性两种类型</li>
<li>例如，单极性的量程为0 ~ +5V，0 ~ +20V；双极性的量程为-5 ~ +5V，-10 ~ +10V</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>第十四章 嵌入式系统总线和通信接口</title>
    <url>/2024/09/11/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF%E5%92%8C%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="串行接口基本原理与结构"><a href="#串行接口基本原理与结构" class="headerlink" title="串行接口基本原理与结构"></a>串行接口基本原理与结构</h1><ul>
<li>串行通信：数据是一位一位地进行传输的，在传输中每一位数据都占据一个固定的时间长度</li>
<li>优点：<ul>
<li>传输线少、成本低</li>
<li>特别适合远距离传送</li>
</ul>
</li>
<li>缺点：<ul>
<li>速度慢</li>
</ul>
</li>
</ul>
<h2 id="串行数据传送3种基本的通信模式"><a href="#串行数据传送3种基本的通信模式" class="headerlink" title="串行数据传送3种基本的通信模式"></a>串行数据传送3种基本的通信模式</h2><ul>
<li><p>单工通信：数据仅能从设备A到设备B进行单一方向的传输。如遥控、遥测等</p>
</li>
<li><p>半双工通信：数据可以从设备A到设备B进行传输，也可以从设备B到设备A进行传输，但不能在同一时刻进行双向传输。如对讲机</p>
</li>
<li><p>全双工通信：数据可以在同一时刻从设备A传输到设备B，或从设备B传输到设备A，即可以同时双向传输。如电话</p>
</li>
</ul>
<h2 id="串行通信在信息格式上划分"><a href="#串行通信在信息格式上划分" class="headerlink" title="串行通信在信息格式上划分"></a>串行通信在信息格式上划分</h2><h3 id="异步通信方式"><a href="#异步通信方式" class="headerlink" title="异步通信方式"></a>异步通信方式</h3><ul>
<li><p>是指通信的发送和接收设备使用各自的时钟，控制数据的发送和接收过程</p>
</li>
<li><p>为使双方的收发协调，要求发送和接收设备的时钟尽可能一致</p>
</li>
<li><p>数据是一帧一帧传送的，每帧数据包含有起始位（“0”）、数据位、奇偶校验位和停止位（“1”），每帧数据的传送靠起始位来同步</p>
</li>
<li><p>一帧数据的各位代码间的时间间隔是固定的，而相邻两帧的数据其时间间隔是不固定的</p>
</li>
<li><p>在异步通信的数据传送中，传输线上允许空字符</p>
</li>
<li><p>异步通信对字符格式、波特率、校验位有确定的要求</p>
<ul>
<li><p>字符格式</p>
<ul>
<li>每个字符传送时，必须前面加一起始位，后面加上1、1.5或2位停止位</li>
<li>例如ASCII码传送时，一帧数据的组成是：前面一个起始位，接着7位ASCII编码，再接着一位奇偶校验位，最后一位停止位，共10位<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240911190440.png" alt="串行异步通信字符格式"></li>
</ul>
</li>
<li><p>波特率</p>
<ul>
<li>传送数据位的速率称为波特率，用位&#x2F;秒（bit&#x2F;s）来表示，称之为波特</li>
<li>例如，数据传送的速率为120字符帧&#x2F;秒，每帧包括10个数据位，则传送波特率为：10X120&#x3D;1200b&#x2F;s&#x3D;1200波特</li>
<li>异步通信的波特率的数值通常为：150、300、600、1200、2400、4800、9600、14400、28800等，数值成倍数变化</li>
</ul>
</li>
<li><p>校验位</p>
<ul>
<li>偶校验就是要使字符加上校验位有偶数个“1”</li>
<li>奇校验就是要使字符加上校验位有奇数个“1”</li>
<li>例如数据“00010011”，共有奇数个“1”，偶校验时，则校验位就置为“1”，奇校验时，则校验位就置为“0”</li>
</ul>
</li>
</ul>
</li>
<li><p>异步通信的特点</p>
<ul>
<li>不要求收发双方时钟的严格一致，实现容易，设备开销小</li>
<li>但每个字符要附加2~3位用于起止位，各帧之间还有间隔，因此传输效率不高。实际使用率只有约80%</li>
</ul>
</li>
</ul>
<h3 id="同步通信方式"><a href="#同步通信方式" class="headerlink" title="同步通信方式"></a>同步通信方式</h3><ul>
<li>是一种比特同步通信技术，要求收发双方具有同频同相的同步时钟信号，只需在传送报文的最前面附加特定的同步字符，使收发双方建立同步，此后便在同步时钟的控制下逐位发送&#x2F;接收</li>
<li>同步传输采用字符块的方式，减少每一个字符的控制和错误检测数据位，因而可以具有较高的传输速率</li>
<li>即将许多字符聚集成一字符后，在每块信息之前要加上1~2个同步字符，字符块之后再加入适当的错误检测数据才传送出去</li>
<li>特点<ul>
<li>数据传输速率较高</li>
<li>但要求发送方时钟和接受方时钟保持严格同步</li>
</ul>
</li>
</ul>
<h2 id="RS-232串行接口"><a href="#RS-232串行接口" class="headerlink" title="RS-232串行接口"></a>RS-232串行接口</h2><ul>
<li><p>RS-232C是美国电子工业协会（EIA）制定的一种串行通信接口标准</p>
</li>
<li><p>RS-232C接口规格</p>
<ul>
<li><p>EIA所制定的传送电气规格</p>
<table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center">L（LOW）</th>
<th align="center">H（Hight）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">电压范围</td>
<td align="center">-25V~3V</td>
<td align="center">+3V~+25V</td>
</tr>
<tr>
<td align="center"><strong>负逻辑</strong></td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
</li>
<li><p>RS-232C通常以±12V的电压来驱动信号线，TTL标准与RS-232C标准之间的电平转换电路通常采用集成电路芯片实现，如M2AX23等</p>
</li>
</ul>
</li>
<li><p>RS-232C接口信号</p>
<ul>
<li><p>EIA制定的RS-232C接口与外界的相连采用25芯（DB-25）和9芯（DB-9）D型插接件，实际应用中，并不是每只引脚信号都必须用到。</p>
</li>
<li><p>各引脚功能如下<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240911190511.png" alt="RS232"></p>
<table>
<thead>
<tr>
<th align="center">引脚号</th>
<th align="center">符号名称</th>
<th align="center">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">CD</td>
<td align="center">载波检测</td>
<td align="left">主要用于Modem通知计算机其处于在线状态，即Modem检测到拨号音</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">RXD</td>
<td align="center">接收数据线</td>
<td align="left">用于接收外部设备送来的数据</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">TXD</td>
<td align="center">发送数据线</td>
<td align="left">用于将计算机的数据发送给外部设备</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">DTR</td>
<td align="center">数据终端就绪</td>
<td align="left">当此引脚高电平时，通知Modem可以进行数据传输，计算机已经准备好</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">SG</td>
<td align="center">信号地</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">DSR</td>
<td align="center">数据设备就绪</td>
<td align="left">此引脚为高电平时，通知计算机Modem已经准备好，可以进行数据通信</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">RTS</td>
<td align="center">请求发送</td>
<td align="left">此引脚由计算机来控制，用以通知Modem马上传送数据至计算机；否则，Modem将收到的数据暂时放入缓冲区中</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">CTS</td>
<td align="center">允许发送</td>
<td align="left">此引脚由Modem控制，用以通知计算机将要传送的数据送至Modem</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">RI</td>
<td align="center">振铃提示</td>
<td align="left">Modem通知计算机有呼叫进来，是否接听呼叫由计算机决定</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>RS-232C的基本连接方式</p>
<ul>
<li>计算机利用RS-232C接口进行串口通信，有简单连接和完全连接两种连接方式</li>
<li>简单连接又称三线连接，即只连接发送数据线、接受数据线和信号地、实现全双工通信</li>
<li>如果应用中还需要使用RS-232C的控制信号，则采用完全连接方式<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240911190530.png" alt="RS232两种连接方式"></li>
</ul>
</li>
</ul>
<h2 id="RS-422串行接口"><a href="#RS-422串行接口" class="headerlink" title="RS-422串行接口"></a>RS-422串行接口</h2><ul>
<li>RS-422标准是RS-232的改进型，是一种单机发送、多机接收的单向、平衡传输规范，传输速率可达10Mb&#x2F;s。采用差分传输方式，也称做平衡传输<ul>
<li>允许在相同传输线上连接多个接收节点，最多可接10个节点，即一个主设备（Master），其余10个为从设备（Salve），从设备之间不能通信</li>
<li>支持一点对多点的双向通信。RS-422四线接口由于采用单独的发送和接受通道，因此不必控制数据方向，各装置之间任何必需的信号交换均可以按软件方式（XON&#x2F;XOFF握手）或硬件方式（一对单独的双绞线）实现</li>
</ul>
</li>
<li>RS-422的最大传输距离为4000英尺（约1219m），最大传输速率为10Mb&#x2F;s<ul>
<li>传输速率与平衡双绞线的长度有关，只有在很短的距离下才能获得最高传输速率</li>
<li>在最大传输距离时，传输速率为100Kb&#x2F;s</li>
<li>一般100m长的双绞线上所能获得的最大传输速率仅为1Mb&#x2F;s</li>
<li>RS-422需要再传输电缆的最远端连接一个电阻，要求电阻阻值约等于传输电缆的特性阻抗<ul>
<li>在短距离（300m以下）传输时可以不连接电阻</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="RS-485串行接口"><a href="#RS-485串行接口" class="headerlink" title="RS-485串行接口"></a>RS-485串行接口</h2><ul>
<li><p>在RS-422的基础上，为扩展应用范围，EIA制定了RS-485标准，增加了多点、双向通信能力</p>
<ul>
<li>在通信距离为几十米至上千米时，通常采用RS-485收发器</li>
<li>RS-485收发器采用平衡发送和差分发送</li>
<li>即在发送端，驱动器将TTL电平信号转换成差分信号输出；在接受端，接收器将差分信号变成TTL电平，因此具有抑制共模干扰能力</li>
<li>接受器能够检测低达200mV的电压，具有高的灵敏度，故数据传输距离可达千米以上</li>
</ul>
</li>
<li><p>RS-485可以采用二线与四线方式，二线制可实现真正的多点双向通信</p>
<ul>
<li>采用四线连接时，与RS-422一样只能实现点对多的通信，即只能有一个主设备，其余为从设备</li>
<li>RS-485可以连接多达32个设备</li>
</ul>
</li>
<li><p>RS-485的共模输出电压在-7~+12V之间，接收器最小输入阻抗为12kΩ</p>
</li>
<li><p>RS-485满足所有RS-422的规范，所以RS-485的驱动器可以在RS-422网络中应用</p>
</li>
<li><p>RS-485的最大传输速率为10Mb&#x2F;s。在最大传输距离时，传输速率为100Kb&#x2F;s</p>
</li>
<li><p>RS-485需要两个终端电阻，接在传输总线的两端，要求电阻阻值约等于传输电缆的特性阻抗</p>
<ul>
<li>在短距离传输（300m以下）时可不需要终端电阻</li>
</ul>
</li>
</ul>
<h1 id="并行接口基本原理与结构"><a href="#并行接口基本原理与结构" class="headerlink" title="并行接口基本原理与结构"></a>并行接口基本原理与结构</h1><ul>
<li><p>并行通信通常是将数据字节的各位用多条数据线同时进行传送</p>
<ul>
<li>一般用来连接打印机、扫描仪等，所以又称打印口</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>控制简单、传输速度快</li>
<li>由于传输线较多，长距离传送时成本高且接收方的各位同时接收存在困难</li>
</ul>
</li>
<li><p>并行接口可以分为</p>
<ul>
<li>SPP（标准并口）</li>
<li>EPP（增强型并口）</li>
<li>ECP（扩展型并口）</li>
</ul>
</li>
<li><p>并行总线分为：</p>
<ul>
<li><strong>标准</strong>并行总线</li>
<li><strong>非标准</strong>并行总线</li>
</ul>
</li>
<li><p>常用的并行标准总线：<strong>IEEE488总线</strong>和<strong>SCSI总线</strong>。</p>
</li>
<li><p><strong>MXI总线</strong>是一种高性能非标准的通用多用户并行总线</p>
</li>
<li><p>IEEE488总线</p>
<ul>
<li>又称GPIB总线（General Purpose Interface Bus，通用接口总线）</li>
<li>位并行、字节串行双向异步方式传输信号</li>
<li>总线方式连接，仪器设备直接并联于总线上，总线上最多可连接15台设备</li>
<li>最大传输距离为20m，信号传输速度一般为500Kb&#x2F;s，最大传输速度为1Mb&#x2F;s</li>
<li>广泛应用在仪器、仪表、测控领域</li>
</ul>
</li>
<li><p>SCSI（Small Computer System Interface，小型计算机系统接口）总线：</p>
<ul>
<li>速度可达5Mb&#x2F;s，传输距离6m</li>
<li>传输速率很高</li>
<li>普遍用作计算机的高速外设总线，如连接高速硬盘驱动器</li>
</ul>
</li>
<li><p>MXI（Multi-system extension Interface bus，多系统扩展接口总线）</p>
<ul>
<li>是一种高性能非标准的通用多用户并行总线</li>
<li>32位高速并行总线</li>
<li>最高速度可达23Mb&#x2F;s，传输距离20m</li>
<li>用作计算机与测控机箱的互连</li>
</ul>
</li>
</ul>
<h1 id="PCI接口基本原理与结构"><a href="#PCI接口基本原理与结构" class="headerlink" title="PCI接口基本原理与结构"></a>PCI接口基本原理与结构</h1><ul>
<li><p>PCI（Peripheral Component Interconnect，外围设备互连）总线是由Intel公司推出的一种局部总线，是当前用于系统扩展最流行的总线之一</p>
</li>
<li><p>PCI总线是地址、数据多路复用的高性能32位和64位总线，是微处理器与外围控制部件、外围附加板之间的互连机构</p>
</li>
<li><p>PCI定义了32位数据总线，并且可扩展为64位。总线速度有33MHz和66MHz两种</p>
<ul>
<li>改良的PCI系统PCI-X，数据传输速度最高可以达到64位@133MHz</li>
<li>PCI总线主板插槽的体积比ISA总线插槽小，支持突发读写操作（突发数据传输），可同时支持多组外围设备</li>
</ul>
</li>
<li><p>与ISA总线不同，PCI总线的地址总线与数据总线是分时复用的，支持即插即用（PNP：PLug-and-Play）、中断共享等功能</p>
</li>
<li><p>PCI总线在数据传输时，由一个PCI设备做发起者（称为Master、Initiator），而另一个PCI设备做目标（称为Slave、Target）</p>
<ul>
<li>总线上所有时序的产生和控制都由Master发起</li>
<li>PCI总线在同一时刻只能供一对设备完成传输，要求有一个仲裁机构来决定谁有权拿到总线的控制权</li>
</ul>
</li>
</ul>
<h1 id="USB接口基本原理与结构"><a href="#USB接口基本原理与结构" class="headerlink" title="USB接口基本原理与结构"></a>USB接口基本原理与结构</h1><ul>
<li><p>USB（Universal Serial Bus，通用串行总线）是由Compaq、HP、Intel、Lucent、Microsoft、NEC和Philips公司制定的连接计算机与外围设备的机外串行总线</p>
<ul>
<li>最多可连接127个设备</li>
<li>用于多种嵌入式系统设备的数据通信。如移动硬盘、PDA</li>
</ul>
</li>
<li><p>热插拔。USB提供机箱外的热插拔功能，连接外设不必再打开机箱，也不必关闭主机电源，USB可智能地识别USB链上外围设备的动态插入和拆除，具有自动配置和重新配置外设的能力，连接设备方便，使用简单</p>
</li>
<li><p>可连接多个外部设备</p>
<ul>
<li>每个USB系统中有一个主机，USB总线采用“级联”方式可连接多个外部设备</li>
<li>每个USB设备用一个USB插头连接到上一个USB设备插座上，而其本身又提供一或多个USB插座供下一个或多个USB设备连接使用</li>
<li>这种多重连接是通过集线器（Hub）来实现的，整个USB网络中最多可连接127个设备，支持多个设备同时操作</li>
</ul>
</li>
<li><p>低成本的电缆和连接器</p>
<ul>
<li>USB采用统一的4引脚插头和一根四芯的电缆传送信号和电源</li>
<li>电缆长度可长达5m</li>
</ul>
</li>
<li><p>总线供电</p>
<ul>
<li>USB总线可为连接在其上的设备提供5V电压&#x2F;100mA电流的供电，最大可提供500mA的电流</li>
<li>USB设备也可采用自供电方式。可以通过电池或其他的电力设备</li>
<li>支持节约能源的挂机和唤醒模式</li>
</ul>
</li>
<li><p>USB总线的电缆有一对标准尺寸的双绞信号线和一对标准尺寸的电源线，共4根导线</p>
<table>
<thead>
<tr>
<th align="center">连接序号</th>
<th align="center">信号名称</th>
<th align="center">典型连接线</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">VBUS（USB电源）</td>
<td align="center">红</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">D+（正差分信号）</td>
<td align="center">白</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">D-（负差分信号）</td>
<td align="center">绿</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">GND（USB地）</td>
<td align="center">黑</td>
</tr>
<tr>
<td align="center">外层</td>
<td align="center">屏蔽层</td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="SPI接口基本原理与结构"><a href="#SPI接口基本原理与结构" class="headerlink" title="SPI接口基本原理与结构"></a>SPI接口基本原理与结构</h1><ul>
<li><p>SPI（Serial Peripheral Interface，串行外围设备接口）是由Motorola公司开发的一个低成本、易使用的接口，主要用在微控制器（MCU）和外围设备芯片之间进行连接。SPI接口可以用来连接存储器、A&#x2F;D转换器、D&#x2F;A转换器、实时时钟日历、LCD驱动器、传感器、音频芯片，其他处理器等。</p>
</li>
<li><p>SPI是一个4线接口，主要使用4个信号</p>
<ul>
<li>主机输出&#x2F;从机输入（MOSI）</li>
<li>主机输入&#x2F;从机输出（MISO）</li>
<li>串行SCLK或SCK</li>
<li>外设片选（&#x2F;CS）</li>
<li>有些处理器有SPI接口专用的芯片选择，称为从机选择（&#x2F;SS）</li>
</ul>
</li>
<li><p>MOSI信号由主机产生，从机接收。在有些芯片上，MOSI只被简单地标为串行输入（SI），或串行数据输入（SDI）</p>
</li>
<li><p>MISO信号由从机产生，不过还是在主机的控制下产生的。在一些芯片上，MISO有时被称为串行输出（SO）或串行数据输出（SDO）</p>
</li>
<li><p>外设片选信号：通常只是由主机的备用I&#x2F;O引脚产生的</p>
</li>
<li><p>与标准的串行接口不同，SPI是一个同步协议接口，所有的传输都参考一个共同的时钟，这个同步时钟信号由主机（处理器）产生，接收数据的外设（从设备）使用时钟来对串行比特流的接收进行同步化。可以将多个具有SPI接口的芯片连到主机的同一个SPI接口上，主机通过控制从设备的片选输入引脚来选择接收数据的从设备。</p>
</li>
<li><p>如图所示，微处理器通过SPI接口与外设进行连接<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240911190728.png" alt="SPI连线"></p>
<ul>
<li>主机和外设都包含一个串行移位寄存器，主机写入一个字节到它的SPI串行寄存器，SPI寄存器通过MOSI信号线将字节传送给外设</li>
<li>外设也可以将自己移位寄存器中的内容通过MISO信号线传送给主机。主机和外设的两个移位寄存器中的内容被相互交换</li>
<li>外设的写操作和读操作是同步完成的，因此SPI成为一个很有效的协议</li>
</ul>
</li>
<li><p>如果只是进行写操作，主机只需忽略收到的字节</p>
</li>
<li><p>如果主机要读取外设的一个字节，就必须发送一个空字节来触发从机的数据传输</p>
</li>
<li><p>当主机发送一个连续的数据流时，有些外设能进行多字节传输</p>
<ul>
<li>如多数具有SPI接口的存储器芯片都以这种方式工作。在这种传输方式下，SPI外设的芯片选择端必须在整个传输过程中保持低电平</li>
<li>如，存储器芯片会希望在一个“写”命令之后紧接着收到的是4个地址字节（起始地址），这样后面接收到的数据就可以存储到该地址</li>
</ul>
</li>
<li><p>其他外设只需要一个单字节（比如一个发给A&#x2F;D转换器的命令），有些设置还支持菊花链连接，如图所示<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240911190642.png" alt="SPI菊花链连接方式"></p>
<ul>
<li>主机处理器从其SPI接口发送3个字节的数据</li>
<li>第1个字节发送给外设A，当第2个字节发送给外设A的时候，第1个字节已移出了A，而传送给了B</li>
<li>同样，主机想要从外设A读取一个结果，它必须再发送一个3字节（空字节）的序列，这样就可以把A中的数据移到B中，然后再移到C中，最后送回到主机。在这个过程中，主机还依次从B和C接收到字节</li>
<li>注意，菊花链连接不一定适用于所有的SPI设备，特别是要求多字节传输的（比如存储器芯片）设备。有的外设芯片不支持菊花链连接</li>
</ul>
</li>
<li><p>根据时钟极性和时钟相位的不同，SPI有4种工作模式</p>
<ul>
<li><strong>时钟极性</strong>有高电平、低电平两种</li>
<li><strong>时钟相位</strong>有两个：时钟相位0和时钟相位1</li>
</ul>
</li>
<li><p>时钟极性（CPOL：Clock Polarity）：</p>
<ul>
<li>时钟极性为低电平时：空闲时时钟（SCK）处于低电平，传输时跳到高电平</li>
<li>时钟极性为高电平时：空闲时时钟（SCK）处于高电平，传输时跳到低电平</li>
</ul>
</li>
<li><p>时钟相位（CPHA：Clock Phase）：</p>
<ul>
<li>当CPHA为0时，时钟周期的前一边缘采集数据</li>
<li>当CPHA为1时，时钟周期的后一边缘采集数据</li>
</ul>
</li>
</ul>
<h1 id="I2C接口基本原理与结构"><a href="#I2C接口基本原理与结构" class="headerlink" title="I2C接口基本原理与结构"></a>I<sup>2</sup>C接口基本原理与结构</h1><ul>
<li><p>I<sup>2</sup>C BUS（Inter Integrated Circuit BUS，内部集成电路总线）是由Philips公司推出的二线制串行扩展总线，用于连接微控制器及其外围设备</p>
<ul>
<li>I<sup>2</sup>C总线是具有总线仲裁和高低速设备同步等功能的高性能多主机总线</li>
<li>直接用导线连接设备，通信时无需片选信号</li>
<li>I<sup>2</sup>C总线的协议层包含物理层和数据链路层。物理层有两根信号线，在链路层每个连接到I<sup>2</sup>C总线上的设备都有唯一的地址</li>
</ul>
</li>
<li><p>在I<sup>2</sup>C总线上，物理层只需要两条线——串行数据SDA线、串行时钟SCL线，它们用于总线上器件之间的信息传递</p>
<ul>
<li>SDA和SCL都是双向的</li>
<li>每个器件都有一个唯一的地址以供识别，而且各器件都可以作为一个发送器或接收器（由器件的功能决定）<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240911190823.png" alt="IIC接线"></li>
</ul>
</li>
<li><p>I<sup>2</sup>C总线有4种操作模式</p>
<ul>
<li>主发送模式</li>
<li>主接受模式</li>
<li>从发送模式</li>
<li>从接受模式</li>
</ul>
</li>
<li><p>I<sup>2</sup>C的启动信号</p>
<ul>
<li>当I<sup>2</sup>C接口处于从模式时，想要数据传输，必须检测SDA线上的启动信号，启动信号由主器件产生</li>
<li>在SCL信号为高时，SDA产生一个由高变低的电平变化，即产生一个启动信号</li>
<li>当I<sup>2</sup>C总线上产生了启动信号后，那么这条总线就被发出启动信号的主器件占用了，变成“忙”状态</li>
</ul>
</li>
<li><p>I<sup>2</sup>C的停止信号</p>
<ul>
<li>在SCL信号为高时，SDA产生一个由低变高的电平变化，产生停止信号</li>
<li>停止信号也由主器件产生，作用是停止与某个从器件之间的数据传输</li>
<li>当I<sup>2</sup>C总线上产生了一个停止信号后，那么在几个时钟周期之后总线就被释放，变成“闲”状态<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240911190747.png" alt="IIC启动和停止信号"></li>
</ul>
</li>
<li><p>主器件产生一个启动信号后，会立即送出一个从地址，用来通知将与它进行数据通信的从器件</p>
<ul>
<li>1个字节的地址包括7位的地址信息和1位的传输方向指示位（R&#x2F;W’）</li>
<li>如果第7位为“0”，表示主机发送数据（W’），即进行一个写操作</li>
<li>如果为“1”，表示主机接收数据（R），即进行一个读操作</li>
</ul>
</li>
<li><p>数据传输格式<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240911190835.png" alt="IIC数据传输格式"></p>
<ul>
<li>SDA线上传输的每个字节长度都是8位，每次传输中字节的数量是没有限制的</li>
<li>在起始条件后面的第一个字节是地址域，之后每个传输的字节后面都有一个应答（ACK）位（即一帧共有9位）</li>
<li>传输中串行数据的MSB（字节的高位）首先发送</li>
</ul>
</li>
<li><p>应答信号</p>
<ul>
<li>为了完成1个字节的传输操作，接收器应该在接收完1个字节之后发送ACK位到发送器，告诉发送器，已经收到了这个字节</li>
<li>ACK脉冲信号在SCL线上第9个时钟处发出（前面8个时钟完成1个字节的数据传输，SCL上的时钟都是由主器件产生的）</li>
<li>当发送器要接收ACK脉冲时，应该释放SDA信号线，即将SDA置高</li>
<li>接受器在接受完前面8位数据后，将SDA拉低</li>
<li>发送器探测到SDA为低，就认为接收器成果接收了前面的8位数据</li>
</ul>
</li>
<li><p>总线竞争的仲裁</p>
<ul>
<li>I<sup>2</sup>C总线上可以挂接有多个器件，有时会发生两个或多个主器件同时向占用总线的情况</li>
<li>I<sup>2</sup>C总线具有多主控能力，可对发生在SDA线上的总线竞争进行仲裁</li>
<li>仲裁原则：当多个主器件同时想占用总线时，如果某个主器件发送高电平，而另一个主器件发送低电平，则发送电平与此时SDA总线电平不符的那个器件将自动关闭其输出级</li>
</ul>
</li>
<li><p>总线竞争的仲裁在两个层次上进行的</p>
<ul>
<li>首先是地址位的比较，如果主器件寻址同一个从器件，则进入数据位的比较，从而确保了竞争仲裁的可靠性</li>
<li>由于是利用I<sup>2</sup>C总线上的信息进行仲裁，不会造成信息的丢失</li>
</ul>
</li>
<li><p>I<sup>2</sup>C总线的数据传输过程：</p>
<ol>
<li>开始：主设备产生启动信号，表明数据传输开始</li>
<li>地址：主设备发送地址信息，包含7位的从设备地址和1位的数据方向指示位（读或写位，表示数据流的方向）</li>
<li>数据：根据指示位，数据在主设备和从设备之间进行传输。数据一般以8位传输，MSB先传；具体能传输多少量的数据并没有限制。接收器产生1位的ACK（应答信号）表明收到了每个字节。传输过程中可以被中止和重新开始</li>
<li>停止：主设备产生停止信号，结束数据传输</li>
</ol>
</li>
</ul>
<h1 id="网络接口"><a href="#网络接口" class="headerlink" title="网络接口"></a>网络接口</h1><h2 id="以太网接口基本原理与结构"><a href="#以太网接口基本原理与结构" class="headerlink" title="以太网接口基本原理与结构"></a>以太网接口基本原理与结构</h2><ul>
<li><p>以太网（Ethernet）是目前应用最广泛的局域网通讯方式，同时也是一种协议</p>
</li>
<li><p>以太网协议定义了一系列软件和硬件标准，从而将不同的设备连接在一起</p>
</li>
<li><p>嵌入式系统通常使用的以太网协议是IEEE802.3标准，以太网接口电路主要由媒质接入控制MAC控制器和物理层接口（Physical Layer，PHY）两大部分构成</p>
</li>
<li><p>在802.3版本的标准中，没有采用直接的二进制编码（即用0V表示“0”，用5V表示“1”），而是采用</p>
<ul>
<li>曼彻斯特编码（Manchester Encoding）</li>
<li>差分曼彻斯特编码（Differential Manchester Encoding）<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240911190842.png" alt="曼彻斯特编码"></li>
</ul>
</li>
<li><p>曼彻斯特编码的规律：每位中间有一个电平跳变，从高到低的跳变表示“0”，从低到高的跳变表示“1”</p>
</li>
<li><p>差分曼彻斯特编码的规律：每位的中间有一个电平跳变，但不用这个跳变来表示数据，而是利用每个码元<strong>开始时</strong>有无跳变来表示“0”或“1”，有跳变表示“0”，无跳变表示“1”（保持性）</p>
</li>
<li><p>曼彻斯特编码和差分曼彻斯特编码相比，前者编码简单，后者能提供更好的噪声抑制性能</p>
</li>
<li><p>802.3 Mac层的以太网的物理传输帧如表所示</p>
<table>
<thead>
<tr>
<th>PR</th>
<th>SD</th>
<th>DA</th>
<th>SA</th>
<th>TYPE</th>
<th>DATA</th>
<th>PAD</th>
<th>FCS</th>
</tr>
</thead>
<tbody><tr>
<td>56位</td>
<td>8位</td>
<td>48位</td>
<td>48位</td>
<td>16位</td>
<td>不超过1500字节</td>
<td>可选</td>
<td>32位</td>
</tr>
</tbody></table>
<ul>
<li><p>PR：同步位，用于收发双方的时钟同步，同时也指明了传输的速率，是56位的二进制数101010101010…，最后两位是10</p>
</li>
<li><p>SD：分隔符，表示下面跟着的是真正的数据而不是同步时钟，为8位的10101011</p>
</li>
<li><p>DA：目的地符，以太网的地址为48位二进制地址，表明该帧传输给哪个网卡。如果为FFFFFFFFFFFF，是广播地址。广播地址的数据可以被任何网卡接收到</p>
</li>
<li><p>SA：源地址，48位，表明该帧的数据是哪个网卡发的，即发送端的网卡地址，是6个字节</p>
</li>
<li><p>TYPE：类型手段，表明该帧的数据是什么类型的数据，不同协议的类型字段不同。如：0800H表示数据为IP包，0806H表示数据为ARP包，814CH是SNMP包，8137H为IPX&#x2F;SPX包</p>
</li>
<li><p>DATA：数据段，该段数据不能超过1500B。以太网规定整个传输包的最大长度不能超过1514B（14B为DA，SA，TYPE）</p>
</li>
<li><p>PAD：填充位。以太网帧传输的数据包最小不能小于60B（除去DA、SA、TYPE的14B），还必须传输64B的数据，当数据段的数据不足46B时，后面通常是补0（也可以补其他值）</p>
</li>
<li><p>FCS：32位数据校验位。32位的CRC校验，该校验由网卡自动计算，自动生成，自动校验，自动在数据段后面填入。不需要软件还礼</p>
</li>
<li><p>通常PR、SD、PAD、FCS数据段是网卡（包括物理层和Mac层的处理）自动产生的，剩下的DA、SA、TYPE、DATA4个段的内容由上层软件控制</p>
</li>
</ul>
</li>
<li><p>以太网数据传输的特点</p>
<ul>
<li>所有数据位的传输由低位开始，传输的位流用曼彻斯特编码</li>
<li>以太网是基于冲突检测的总线复用方法，冲突退避算法是由硬件自动执行</li>
<li>以太网传输的数据段的长度，DA+SA+TYPE+DATA+PAD最小为60B，最大为1514B</li>
<li>通常的以太网卡可以接受3种地址的数据：广播地址、多播地址（或者叫组播地址，在嵌入式系统中很少用到）、自己的地址。但有时，用于网络分析和监控，网卡也可以设置为接受任何数据包</li>
<li>任何两个网卡的物理地址都是不一样的，是世界上唯一的，网卡地址由专门机构分配。不同厂家使用不同地址段，同一厂家的任何两个网卡的地址也是唯一的。根据网卡的地址段（网卡地址的前3个字节）可以知道网卡的生产厂家</li>
</ul>
</li>
<li><p>嵌入式以太网接口实现的方法</p>
<ul>
<li><p>嵌入式处理器+网卡芯片</p>
<ul>
<li>把以太网芯片连接到嵌入式处理器的总线上</li>
<li>通用性强，对嵌入式处理器没有特殊要求，不受处理器的限制，但是，嵌入式处理器和网络数据交换通过外部总线（通常是并行总线）交换数据，速度慢，可靠性不高，电路板走线复杂</li>
<li>目前常见的以太网接口芯片，如CS8900，RTL8019&#x2F;8029&#x2F;8039、DM9008及DWL650无线网卡等</li>
</ul>
</li>
<li><p>带有以太网接口的嵌入式处理器</p>
<ul>
<li>带有以太网接口的嵌入式处理器通常是面向网络应用而设计的，要求嵌入式处理器有通用的网络接口（比如：MII接口）</li>
<li>处理器和网络数据交换通过内部总线，速度快</li>
</ul>
</li>
</ul>
</li>
<li><p>网络编程接口</p>
<ul>
<li><p>BSD套接字（BSD Sockets）是使用的最广泛的网络程序编程方法</p>
<ul>
<li>主要用于应用程序的编写，用于网络上主机与主机之间的相互通信</li>
<li>很多操作系统都支持BSD套接字编程。例如，UNIX、Linux、VxWorks、Windows的Winsock基本上是来自BSD Sockets</li>
</ul>
</li>
<li><p>套接字（Sockets）分为Stream Sockets和Data Sockets</p>
<ul>
<li>Stream Sockets是可靠性的双向数据传输，对应使用TCP协议传输数据</li>
<li>Data Sockets是不可靠连接，对应使用UDP协议传输数据<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240911190918.png" alt="网络编程接口"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="CAN总线接口基本原理与结构"><a href="#CAN总线接口基本原理与结构" class="headerlink" title="CAN总线接口基本原理与结构"></a>CAN总线接口基本原理与结构</h2><ul>
<li><p>Can（Controller Area Network，控制器局域网）是德国Bosch公司与1983年为汽车应用而开发的，它是一种现场总线（FieldBus），能有效支持分布式控制和实时控制的串行通信网络。1993年11月，ISO正式颁布了控制器局域网CAN国际标准（ISO11898）</p>
</li>
<li><p>CAN总线是一种多主方式的串行通信总线</p>
<ul>
<li>理想的由CAN总线构成的单一网络中，是可以挂接任意多个节点，实际应用中节点数目受网络硬件的电气特性所限制。例如：当使用Philips P82C250作为CAN收发器时，同一网络中允许挂接110个节点。</li>
<li>CAN总线具有很高的实时性能，已经在汽车工业、航空工业、工业控制、安全防护等领域得到了广泛应用。</li>
</ul>
</li>
<li><p>CAN总线的通信介质可采用双绞线、同轴电缆和光导纤维，最常用的是双绞线</p>
<ul>
<li>通信距离与波特率有关，最大通信距离可达10km，最大通信波特率可达1Mbps</li>
<li>CAN总线仲裁采用11位标识和非破坏性位仲裁总线结构机制，可以确定数据块的优先级，保证在网络节点冲突时最高优先级结点不需要冲突等待</li>
<li>CAN总线采用了多主竞争式总线结构，具有多主站运行和分散仲裁的串行总线以及广播通信的特点</li>
<li>CAN总线上任意结点可在任意时刻主动向网络上其他节点发送信息而不分主次，因此可在各节点之间实现自由通信</li>
</ul>
</li>
<li><p>CAN总线信号使用差分电传送</p>
<ul>
<li>两条信号线被称为CAN_H和CAN_L，静态时均是2.5V左右，此时状态表示为逻辑1，也可以叫作“隐性”</li>
<li>采用CAN_H比CAN_L高表示逻辑0，称为“显性”，通常电压值为CAN_H&#x3D;3.5V和CAN_L&#x3D;1.5V</li>
<li>当“显性”位和“隐性”位同时发送的时候，最后总线数值将为“显性”</li>
<li>这种特性为CAN总线的仲裁奠定了基础</li>
</ul>
</li>
<li><p>一些面向工业控制的嵌入式处理器集成了一个或者多个CAN总线控制器</p>
<ul>
<li>例如：Phillips公司的LPC2194和LPC2294（ARM7TDMI内核）带有4个CAN总线控制器</li>
<li>CAN总线控制器主要是完成时序逻辑转换等工作，要在电气特性上满足CAN总线标准，还需要一个CAN总线的物理层芯片，用它来实现TTL电平到CAN总线电平特性的转换，即CAN收发器<br> <img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240912093355.png" alt="image-20240912093354492"></li>
</ul>
</li>
<li><p>实际上，多数嵌入式处理器都不带CAN总线控制器</p>
<ul>
<li>通常的解决方案是在嵌入式处理器的外部总线上扩展CAN总线接口芯片</li>
<li>例如：Phillips公司的<strong>SJA1000</strong> CAN总线接口芯片，Microchip公司的MCP251x系列（<strong>MCP2510</strong>和MCP2515）CAN总线接口芯片，这两种芯片都支持CAN2.0B标准</li>
</ul>
</li>
<li><p>SJA 1000的总线采用的是地址线和数据线复用的方式，多数嵌入式处理器采用SJA 1000扩展CAN总线较为复杂</p>
</li>
<li><p>MCP2510是由Microchip公司产生的CAN协议控制器，完全支持CAN总线V2.0A&#x2F;B技术规范</p>
<ul>
<li>0~8字节的有效数据长度，支持远程帧</li>
<li>最大1Mb&#x2F;s的可编程波特率</li>
<li>两个支持过滤器（Filter，Mask）的接收缓冲区，三个发送缓冲区</li>
<li>支持回环（Loop Back）模式，便于测试</li>
<li>SPI高速串行总线，最大5MHz</li>
<li>3V到5.5V供电</li>
</ul>
</li>
<li><p>大多数嵌入式处理器都有SPI总线控制器，MCP2510可以3V到5.5V供电，能够直接和3.3V I&#x2F;O口的嵌入式处理器连接，电路原理图如图所示<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240912094844.png" alt="image-20240912094843626"></p>
</li>
<li><p>MCP2510使用3.3V电压供电，可以直接和三星S3C44B0X处理器通过SPI总线连接。相关的资源如下：<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240912162932.png" alt="CAN扩展原理图"></p>
<ul>
<li>使用一个扩展的I&#x2F;O口（EXIO2）作为片选信号，低电平有效</li>
<li>用S3C2410A的外部中断6（EXINT6）作为中断管脚，低电平有效</li>
<li>16MHz晶体作为输入时钟，MCP2510内部有振荡电路，用晶体可以直接起振使用TJA1050作为CAN总线收发器</li>
</ul>
</li>
<li><p>CAN总线收发器TJA1050必须使用5V供电。MCP2510和TJA1050连接的两个信号都是单向的信号。需单向满足I&#x2F;O口的电气特性</p>
<ul>
<li>从MCP2510输出的TXCAN信号是否满足TJA1050的输入电平。TJA1050为5V供电时，输入高电平V<sub>ih</sub>的范围是2~5.3V。而3.3V供电的MCP2510输出TXCAN信号高电平V<sub>oh</sub>最小值为2.6V，可以满足要求</li>
<li>从TJA1050输出的RXD信号是否满足MCP2510的输入电平。3.3V供电的MCP2510输入信号RXCAN高电平范围V<sub>ih</sub>：2~4.3V，无法满足5V逻辑的TJA1050输出电平——电阻分压实现单向电平转换</li>
</ul>
</li>
<li><p>分压电阻值的选择，需要考虑两个问题</p>
<ul>
<li>TJA1050输出信号的驱动能力（输出电流&lt;&#x3D;15mA）</li>
<li>MCP2510的RXCAN管脚的输入阻抗（输入电流&lt;&#x3D;5μA）</li>
</ul>
</li>
</ul>
<h2 id="无线以太网基本原理与结构"><a href="#无线以太网基本原理与结构" class="headerlink" title="无线以太网基本原理与结构"></a>无线以太网基本原理与结构</h2><ul>
<li>WLAN（Wireless Local Area Network，无线局域网）是利用无线通信技术在一定的局部范围内建立的，是计算机网络与无线通信技术相结合的产物，以无线多址通道作为传输媒介，提供有线局域网的功能</li>
<li>传输介质<ul>
<li>红外线IR</li>
<li>射频RF波段</li>
</ul>
</li>
<li>WLAN的标准：主要是针对物理层和媒质访问控制层（MAC层）。涉及到所有使用的无线频率范围、控制接口通信协议等技术规范和技术标准<ul>
<li>802.11原始标准（2Mbps，2.4GHz）办公室、校园局域网</li>
<li>802.11b物理层补充（11Mbps，2.4GHz）办公室、家庭、宾馆、车站、机场等场合</li>
<li>802.11a物理层补充（54Mbps，5.2GHz）话音、数据和图像</li>
<li>802.11g物理层补充（54Mbps，2.4GHz）传输速率和安全性</li>
<li>802.11h无线覆盖半径的调整（室内和室外信道，5.2GHz）</li>
</ul>
</li>
</ul>
<h2 id="1394接口基本原理与结构"><a href="#1394接口基本原理与结构" class="headerlink" title="1394接口基本原理与结构"></a>1394接口基本原理与结构</h2><ul>
<li><p>IEEE 1394是Apple公司率先提出的一种高品质、高传输速率的串行总线技术，1995年被IEEE认定为串行工业总线标准</p>
<ul>
<li>1394作为一种标准总线，可以在不同的工业设备之间架起一座沟通的桥梁</li>
<li>在一条总线上可以接入63个设备</li>
<li>实时多媒体领域。大容量存储以及打印机、扫描仪上等等</li>
<li>IEEE1394规范仅支持64位固定解址模式</li>
</ul>
</li>
<li><p>支持多种总线速度，适应不同应用要求</p>
<ul>
<li>IEEE 1394a：100Mb&#x2F;s、200Mb&#x2F;s、400Mb&#x2F;s</li>
<li>IEEE 1394b：800Mb&#x2F;s、1600Mb&#x2F;s、3200Mb&#x2F;s</li>
</ul>
</li>
<li><p>支持热插拔</p>
<ul>
<li>设备的资源均由总线控制器自动分配</li>
<li>总线控制器会自动重新配置好设备</li>
</ul>
</li>
<li><p>接口有两种类型</p>
<ul>
<li>6针的六角形接口和4针的小型四角形接口</li>
<li>6针的六角形接口可向所连接的设备供电，而4针的四角形接口则不能</li>
</ul>
</li>
<li><p>支持同步和异步两种传输方式</p>
<ul>
<li>设备可以根据需要动态地选择传输方式，总线自动完成带宽分配</li>
<li>要求实时传输并对数据的完整性要求不严格的场合，可采用同步传输方式</li>
<li>对数据完整性要求较高的场合，采用异步传输的方式更好</li>
</ul>
</li>
<li><p>支持点到点通信模式，IEEE 1394是多主总线，每个设备均可以获取总线的控制权，与其他设备进行通信</p>
</li>
<li><p>两种传输方式：Backplane模式和Cable模式</p>
<ul>
<li>Backplane模式最小的速率也比USB1.1最高速率高，分别为12.5Mbps&#x2F;s、25Mbps&#x2F;s、50Mbps&#x2F;s，可以用于多数的高带宽应用</li>
<li>Cable模式是速度非常快的模式，分为100Mbps&#x2F;s、200Mbps&#x2F;s和400Mbps&#x2F;s几种，在200Mbps&#x2F;s下可以传输不经压缩的高质量数据电影</li>
</ul>
</li>
<li><p>遵循ANSIIEEE 1212控制及状态寄存器（CSR）标准，定义了64位的地址空间。可寻址1024条总线的63个节点，每个节点可包含256TB的内存空间</p>
</li>
<li><p>支持较远距离的传输</p>
<ul>
<li>普通线缆：2个设备之间的最大距离可达4.5m（高级线缆可达15m）</li>
<li>玻璃光缆或5类双绞线：设备间距离可达100m以上</li>
</ul>
</li>
<li><p>支持公平仲裁原则，为每一种传输方式保证足够的传输带宽，支持错误检测和处理</p>
</li>
<li><p>六线电缆具有电源线，可传输8~40V的直流电压</p>
<ul>
<li>2对双绞线：信号传递</li>
<li>1对双绞线：供应电源</li>
</ul>
</li>
<li><p>IEEE1394的协议栈由3层组成：物理层、链路层和事物层，另外还有一个管理层<img src="https://gitee.com/Ascendlogo/note-pic/raw/master/img/20240912162855.png" alt="1394"></p>
<ul>
<li>物理层和链路层由硬件构成，通常集成在同一块芯片上</li>
<li>事务层主要由软件实现</li>
</ul>
</li>
<li><p>物理层提供IEEE1394的电气和机械接口，功能是重组字节流并将它们发送到目的节点上去</p>
<ul>
<li>物理层为链路层提供服务</li>
<li>解析字节流并发送数据包给链路层</li>
</ul>
</li>
<li><p>链路层提供了给事务层确认的数据服务，包括：寻址、数据组帧和数据校验</p>
<ul>
<li>提供直接面向应用的服务</li>
<li>支持同步和异步传输模式</li>
<li>链路层的底层提供了仲裁机制</li>
</ul>
</li>
<li><p>事务层为应用提供服务</p>
<ul>
<li>只支持异步传输</li>
<li>定义了3种基于请求响应的服务：read、write、lock</li>
<li>即是将发送者的数据送往接受者；读即是将有关数据返回到发送者；锁定即是写、读指令功能的组合</li>
</ul>
</li>
<li><p>管理层定义了一个管理节点所使用的所有协议、服务以及进程</p>
<ul>
<li>电缆环境下，IEEE 1394定义了2类管理：总线管理（BM）和同步资源管理（IRM）</li>
<li>总线管理（BM）：总线的电源管理信息、拓扑结构信息、不同节点的速度极限信息，一遍协调不同速度设备之间的通信</li>
<li>同步资源管理（IRM）：管理同步资源，如：可用频道信息、带宽的分配</li>
</ul>
</li>
</ul>
<h1 id="总线分类"><a href="#总线分类" class="headerlink" title="总线分类"></a>总线分类</h1><h2 id="内部总线"><a href="#内部总线" class="headerlink" title="内部总线"></a>内部总线</h2><ul>
<li>说明：内部总线是微机内各外围芯片与处理器之间的总线，用于芯片一级的互连</li>
<li>常用总线：I<sup>2</sup>总线、SPI总线、SCI总线等</li>
</ul>
<h2 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h2><ul>
<li>说明：系统总线是微机中各插件板与系统板之间的总线，用于插件板一级的互连</li>
<li>常用总线：ISA总线、EISA总线、VESA总线、PCI总线</li>
</ul>
<h2 id="外部总线"><a href="#外部总线" class="headerlink" title="外部总线"></a>外部总线</h2><ul>
<li>说明：外部总线则是微机和外部设备之间的总线，微机作为一种设备，通过该总线和其他设备进行信息与数据交换，它用于设备一级的互连</li>
<li>常用总线：RS232、RS485、USB总线、IEEE1394总线等</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>好人与坏人</title>
    <url>/2023/03/26/%E6%82%9F/%E5%A5%BD%E4%BA%BA%E4%B8%8E%E5%9D%8F%E4%BA%BA/</url>
    <content><![CDATA[<p>在这个世界上没有绝对的好人，也没有绝对的坏人。<br>在一个长的时间限度内，你好事比坏事做的多就是好人，坏事做得比好事多也就成了坏人。<br>所以不必自困于过去的遗憾，做到今天的自己问心无愧就好。<br>但行好事耳。</p>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>勇气</title>
    <url>/2023/12/29/%E6%82%9F/%E5%8B%87%E6%B0%94/</url>
    <content><![CDATA[<ul>
<li>人唯有把自己逼进万劫不复的险境，才能获得向死而生的勇气。</li>
<li>人得以不断发展的重要动力是灰暗的生活与光明的未来之间的矛盾。</li>
<li>勇敢的人先享受世界。</li>
<li>人生的分界线就在这里，跨过这一步就是英雄，退回这一步就是懦夫。</li>
</ul>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>5KM哲学</title>
    <url>/2023/03/26/%E6%82%9F/5KM%E5%93%B2%E5%AD%A6/</url>
    <content><![CDATA[<p>当我跑5km时，前1km是毫无压力的，因为刚刚开始跑，感觉不到累。<br>最后500米也是可以肆无忌惮地冲刺的，因为我知道跑完这500米完就可以休息了，不用担心接着跑会坚持不下来。<br>而中间的3.5km是十分枯燥的，总是在思考还有多久能休息，再跑心脏会不会承担不了等等问题。可能会感觉到喘不过来气，可能会想要放弃，可能会感觉看不见终点在哪里。</p>
<p>人生也是如此，绝大多数光景我们都在这3.5km中活着，眼前只有一个不太真实可触的目标，身体十分疲惫，心理也承担着巨大的压力。感觉一直在做事情，却难以接近那个遥不可及又充满神秘的未来。</p>
<p>困难的地方在于我们只能也必须跑下去，幸运的地方在于我们还可以跑下去，并且有人到达过终点。</p>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>目标</title>
    <url>/2023/05/15/%E6%82%9F/%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<p>有些事情我今天没去做，明天更不会做。<br>有些书我这个月没读，下个月更不会读。<br>有些目标我今年没达成，明年更不会达成。<br>有些成功我年轻没取得，年老也不会实现。</p>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>自律</title>
    <url>/2023/07/02/%E6%82%9F/%E8%87%AA%E5%BE%8B/</url>
    <content><![CDATA[<ul>
<li>自律就像是用气球包住了无数的欲望。这个气球会越来越大越来越大，随时都无比接近爆炸。但是只要自律还在，气球就不会爆炸。</li>
<li>愈是沉迷什么，就愈要远离什么。你只能臣服于一种东西，那就是对自己强大的控制力。</li>
</ul>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>时间</title>
    <url>/2023/07/01/%E6%82%9F/%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p>把时间放到更有意义的事情上，是一种延长生命的行为。</p>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>《明朝那些事》</title>
    <url>/2024/11/05/%E6%9C%AD/%E3%80%8A%E6%98%8E%E6%9C%9D%E9%82%A3%E4%BA%9B%E4%BA%8B%E3%80%8B/</url>
    <content><![CDATA[<ul>
<li>知道可能面对的困难和痛苦，在死亡的恐惧中不断挣扎，却仍然能战胜自己，选择这条道路，才是真正的勇气。</li>
<li>一个人要显示自己的力量，从来不是靠暴力，挑战这一准则的人必然会被历史从强者的行列中淘汰，历来如此。</li>
</ul>
]]></content>
      <categories>
        <category>札</category>
      </categories>
  </entry>
  <entry>
    <title>忧思</title>
    <url>/2023/11/25/%E6%82%9F/%E5%BF%A7%E6%80%9D/</url>
    <content><![CDATA[<ul>
<li>睿智，得乎静；刚勇，显与动。是故大丈夫处世，必忧思以深远，行决以神速，孤心磨砺以求成也。</li>
<li>万事万物各行其道我又何必庸人自扰。</li>
<li>去寻找全局最优解，而不是局部最优解。</li>
<li>伟人之所以伟大，只是因为我们跪在地上，站起来吧！</li>
<li>先不不喜欢的事情做好才能去做喜欢的事。</li>
<li>故天将降大任于是人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</li>
<li>熬过每一个今天，成功自然会来。</li>
<li>我们能够掌控的是能力，我们无法掌控的是机遇。没有机遇你展现不了能力，没有能力你抓不住机遇。我们能做的只有提升能力，抓住机遇。</li>
<li>成功或失败是上天决定的，前进或停下是我决定的。命定但不注定。</li>
<li>从无所不能，到无所能，到有所能。循此苦旅，以达天际。</li>
</ul>
]]></content>
      <categories>
        <category>悟</category>
      </categories>
  </entry>
  <entry>
    <title>《毛泽东选集》</title>
    <url>/2024/07/09/%E6%9C%AD/%E3%80%8A%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86%E3%80%8B/</url>
    <content><![CDATA[<ul>
<li>他们站在一切人之上——之前站在一切人之下，所以叫做反常。</li>
<li>今天的暂时的妥协，即酝酿着明天的更大的战争。</li>
</ul>
]]></content>
      <categories>
        <category>札</category>
      </categories>
  </entry>
  <entry>
    <title>C语言学习笔记</title>
    <url>/2021/06/15/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="程序设计与C语言"><a href="#程序设计与C语言" class="headerlink" title="程序设计与C语言"></a>程序设计与C语言</h1><h2 id="计算机与编程语言"><a href="#计算机与编程语言" class="headerlink" title="计算机与编程语言"></a>计算机与编程语言</h2><ul>
<li><p>编程语言不是人与计算机交谈的语言，而是以计算机可理解方式对解决问题的步骤进行描述</p>
</li>
<li><p>不同算法可以影响计算机运算速度（如限定条件）</p>
</li>
<li><p>执行方式：</p>
<ul>
<li>解释：借助一个程序，此程序指导计算机进行操作运行“目的程序”（可以理解“目的程序”）</li>
<li>编译：借助一个程序，此程序对目的程序进行翻译，来让计算机执行</li>
<li><strong>有的程序语言既可以编译执行也可以解释执行</strong></li>
</ul>
</li>
</ul>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><ul>
<li>程序框架</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&quot;&quot;</code>里面的内容叫做<code>&quot;字符串&quot;</code>，<code>printf</code>会把其中的内容原封不动地输出</p>
</li>
<li><p><code>\n</code>表示再输出的结果后面换一行</p>
</li>
</ul>
<h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>在按下回车键前，程序不会得到输入</p>
</li>
<li><p>定义变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  price = <span class="number">0</span>；</span><br><span class="line"><span class="comment">// 类型 名字  赋值 初始值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>变量是一个保存数据的地方，变量只有保存数据才能参与计算</p>
</li>
<li><p>变量定义的一般形式：&lt;类型名称&gt;&lt;变量名称&gt;</p>
</li>
<li><p>变量名称（标识符）：只能由字母、数字、下划线组成。数字不可以出现在第一个位置。C语言关键字（保留字）不可作标识符。</p>
</li>
<li><p>C语言保留字：</p>
</li>
</ul>
<blockquote>
<p>auto; break; case; char; const; continue; default; double; do; else; enum; extern; float; for; goto; if; int; long; register; return; short; signed; sizeof; static; struct; switch; typedef; union; unsigned; void; volatile; while; inline; restrict</p>
</blockquote>
<ul>
<li>变量在被使用之前应当初始化（被赋值）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化：&lt;类型名称&gt;&lt;变量名称&gt;=&lt;初始化&gt;</span></span><br><span class="line"><span class="type">int</span> price = <span class="number">0</span>；</span><br><span class="line"><span class="type">int</span> price = <span class="number">0</span>，amount = <span class="number">100</span>；</span><br></pre></td></tr></table></figure>

<ul>
<li><p>C语言是一种有类型的语言。且程序执行过程中变量类型不可改变。</p>
</li>
<li><p><code>printf</code>输出函数</p>
<p><code>scanf</code>输入函数：</p>
<ul>
<li><strong>加&amp;在变量名称前</strong></li>
<li>出现在<code>scanf</code>的格式字符串里面的东西是它一定要输出的东西（空格、回车、制表符均指空白字符）</li>
</ul>
</li>
<li><p>固定不变的数是常数，直接写在程序里称为直接量。</p>
</li>
<li><p><code>const</code>为修饰符，在<code>int</code>之前，表示不变的属性，表示这变量的值一旦初始化无法修改（全大写）</p>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>10和10.0不同</p>
<p>10为整数 10.0为浮点数</p>
</li>
<li><p>两个整数的计算结果只能是整数（去尾法保留），整数与浮点数运算时整数将变为浮点数</p>
</li>
</ul>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><ul>
<li><p>一个表达式是一系列运算符和算子的组合，用来计算一个值。</p>
<p><code>count = count + 1</code></p>
</li>
<li><p>运算符指进行运算的动作；算子指参与运算的值。</p>
<p>+；-；sizes &#x3D; 7</p>
<p>%表示取两个数相除以后的余数</p>
</li>
<li><p>运算符优先级</p>
</li>
</ul>
<blockquote>
<p>1 	+ - 	单目（只有一个算子）不变 自右向左 	a*-b a*+b</p>
<p>2 	* &#x2F; % </p>
<p>3 	+ -</p>
<p>4 	&#x3D;       赋值       自右向左  	a &#x3D; b</p>
</blockquote>
<ul>
<li><p>断点：让程序运行过程中暂停</p>
</li>
<li><p><code>total += 5</code>；等价于 <code>total = total + 5</code></p>
</li>
<li><p>两个运算符之间不留空格</p>
</li>
<li><p>符合赋值：+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;</p>
</li>
<li><p><code>total /= a + b</code> 等价于<code>total = total /（a + b）</code></p>
</li>
<li><p>++和–是单目运算符，且算子必须是变量（不能5++或++5），称作递增和递减，作用为为变量+1或-1，<strong>后缀a++<strong>代表a加1以</strong>前</strong>的值，<strong>前缀++a</strong>代表<strong>a加1以后</strong>的值。若a &#x3D; 10则<code>a++</code> &#x3D; 10，<code>++a</code> &#x3D; 11，a&#x3D;11</p>
</li>
<li><p><code>INC</code>：递增</p>
<p><code>DEC</code>：递减</p>
</li>
</ul>
<h1 id="判断与循环"><a href="#判断与循环" class="headerlink" title="判断与循环"></a>判断与循环</h1><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><ul>
<li><p>if常用框架</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>if</code>语句中条件的逻辑表达式若为<code>true</code>，则执行大括号中的语句，反之不执行</p>
</li>
<li><p>&#x3D;&#x3D;相等；!&#x3D;不相等 ；&gt;大于； &gt;&#x3D;大于或等于；&lt;小于；&lt;&#x3D;小于或等于</p>
</li>
<li><p>关系运算的结果成立为1，否则为0；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="number">5</span> == <span class="number">3</span>))<span class="comment">// 输出0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关系运算符优先级小于算术运算，大于赋值运算</p>
</li>
<li><p>判断是否相等关系运算低于其他关系运算</p>
</li>
<li><p><code>a  == b == c</code>：0&#x2F;1与c比较</p>
</li>
<li><p>以&#x2F;&#x2F;开头的语句将程序分开进行注释，为人类读者提供解释信息，对程序无影响，或以&#x2F;*到*&#x2F;</p>
</li>
<li><p><code>else</code>：否则的话 <code>else&#123;&#125;</code></p>
</li>
<li><p><code>if()</code>后不加<code>;</code>因为语句并没与结束</p>
</li>
<li><p><code>if</code>、<code>else</code>后若没有{}则只读其后一个语句</p>
</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul>
<li><p>计算机内最高能输入的整数为10位数</p>
</li>
<li><p><code>while</code>：当条件满足时，不断重复循环体内的语句。循环可能执行一次，也可能不执行</p>
</li>
<li><p><code>do-while</code>：进入循环时不检查，执行完一轮循环代码之后再判断循环条件</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">&lt;循环体语句&gt;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(&lt;循环条件&gt;)；<span class="comment">// 注意分号</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>for（初始条件；循环继续的条件（判断式）；循环每轮要进行的动作（累加器））</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (count = <span class="number">10</span>; count &gt; <span class="number">0</span>; count--)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于一开始的<code>count = 10</code>，当<code>count &gt; 0</code>时，重复做循环体，每一轮循环在做完循环体内语句后，使得<code>count--</code></p>
</li>
<li><p>做求和的程序时，记录结果变量初始化为0，而做求积变量时，记录结果变量初始化为1</p>
</li>
<li><p>循环的控制变量i是选择从0开始还是从1开始是判断<code>i &lt; n</code>还是判断<code>i &lt;= n</code>，对循环的次数，循环结束后变量的值都有影响。</p>
</li>
<li><p><code>for</code> &#x3D;&#x3D; <code>while</code></p>
</li>
<li><p><code>for(int i=1; i&lt;=n; i++)&#123;fact *= i&#125;</code></p>
<p>先<code>fact *= i</code>后<code>i++</code></p>
</li>
<li><p>固定次数 <code>for</code></p>
<p>必须执行一次 <code>do-while</code></p>
<p>其他情况 <code>while</code></p>
</li>
<li><p>省略循环的条件表示循环总是满足的</p>
</li>
</ul>
<h1 id="进一步判断与运算"><a href="#进一步判断与运算" class="headerlink" title="进一步判断与运算"></a>进一步判断与运算</h1><h2 id="逻辑类型和运算"><a href="#逻辑类型和运算" class="headerlink" title="逻辑类型和运算"></a>逻辑类型和运算</h2><ul>
<li><p>#include&lt;stdio.h&gt; 可用<code>bool</code>，<code>true</code>，<code>false</code></p>
</li>
<li><p>逻辑运算是对逻辑量进行的运算，结果只有0或1</p>
</li>
<li><p>逻辑量是关系运算或逻辑运算的结果</p>
</li>
<li><table>
<thead>
<tr>
<th>符号</th>
<th>逻辑关系</th>
<th>表达式</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>！</td>
<td>逻辑非</td>
<td>!a</td>
<td>a true 则  !a false</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>a &amp;&amp; b</td>
<td>a、b均true为true否则false</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
<td>a || b</td>
<td>a、b均false为false否则true</td>
</tr>
</tbody></table>
</li>
<li><p>x∈(4, 6)等价于<code>x &gt; 4 &amp;&amp; x &lt; 6</code></p>
</li>
<li><p>判断字符 c是否为大&#x2F;小写字母：<code>c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;</code></p>
</li>
<li><p>逻辑运算符优先级普遍低于比较运算符，单目运算符优先级高于双目运算符（<code>!age &lt; 20</code>代表0&#x2F;1与20比较）</p>
<ol>
<li>()													自左向右（结合性） </li>
<li>！	+ - 	++ 	–						自右向左（单目+或-）</li>
<li>* &#x2F; 	%</li>
<li>+ -</li>
<li>&lt; 	&lt;&#x3D; 	&gt;	 &gt;&#x3D;</li>
<li>&#x3D;&#x3D; 	!&#x3D;</li>
<li>&amp;&amp;</li>
<li>||</li>
<li>&#x3D; 	+&#x3D; 	-&#x3D;	*&#x3D; 	&#x2F;&#x3D;	 %&#x3D;  	自右向左（结合性）</li>
</ol>
</li>
<li><p>逻辑运算自左向右进行，如果左边结果可以决定运算结果，就不会做右边的计算（短路）</p>
<p><code>a == 6 &amp;&amp; b == 1</code> <code>a == 6 &amp;&amp; b += 1</code></p>
<p>对于&amp;&amp;：左边为false则右边不做；对于||：左边为true则不做右边</p>
<p><strong>不要把赋值，包括复合赋值组合进表达式</strong></p>
</li>
<li><p>条件运算符 <code>count = (count &gt; 20) ? count - 10 : count+10</code></p>
<p>表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(count &gt; <span class="number">20</span>)</span><br><span class="line">    count = count<span class="number">-10</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    count = count+<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>条件满足时的值和条件不满足时的值</p>
</li>
<li><p>“表达式”主要在for中使用，赋予不同变量值</p>
</li>
</ul>
<h2 id="级联和嵌套的判断"><a href="#级联和嵌套的判断" class="headerlink" title="级联和嵌套的判断"></a>级联和嵌套的判断</h2><ul>
<li><p>若<code>if</code>条件判断后语句仍为<code>if</code>或<code>if - else</code>语句，则为嵌套<code>if</code>语句</p>
</li>
<li><p><code>else</code>总是与<strong>最近</strong>的<code>if</code>匹配（<strong>大括号存在时可能特殊</strong>），在<code>if</code>或<code>else</code>后面总是用<code>&#123;&#125;</code></p>
</li>
<li><p>级联的<code>if- else if</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(exp1)</span><br><span class="line">    stl1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(exp2)</span><br><span class="line">    stl2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    stl3；</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="多路分支"><a href="#多路分支" class="headerlink" title="多路分支"></a>多路分支</h2><ul>
<li><p>switch - case</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">swich(控制表达式) &#123;          </span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 常量:  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">break</span>;                </span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 常量:   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量只能是<strong>整数型</strong>结果</p>
<ul>
<li><code>int type</code>（正确）</li>
<li><code>double type</code>（错误）</li>
</ul>
</li>
<li><p>常量可为常数，或常数计算表达式（编译知道结果）</p>
</li>
<li><p><code>switch</code>可视作跳转，若<code>case后无break</code>，则执行下一个<code>case</code>，<code>case</code>不会让语句停止</p>
</li>
</ul>
<h2 id="循环的例子"><a href="#循环的例子" class="headerlink" title="循环的例子"></a>循环的例子</h2><ul>
<li><p>计算之前先保存原始的值，后面可能有用</p>
</li>
<li><p>可以用模拟较少的循环次数来推断很大次数的循环</p>
</li>
<li><p>随机数<code>rand()</code>，得到一个随机的整数函数</p>
</li>
</ul>
<h2 id="判断和循环常见的错误"><a href="#判断和循环常见的错误" class="headerlink" title="判断和循环常见的错误"></a>判断和循环常见的错误</h2><p><code>if</code>常见错误：</p>
<ul>
<li><p>忘了<code>&#123;&#125;</code></p>
</li>
<li><p><code>if</code>后面错加<code>;</code></p>
</li>
<li><p>错误地使用<code>==</code>和<code>=</code></p>
</li>
<li><p>令人困惑的<code>else</code>：</p>
<ul>
<li><code>if</code>和<code>else</code>之后加大括号</li>
<li>大括号内语句缩进一个<code>tab</code></li>
</ul>
</li>
</ul>
<h1 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h1><h2 id="循环控制-1"><a href="#循环控制-1" class="headerlink" title="循环控制"></a>循环控制</h2><ul>
<li><p>循环中可用<code>break</code>跳出循环</p>
</li>
<li><p>循环中可用<code>continue</code>跳过循环这一轮剩下语句进入下一轮</p>
</li>
</ul>
<h2 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h2><ul>
<li><p>嵌套的循环：循环里面还是循环</p>
</li>
<li><p><code>break</code>和<code>continue</code>只能对它所在的那层循环做</p>
</li>
<li><p>接力<code>break</code></p>
</li>
<li><p><code>goto</code>：<code>goto xx(符号) -&gt; xx(同上符号):</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">again:</span><br><span class="line">      语句;</span><br><span class="line">    <span class="keyword">goto</span> again;<span class="comment">//again可以替换成其他的，这里不要求一定是again</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="循环应用"><a href="#循环应用" class="headerlink" title="循环应用"></a>循环应用</h2><h1 id="数组和函数"><a href="#数组和函数" class="headerlink" title="数组和函数"></a>数组和函数</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>数组是长度固定的数据结构，用来存放指定类型的数据，所有数据的类型都相同</p>
</li>
<li><p>&lt;类型&gt;变量名称[元素类型];</p>
<p><code> int  grades  [100]</code>;  <code>double weight [20]</code>;</p>
</li>
<li><p>元素数量必须是整数；C99之前，元素数量必须是编译时刻确定的字面量</p>
</li>
<li><p>数组是一种容器：</p>
<ul>
<li><p>类型相同</p>
</li>
<li><p>一旦创建，不可改变大小</p>
</li>
<li><p>数组元素在内存中是连续依次排列的</p>
<p><code>int a[10]</code>: <code>a[0]</code>, <code>a[1]</code>, <code>a[2]</code>, … <code>a[9]</code>（10个单元）</p>
</li>
</ul>
</li>
<li><p>可以在赋值左边或右边</p>
</li>
<li><p>使用数组时放在<code>[]</code>中的数字叫下边或索引，下标从0开始计数</p>
<p><code>a[100]</code> →0~99</p>
</li>
<li><p>编译器不会检查数组是否越界，但运用到程序中可能会崩溃</p>
</li>
<li><p>长度为0的数组：<code>int a[0]</code>; 可以存在但无用</p>
</li>
</ul>
<h2 id="函数的定义和使用"><a href="#函数的定义和使用" class="headerlink" title="函数的定义和使用"></a>函数的定义和使用</h2><ul>
<li><p>函数是一块代码，接受0个或多个参数，做一件事情，并返回一个或零个值</p>
</li>
<li><p>函数头 {函数体}</p>
<p><code>void + sum(int begin, int end)</code></p>
<p>返回类型  函数名  参数表（类型+名字）</p>
</li>
<li><p>调用函数 函数名<strong>（</strong>参数值<strong>）</strong> （即使不给参数依然需要<strong>（ ）</strong>），若有参数则需要正确数量和顺序</p>
</li>
<li><p><code>return</code> 停止函数的执行，并返回一个值</p>
<p><code>return；</code></p>
<p><code>return 表达式；</code></p>
</li>
<li><p>没有返回值的函数：</p>
<ul>
<li><code>void</code>函数名（参数表）</li>
<li>不能使用（无）<code>return</code></li>
<li>不能做返回值的赋值</li>
</ul>
</li>
</ul>
<h2 id="函数的参数和变量"><a href="#函数的参数和变量" class="headerlink" title="函数的参数和变量"></a>函数的参数和变量</h2><ul>
<li><p>在看到<code>sum(1, 10)</code>，它需要知道<code>sum()</code>的样子以检查对<code>sum()</code>的使用是否正确（C的编译器自上而下分析代码）</p>
</li>
<li><p>函数头()；（函数声明（函数原型）可用来判断函数的调用是否正确）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数头()（编译器会再次检查调用是否正确）（<strong>实际函数头</strong>）</p>
</li>
<li><p>调用函数必须传递给它数量、类型正确的值</p>
<p>字面量，变量，函数的返回值，计算结果</p>
</li>
<li><p>调用函数时给的值与参数的类型不匹配是C语言系统上最大的漏洞,编译器总是自己转换，但可能会产生错误 C++&#x2F;java却避免了</p>
</li>
<li><p>C语言在调用函数，永远只传值给函数</p>
</li>
<li><p>传值：每个函数有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系（<code>int main()</code>后a和b与调用函数中a和b无关系）</p>
</li>
<li><p>过去称函数参数表中的参数为形式参数，调用函数时给的值叫实际参数。但现代不再适用。现代称前者为参数，后者为值。</p>
</li>
<li><p>定义在函数内部的变量就是本地变量。参数也是本地变量。</p>
</li>
<li><p>生存期：变量出现的时间与消亡的时间。</p>
</li>
<li><p>作用域：在代码的什么范围内可以访问这个变量（变量起作用）对于本地变量这两个问题的答案是<code>&#123;&#125;</code>（块）</p>
</li>
<li><p>本地变量定义在块内，可以是函数块内，也可以是语句块内。程序进入块之前，变量不存在，离开这个块，其中的变量就消失了。</p>
</li>
<li><p>块外面定义变量在块里面依然有效，反之无效</p>
</li>
<li><p>若块里面定义了和外面同名的变量则掩盖了外面的，但不能在一个块内定义同名变量</p>
</li>
<li><p>本地变量不会被默认初始化，参数在进入函数时被初始化了</p>
</li>
<li><p>传统C中，<code>void f()</code> -&gt; 不代表无参数，表示f函数参数未知，当无参数时，最好写<code>void f(void)</code></p>
</li>
<li><p>C语言不允许函数嵌套定义</p>
</li>
</ul>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><ul>
<li><p><code>int a[3][5]</code>3行5列矩阵</p>
</li>
<li><p><code>a[i][j]</code>表示一个<code>int</code>，是i行j列上的单元</p>
</li>
<li><p>二维数组的初始化</p>
<ul>
<li>列必须给出，行数可由编译器数</li>
<li>每行一个<code>&#123;&#125;</code>，逗号分隔</li>
<li>如果省略表示补零</li>
<li>也可以用定位（C99only）</li>
</ul>
</li>
</ul>
<h1 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h1><h2 id="数组运算-1"><a href="#数组运算-1" class="headerlink" title="数组运算"></a>数组运算</h2><ul>
<li><p>数组的集成初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不需要给出数组大小，编译器替我们数</p>
</li>
<li><p>集成初始化的定位（C99only）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; [<span class="number">0</span>] = <span class="number">2</span>, [<span class="number">2</span>] = <span class="number">3</span>, <span class="number">6</span> &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>用<code>[n]</code>在初始化数据中给出定位</li>
<li>没有定位的数据接在前面的位置后面</li>
<li>其他位置补0</li>
<li>特别适合初始数据稀疏的数组</li>
</ul>
</li>
<li><p><code>sizeof</code>：给出整个数组所占据的内容的大小，单位是字节</p>
</li>
<li><p><code>sizeof(a) / sizeof(a[0])</code>为数组元素个数</p>
</li>
<li><p><strong>要把一个数组所有元素交给另一个数组，必须采用遍历</strong></p>
</li>
<li><p>遍历数组作为函数参数时：</p>
<ul>
<li>不能在<code>[]</code>中给出数组大小</li>
<li>不能利用<code>sizeof</code>来计算数组元素个数</li>
</ul>
</li>
</ul>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul>
<li><p>在一个数组中找到某个数的位置（确认是否存在）</p>
</li>
<li><p>基本方法：遍历</p>
</li>
<li><p>二分搜索</p>
</li>
</ul>
<h1 id="指针与字符串"><a href="#指针与字符串" class="headerlink" title="指针与字符串"></a>指针与字符串</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul>
<li><p><code>sizeof</code>：运算符，给出某个类型或变量在内存中所占据的字节数<code>sizeof(int)</code>；<code>sizeof(i)</code></p>
</li>
<li><p>&amp;：运算符，获得变量的地址，它的操作必须是<strong>变量</strong></p>
</li>
<li><p>地址的大小是否与int相同取决于编译器</p>
</li>
<li><p>指针：就是保存地址的变量 <code>int *p=&amp;i</code></p>
<p><code>int* p, q</code>和<code>int *p, q</code>都代表<code>p</code>为指针，<code>q</code>为<code>int</code></p>
</li>
<li><p>普通变量的值是实际的值；指针变量的值是具有实际值的变量的地址</p>
</li>
<li><p><code>void f(int *p)</code>；在被调用时得到了某个变量的地址，在函数里面可以通过这个指针访问外面这个<code>i</code></p>
</li>
<li><p><code>*</code>是单目运算符，用来访问指针的值所表示的地址上的变量，可以做左值也可以做右值</p>
</li>
<li><p>函数参数表中的数组实际上是指针，<code>sizeof(a) == sizeof(int*)</code>，但是可以用数组的运算符<code>[]</code>进行计算</p>
</li>
<li><p>参数表中以下四种函数原型是等价的：</p>
<ul>
<li><code>int sum(int *arr, int n)</code></li>
<li><code>int sum(int *, int)</code></li>
<li><code>int sum(int arr[], int n)</code></li>
<li><code>int sum(int[ ], int)</code></li>
</ul>
</li>
<li><p>数组变量是特殊的指针，数组变量本身表达地址，（<code>int a[10]</code>; <code>int *p = a</code>;无需用&amp;取地址）</p>
</li>
<li><p>但是数组的单元表达的是变量，需要用&amp;取地址，<code>a == &amp;a[0]</code></p>
</li>
<li><p><code>[]</code>运算符可以对数组做，也可以对指针做：<code>p[0]</code>等价于<code>a[0]</code></p>
</li>
<li><p><code>*</code>可以对指针做，也可以对数组做</p>
</li>
<li><p>数组变量是<code>const</code>的指针，所以不能被赋值（<code>int a[ ] =</code> 等价于<code>int *const a =</code>）</p>
</li>
</ul>
<h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><ul>
<li><p><code>char</code>是一种整数，也是一种特殊的类型字符。</p>
</li>
<li><p>用单引号表示的字符字面量：<code>&#39;a&#39;</code>，<code>&#39;1&#39;</code>，<code>&#39;&#39;</code>也是一个字符，<code>printf</code>和<code>scanf</code>里用<code>%c</code>来输出输入字符。</p>
</li>
<li><p>大小写转换：<code>&#39;a&#39; - &#39;A&#39;</code>得到<code>a</code>和<code>A</code>在<code>ASCII</code>上的距离，<code>a + &#39;a&#39; - &#39;A&#39;</code>可以将大写字母变为小写字母，而<code>a + &#39;A&#39; - &#39;a&#39;</code>可以将小写字母变为大写字母</p>
</li>
<li><p>逃逸字符：用来表达无法印出来的控制字符或特殊字符，它由一个反斜杠<code>\</code>开头，后面跟上另一个字符，这两个字符合起来，组成一个字符。</p>
</li>
<li><blockquote>
<p><code>\b</code>：回退一格</p>
<p><code>\t</code>：到下一个表格位</p>
<p><code>\n</code>：换行</p>
<p><code>\r</code>：回车</p>
<p><code>\&quot;</code>：双引号</p>
<p><code>\&#39;</code>：单引号</p>
<p><code>\\</code>：反斜杠本身</p>
</blockquote>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>字符串是以<code>\0</code>结尾的一串字符</p>
</li>
<li><p><code>0</code>或<code>\0</code>相同，但和<code>&#39;0&#39;</code>不同，0标志字符串的结束，但它不是字符串的一部分，计算字符串长度的时候不包括这个<code>0</code></p>
</li>
<li><p>字符串以数组的形式存在，以数组或指针的形式访问，更多以指针形式</p>
</li>
<li><p><code>string.h</code>里有很多处理字符串的函数</p>
</li>
<li><p>字符串变量：<code>char *str = &quot;Hello&quot;</code>; <code>char word[] = &quot;Hello&quot;</code>; <code>char line[10] = &quot;Hello&quot;</code></p>
</li>
<li><p>字符串常量：<code>&quot;Hello&quot;</code>，会被编译器编程一个字符数组放在某处，这个数组的长度是6（<strong>结尾还有表示结束的0</strong>）</p>
</li>
<li><p>两个相邻的字符串常量会被自动连接起来</p>
</li>
<li><p>C语言的字符串是以字符数组的形态存在的，不能用运算符对字符串做运算，通过数组的方式可以遍历字符串，唯一特殊的地方是字符串字面量可以用来初始化字符数组</p>
</li>
<li><p>如果要构造一个字符串-&gt;数组；</p>
<p>如果要处理一个字符串-&gt;指针</p>
</li>
<li><p>字符串可以表达为<code>char*</code>的形式，<code>char*</code>不一定是字符串，只有它所指的字符数组有结尾的0；才能说它所指的是字符串</p>
</li>
</ul>
<h2 id="字符串的计算"><a href="#字符串的计算" class="headerlink" title="字符串的计算"></a>字符串的计算</h2><ul>
<li><p>并没有产生新的字符串，只是让指针s指向了t所指的字符串，对s的任何操作就是对t做的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *t = <span class="string">&quot;title&quot;</span>;</span><br><span class="line"><span class="type">char</span> *s;</span><br><span class="line">s = t;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>scanf(“%7s”, string)</code>；在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的长度小</p>
</li>
<li><p><code>string.h</code>:</p>
<ul>
<li><code>strlen</code>：返回s的字符串长度（不包括结尾的\0）</li>
<li><code>strcmp</code>：比较两个字符串，返回：0：<code>s1 == s2</code>；正差值：<code>s1 &gt; s2</code>；负差值：<code>s1 &lt; s2</code></li>
<li><code>strcpy</code>：把第二个参数的字符串拷贝到第一个空间；<code>restrict</code>表明两个字符串不重叠（C99），返回第一个参数</li>
<li><code>strcat</code>：把第二个参数的字符串接到第一个参数的后面去接成一个长的字符串</li>
<li><code>strchr</code>：从字符串左边找字符；<code>strrchr</code>：从字符串右边找字符。返回<code>NULL</code>表示没有找到。</li>
</ul>
</li>
</ul>
<h1 id="指针与字符串（进阶）"><a href="#指针与字符串（进阶）" class="headerlink" title="指针与字符串（进阶）"></a>指针与字符串（进阶）</h1><h2 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h2><ul>
<li><p>比如：交换两个变量的值</p>
</li>
<li><p>函数返回多个值，某些值就只能通过指针返回，传入的参数实际上是需要保存带回的结果的变量</p>
</li>
<li><p>函数返回应用的状态，结果通过指针返回</p>
</li>
<li><p><strong>常见错误：</strong>定义了指针变量，还没有指向任何变量，就开始使用指针</p>
</li>
<li><p>函数参数表中的数组实际上是指针，<code>sizeof(a)== sizeof(int*)</code>，但是可以用数组的运算符<code>[]</code>进行计算</p>
</li>
<li><p>数组变量是特殊的指针，数组变量本身表达地址，（<code>int a[10]</code>;<code>int *p = a</code>;）无需用&amp;取地址）</p>
</li>
<li><p><code>[]</code>运算符可以对数组做，也可以对指针做：<code>p[0]</code>等价于<code>a[0]</code> ，<code>*</code>可以对指针做，也可以对数组做</p>
</li>
<li><p>数组变量是<code>const</code>的指针，所以不能被赋值（<code>int a[]=</code>等价于int *const a&#x3D;）</p>
</li>
<li><p>指针是<code>const</code>：不能指向其他变量（声明时<code>*</code>在<code>const</code>前）</p>
<p>指针所指是<code>const</code>：不能通过指针修改变量（声明时<code>*</code>在<code>const</code>后）</p>
<p><code>const</code>数组：数组每个单元都是<code>const int</code>，必须通过初始化赋值</p>
</li>
</ul>
<h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><ul>
<li><p>指针加1表示指针指向下一个变量（地址加<code>sizeof(指针指向类型)</code>）</p>
</li>
<li><p>如果指针不是指向一片连续分布空间（如数组），“加1”运算毫无意义</p>
</li>
<li><p>指针计算：加减整数（+，+&#x3D;，-，-&#x3D;）；递增递减（++, –）；两个指针相减（结果为<code>地址差值/sizeof(指针指向类型)</code>）</p>
</li>
<li><p><code>*p++</code>：<strong>取出p所指的数据，再将p指向下一位置</strong>，++的优先级高于*，常用于数组类的连续空间操作，在某些CPU上可以直接被翻译成汇编指令</p>
</li>
<li><p>指针比较：比较在内存中的地址，数组中单元的地址递增排列</p>
</li>
<li><p>0地址：用NULL表示，不代表数值0</p>
</li>
<li><p>所有指针大小相同，指向不同类型指针无法赋值</p>
</li>
<li><p><code>void*</code>：不知道指向什么东西的指针，计算时与<code>char*</code>相同（但不相通）</p>
</li>
<li><p>指针的类型转换：<code>int *p = &amp;i</code>；<code>void *q = (void*)p</code>（<code>p</code>所指变量类型为<code>int</code>，但从<code>q</code>看所指变量类型未知）</p>
</li>
<li><p>指针的用处：</p>
<ul>
<li>需要传入较大的数据作参数</li>
<li>传入数组后对数组操作</li>
<li>函数返回不止一个结果</li>
<li>需要用函数修改不止一个变量</li>
<li>动态申请的内存</li>
</ul>
</li>
<li><p>动态内存分配：<code>malloc</code>函数（<code>&lt;stdlib.h&gt;</code>），申请以字节为单位的空间，返回的类型是</p>
<p><code>void* ( (int*)malloc(n*sizeof(int)))</code>结束后<code>free()</code>；申请失败则返回0（NULL）</p>
</li>
<li><p><code>free()</code>归还申请的空间给“系统”，只能还申请来的空间的首地址</p>
</li>
<li><p>申请了没<code>free</code>，长时间运行内存逐渐下降</p>
</li>
</ul>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><ul>
<li><p><code>putchar</code>：向标准输出写一个字符，返回输出了几个字符（<code>int</code>），<code>EOF</code>表示写失败</p>
</li>
<li><p><code>getchar</code>：从标准输入读入一个字符，返回类型是int是为了返回<code>EOF</code></p>
</li>
<li><p><code>char **a</code> ：a是指针，指向一个指向字符的指针</p>
</li>
<li><p><code>char[ ][n]</code> !&#x3D; <code>char *a[ ]</code></p>
</li>
</ul>
<h1 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul>
<li><p>定义：用户定义的数据类型，用关键字<code>enum</code>来声明<code>enum</code>枚举类型名字{名字0，…，名字n}；</p>
</li>
<li><p>枚举类型名字未必真的使用，要用的是大括号里面的名字，因为他们就是常量符号，类型为<code>int</code>，值从0到n</p>
</li>
<li><p>枚举量可以作为值，枚举类型可以跟上<code>enum</code>作为类型，实际上是以整数做内部计算和外部输入输出</p>
</li>
<li><p>枚举最后可以加<code>number</code>来代表代表枚举个数，方便遍历</p>
</li>
<li><p>枚举类型很少当做类型使用，排比有意义的名字比<code>const int</code>好用，枚举比宏好，因为枚举有<code>int</code>类型</p>
</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><p>定义：复合数据类型，包含多种类型，用一个变量表示</p>
</li>
<li><p>和本地变量一样，在函数内部声明的结构类型只能在函数内部使用</p>
</li>
<li><p><code>p1</code>和<code>p2</code>都是<code>point</code>里面有<code>x</code>和<code>y</code>的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1, p2;<span class="comment">//（注意分号）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>p1</code>和<code>p2</code>是一种无名结构，里面有<code>x</code>和<code>y</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1, p2;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>p1</code>和<code>p2</code>都是<code>point</code>里面有<code>x</code>和<code>y</code>的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1, p2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p1</span>,<span class="title">p2</span>;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结构用<code>.</code>运算符和名字访问其成员<code>p1.x</code></p>
</li>
<li><blockquote>
<p>对于整个结构，可以做赋值、取地址，也可以传值给函数参数 </p>
<p>p1 &#x3D; p2等价于p1.x&#x3D;p2.x，p1.y &#x3D; p2.y<strong>（数组不可以）</strong></p>
<p>p1 &#x3D; (struct point){5,10}等价于p1.x &#x3D; 5，p1.y &#x3D; 10</p>
</blockquote>
</li>
<li><p>和数组不同，结构变量的名字并不是结构变量的地址，必须用<code>&amp;</code>运算符</p>
</li>
<li><p>整个结构可以作为参数的值传入函数，在函数内新建一个结构变量，并复制调用者的结构的值，也可以返回一个结构（与数组完全不同）</p>
</li>
<li><p>用<code>-&gt;</code>表示指针所指的结构变量中的成员 <code>p-&gt;y = 10</code></p>
</li>
<li><p>结构数组：</p>
<p><code>struct date arr[100]</code>;</p>
</li>
</ul>
<p>​     <code>struct date arr[] = &#123; &#123; 4,52005 &#125;, &#123; 2,4,2005 &#125; &#125;</code>;</p>
<ul>
<li>结构中的变量也可以是结构</li>
</ul>
<h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><ul>
<li><p>自定义数据类型：<code>typedef</code>，声明一个已有的数据类型的新名字<code>typedef int Length</code>;使得<code>Length</code>成为<code>int</code>的别名<code>Length a</code>；等价于<code>int a</code>；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> x, y</span><br><span class="line"></span><br><span class="line">&#125;Date;<span class="comment">//表示Date可代替struct point</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义：<code>union</code>，所有成员共享一个空间，同一时间只有一个成员是有效的，union的大小是其最大的成员</p>
</li>
</ul>
<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><ul>
<li><p>定义：定义在函数外面的变量，具有全局的生存期和作用域，与任何函数无关，在任何函数内部都可以使用它们。</p>
</li>
<li><p>没有做初始化的全局变量会得到0值，指针会得到NULL，只能用编译时刻确定值来初始化全局变量，它们的初始化发生在<code>main</code>函数之前</p>
</li>
<li><p>在本地变量定义时加上<code>static</code>修饰就成为静态本地变量，当函数离开时，静态本地变量会继续存在并保存其值，静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数会保持上次离开时的值</p>
</li>
<li><p>静态本地变量实际是全局变量，它们位于相同的内存区域，它具有全局的生存期，函数内的局部作用域，<code>static</code>此处意为局部作用域（本地可访问）</p>
</li>
<li><p>返回本地变量的指针是危险的，返回全局变量或静态本地变量的指针是安全的，返回在函数内<code>malloc</code>的内存是安全的，但容易造成问题，最好的做法是返回传入的指针</p>
</li>
<li><p>不要使用全局变量在函数间传递参数和结果，尽量避免使用全局变量，使用全局变量和静态本地变量的函数是线程不安全的</p>
</li>
</ul>
<h2 id="编译预处理和宏"><a href="#编译预处理和宏" class="headerlink" title="编译预处理和宏"></a>编译预处理和宏</h2><ul>
<li><p><code>#</code>开头的是编译预处理指令，他们不是C的成分，但C语言离不开叫他们，<code>#define</code>用来定义一个宏</p>
</li>
<li><p><code>#define &lt;名字&gt;&lt;值&gt;</code> 注意结尾没有分号，名字必须是一个单词，值可以是各种东西，在C语言编译器编译之前，编译预处理程序（cpp）会把程序中的名字换成值</p>
</li>
<li><p>若宏中出现其他宏的名字，也是会被替换的，若一个宏的值超过一行，最后一行之前的行末需要加<code>\</code>，宏值后出现的注释不会被当做宏值的一部分</p>
</li>
<li><p>没有值的宏：<code>#define_DEBUG</code>，条件编译，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了</p>
</li>
<li><p>预定义的宏：<code>__LINE__</code>（源代码文件行号）；<code>__FILE__</code>（文件名）；<code>__DATE__</code>（编译日期）；<code>__TIME__</code>（编译时间）；<code>__STDC__</code>（如果编译器遵循ANSI C，其值为1，否则未定义 ）</p>
</li>
<li><p>像函数的宏：<code>#define cude(x) ((x)*(x)*(x))</code>，宏可以带参数，<strong>一切都要带括号</strong>，整个值要括号，参数出现的每个地方都要括号，也可以带多个参数，也可以组合（嵌套）使用其他宏</p>
</li>
<li><p>部分宏会被<code>inline</code>函数替代</p>
</li>
</ul>
<h2 id="大程序文件"><a href="#大程序文件" class="headerlink" title="大程序文件"></a>大程序文件</h2><ul>
<li><p>一个<code>.c</code>文件是一个编译单元，编译器每次只处理一个编译单元</p>
</li>
<li><p>把函数原型放进一个头文件当中（以<code>.h</code>结尾）中，在需要调用这个函数的源代码文件（<code>.c</code>文件）中<code>#include</code>这个头文件，就能让编译器在编译的时候知道函数的原型</p>
</li>
<li><p><code>#include</code>把那个文件的全部文本内容原封不动地插入到它所在的地方</p>
</li>
<li><p><code>#include“ ” </code>要求编译器首先在当前目录（<code>.c</code>所在的目录）寻找这个文件，如果没有，到编译器指定的目录去找。</p>
</li>
<li><p><code>#include&lt; &gt;</code>让编译器只在指定的目录去找</p>
</li>
<li><p>环境变量和编译器命令行参也可以指定寻找头文件的目录</p>
</li>
<li><p><code>#include</code>不是用来引入库的</p>
</li>
<li><p>在使用和定义这个函数的地方都应该<code>#include</code>这个头文件</p>
</li>
<li><p>一般的做法任何<code>.c</code>都有对应的同名<code>.h</code>，把所有对外公布的函数的原型和全局变量的声明都放进去</p>
</li>
<li><p>在函数前面加上<code>static</code>使得它成为只能在所在的编译单元中使用的函数</p>
</li>
<li><p>在全局变量前面加上<code>static</code>就使得它成为只能在所在的编译单元中被使用的全局变量</p>
</li>
<li><p><code>int i</code>; <code>extern int i</code>; 是变量的声明</p>
</li>
<li><p>声明是不产生代码的东西：函数原型；变量声明；结构声明；宏声明；枚举声明；类型声明；<code>inline</code>函数，定义是产生代码的东西：函数；全局变量</p>
</li>
<li><p>只有声明可以放在头文件当中否则会造成一个项目中多个编译单元有重名的实体，某些编译器允许几个编译单元中存在同名的函数或者用<code>weak</code>修饰符来强调这种存在。</p>
</li>
<li><p>同一个编译单元里同名的结构不能被重复声明，如果你的头文件里有结构的声明，很难这个头文件不会在一个编译单元里被<code>#include</code>多次</p>
</li>
<li><p>标准头文件结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LIST_HEAD__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LIST_HEAD__</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p> <code>#pragmam once</code>也能起到相同作用，但不是所有编译器都支持</p>
</li>
</ul>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h2><ul>
<li><p>格式化的输出：<code>%[flags][width][.prec][hlL]type</code></p>
<ul>
<li><code>flag</code><ul>
<li>- 左对齐</li>
<li>+：在前面放+或-</li>
<li>(space)：正数留空</li>
<li>0：0填充</li>
</ul>
</li>
<li><code>width</code>或<code>prec</code>：<ul>
<li><code>number</code>：最小字符数</li>
<li><code>*</code>：下一个参数是字符数</li>
<li><code>.number</code>：小数点后位数</li>
<li><code>.*</code>：下一个参数是小数点后位数</li>
</ul>
</li>
<li><code>hlL</code>（类型修饰）：<ul>
<li><code>hh</code>：单个字节</li>
<li><code>h</code>：short</li>
<li><code>l</code>：long</li>
<li><code>ll</code>：long long</li>
<li><code>L</code>：long double</li>
</ul>
</li>
</ul>
</li>
<li><p><code>%n</code>：读入或写入的个数</p>
</li>
<li><p>格式化输入：<code>%[flag]type</code></p>
</li>
<li><p><code>flag</code>：</p>
<ul>
<li><code>*</code>：跳过</li>
<li>数字：最大字符数；</li>
<li><code>hh</code>：<code>char</code>；<code>h</code>；<code>l</code>；<code>ll</code>；<code>L</code></li>
</ul>
</li>
<li><p><code>type</code>：[…]：所允许的字符</p>
</li>
<li><p><code>printf</code>和<code>scanf</code>的返回值是读入和输出的返回值</p>
</li>
<li><p>用<code>&gt;</code>和<code>&lt;</code>做重定向，<code>&lt;</code>指定输入，<code>&gt;</code>指定输出</p>
</li>
<li><p>打开文件的标准代码 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* fp=fope(“file”,”r”);</span><br><span class="line"><span class="keyword">if</span>(fp) &#123;</span><br><span class="line">	<span class="built_in">scanf</span>(fp,...);</span><br><span class="line">	fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>fopen</code>：</p>
<ul>
<li><code>r</code>：打开只读</li>
<li><code>r+</code>：打开读写，从文件头开始</li>
<li><code>w</code>：打开只写，如果不存在则新建，如果存在则清空</li>
<li><code>w+</code>：打开读写，如果不存在则新建，如果存在则清空</li>
<li><code>a</code>：打开追加，如果不存在则新建，如果存在则从文件尾开始</li>
<li><code>...x</code>（…加x结尾）：只新建，如果文件已新建则不能打开</li>
</ul>
</li>
<li><p>所有的文件最终都是二进制的，文本文件是用最简单的方法可以读写的文件，而二进制文件是需要专门的程序来读写的文件，文本文件的输入输出是格式化，可能经过转码</p>
</li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul>
<li><p>按位运算：</p>
<ul>
<li><code>&amp;</code>按位的与</li>
<li><code>|</code>按位的或</li>
<li><code>~</code>按位取反</li>
<li><code>^</code>按位的异或</li>
<li><code>&lt;&lt;</code>左移；</li>
<li><code>&gt;&gt;</code>右移</li>
</ul>
</li>
<li><p><code>&amp;</code>按位的与：二进制中若两个位对应均为1，则取&amp;结果为1，否则为0，</p>
<ul>
<li>让某一位或某些位为0：<code>x &amp; 0xFE</code>；</li>
<li>取一个数中间的一段：<code>x &amp; 0xFF</code></li>
</ul>
</li>
<li><p><code>|</code>按位的或：二进制中若两个位有1则|结果为1，否则为0</p>
</li>
<li><p><code>~</code>按位取反：把二进制数各位0变为1,1变为0</p>
</li>
<li><p>按位异或<code>^</code>：若两个位相等，则结果为1，不相等则为0</p>
</li>
<li><p><code>&lt;&lt;</code>左移：<code>i &lt;&lt; j</code>：i中所有的位向左移动j个位置，而右边填入0，所有小于<code>int</code>的类型，移位以<code>int</code>的方式来做，结果是int</p>
<p><code>x &lt;&lt;= 1</code>等价于<code>x *= 2</code>，<code>x &lt;&lt; n</code>等价于<code>x *= n * 2</code></p>
</li>
<li><p><code>&gt;&gt;</code>右移：i&gt;&gt;j：i中所有的位向右移动j个位置，而左边填入0，所有小于<code>int</code>的类型，移位以<code>int</code>的方式来做，结果是<code>int</code>，对于<code>unsigned</code>类型，左边填0，对于<code>signed</code>类型，左边填入原来的最高位（<strong>保持符号不变</strong>）</p>
<p><code>x &gt;&gt;= 1</code>等价于<code>x /= 2</code>，<code>x&gt;&gt;n</code>等价于<code>x /= 2 * n</code></p>
</li>
<li><p>可以认为逻辑运算相当于把所以非0值变成1，然后做按位运算</p>
</li>
<li><p>位段：把一个<code>int</code>的若干位组合成一个结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> leading : <span class="number">3</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> FLAG1 : <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> FLAG2 : <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> trailing : <span class="number">11</span>;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以直接用位段的成员名称来访问，比移位、与、或还方便，编译器会安排其中位的排列，不具有可移植性，当所需的位超过一个<code>int</code>时会采用多个<code>int</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>《海边的卡夫卡》</title>
    <url>/2023/05/04/%E6%9C%AD/%E3%80%8A%E6%B5%B7%E8%BE%B9%E7%9A%84%E5%8D%A1%E5%A4%AB%E5%8D%A1%E3%80%8B/</url>
    <content><![CDATA[<ul>
<li>世界缓慢地持续旋转，而人们都活在梦中。</li>
<li>正因为不能称心如意，人生才有意思。</li>
<li>我们大家都在持续失去种种宝贵的东西——宝贵的机会和可能性，无法挽回的感情。这是生存的一个意义。但我们的脑袋里——我想应该是脑袋里——有一个将这些作为记忆保存下来的小房间。肯定是类似图书馆书架的房间。而我们为了解自己的心的正确状态，必须不断制作那个房间用的检索卡。也需要清扫、换空气、给花瓶换水。换言之，你势必永远活在你自身的图书馆里。</li>
<li>于是我们领教了世界是何等凶顽，同时又得知世界也可以变得温存和美好。</li>
<li>某种情况下，命运这东西类似不断改变前进方向的局部沙尘暴。你变换脚步力图避开他，不料沙尘暴就像配合你似的同样变换脚步。不知有多少人曾在那里流血，你本身也会流血。温暖的鲜红的血。你将双手接血。那既是你的血，又是别人的血。不过有一点是清楚的：从沙尘暴中逃出的你已不再是跨入沙尘暴时的你。是的，这就是所谓沙生暴的含义。</li>
<li>纵使那样，也就是说纵使你的选择和努力注定徒劳无益，你也仍然绝对是你，不是你以外的什么。你正在作为你自己而向前迈进，毫无疑问，不必担心。</li>
<li>就经验性来说，人强烈追求什么的时候，那东西基本上是不来的， 而当你极力回避它的时候，它却自然找到头上。</li>
<li>不是人选择命运，而是命运选择人。</li>
</ul>
]]></content>
      <categories>
        <category>札</category>
      </categories>
  </entry>
  <entry>
    <title>《病隙随笔》</title>
    <url>/2024/06/28/%E6%9C%AD/%E3%80%8A%E7%97%85%E9%9A%99%E9%9A%8F%E7%AC%94%E3%80%8B/</url>
    <content><![CDATA[<ul>
<li>我们太看重了白昼，又太忽视黑夜。生命，至少有一半是在黑夜中呀。</li>
<li>一棵树上落着一群鸟儿，把树砍了，鸟儿也就没了吗？不，树上的鸟儿没了，但它们在别处。同样，此一肉身，栖居过一些思想、情感和心绪，这肉身火化了，那思想、情感和心绪也就没了吗？不，他们在别处。</li>
<li>进退维谷之日正可能是别有洞天之时。</li>
<li>所谓命运，就是说，这一出 “人间戏剧”需要各种各样的角色，你只能是其中之一，不可以随意调换。</li>
<li>佛法博大精深，但我确实不认为满腹功利是对佛法的尊敬。便去烧香，也不该有那样的要求，不该以为命运欠了你什么。莫非是佛一时疏忽错有安排，倒要你这凡夫俗子去提醒一二？唯当去求一份智慧，以醒贪迷。</li>
<li>不断的苦难才是不断需要信心的原因。</li>
<li>科学需要证明，信仰并不需要。</li>
<li>爱，原就是自卑弃暗投明的时刻。</li>
<li>皈依并不在一个住所，皈依是在路上。</li>
<li>彻底的圆满只不过是彻底的无路可走。</li>
<li>一切尘世之名都可以磨灭，而“我”不死。</li>
<li>左右苍茫时，总也得有条路走。</li>
<li>我想，上帝为人性写下的最本质的两条密码是：残疾与爱情。</li>
<li>而你若永远地走向它，你便随时都在它的光照之中。</li>
<li>残疾人以及所有的人，固然应该对艰难的生途说“是”，但要对那无言的坚壁说“不”，那无言的坚壁才是人性的残疾。</li>
<li>如果白昼的语言已经枯朽，就用黑夜的梦语，用诗的性灵。</li>
<li>放弃自卑，同时放弃怨恨；其实这两点必然是同时放弃的，因为曾经，它们也是一齐出生的。</li>
<li>那路途中的一切，有些与我擦肩而过从此天各一方，有些便永驻进我的心魂，雕琢我，塑造我，锤炼我，融入我而成为我。</li>
<li>白昼的清晰是有限的，黑夜却漫长，尤其是那心流所遭遇的黑暗更是辽阔无边。</li>
<li>生命的意义本不在向外的寻取，而在向内的建立。</li>
<li>心中对叛徒的看法似乎都在动摇，我慢慢看见，勇猛和可敬之外还有还有着更为复杂的人生处境。</li>
<li>仇恨的最大弊端是仇恨的蔓延，压迫的最大遗患是压迫的复制。</li>
<li>而那虚假的信仰一旦揭开，内里仍不过一场权利之争，一切轰轰烈烈立刻没了根基。</li>
<li>今天，绝对的信仰之光正趋淡薄，日新月异的生活道具正淹没着对生命意义的追求。</li>
<li>神性不明之时，强人最易篡居神位。</li>
<li>唯对神性的追问与寻觅，是实际可行的信仰之路。</li>
<li>接受苦难，从而走向精神的超越。</li>
<li>生命本无意义，是”我“使生命获得意义。</li>
<li>当精神联通了那无限之在，追随了那绝对价值，他就会因自身的局限而谦虚，因人性的丑陋而忏悔，视固有的困苦为锤炼，看琳琅的美物为道具，既知不断地超越自身才是目的，又知这样的超越乃是永远的过程。</li>
<li>不必统一的真实，不如叫作真诚。</li>
<li>在看似已然明朗的地方，开始文学的迷茫路。</li>
<li>游戏规则是人订的，但游戏——游戏的欲望、游戏的限制、游戏的种种困阻和种种可能性，都是神定。</li>
<li>残奥会的圣火不由次神点燃。</li>
<li>自从我学会了寻找，我就已经找到。</li>
</ul>
]]></content>
      <categories>
        <category>札</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统》</title>
    <url>/2024/03/08/%E6%9C%AD/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/</url>
    <content><![CDATA[<h1 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h1><ul>
<li>计算机系统是由硬件和系统软件组成的，他们共同工作来运行应用程序。</li>
</ul>
<h2 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h2><ul>
<li>源程序实际上就是一个由值0和1组成的为（又称为比特）序列，8个位组成一组，称为<strong>字节</strong>。</li>
<li>大部分的现代计算机系统都使用 ASCII 标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数值来表示每个字符。</li>
<li>只由 ASCII 字符构成的文件称为<strong>文本文件</strong>，所有其他文件称为<strong>二进制文件</strong>。</li>
<li>区别不同数据对象的唯一方法是我们读到这些数据对象时的上下文。</li>
</ul>
<h2 id="程序被其他程序翻译成不同的格式"><a href="#程序被其他程序翻译成不同的格式" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h2><ul>
<li>编译系统<ul>
<li><strong>预处理阶段</strong>。预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。通常生成以<code>.i</code>为后缀名的文件。</li>
<li><strong>编译阶段</strong>。编译器（ccl）将文本文件<code>hello.i</code>翻译成文本文件<code>hello.s</code>，它包含一个汇编语言程序。<ul>
<li>汇编语言为不同高级语言的不同编译器提供了通用的输出语言。</li>
</ul>
</li>
<li><strong>汇编阶段</strong>。汇编器（as）将<code>hello.s</code>翻译成及其语言指令。</li>
<li><strong>链接阶段</strong>。链接器将关于涉及到的函数的预编译文件整合到目标文件中，得到<code>hello</code>文件（可执行文件）。</li>
</ul>
</li>
</ul>
<h2 id="了解编译系统如何工作是大有益处的"><a href="#了解编译系统如何工作是大有益处的" class="headerlink" title="了解编译系统如何工作是大有益处的"></a>了解编译系统如何工作是大有益处的</h2><ul>
<li>优化程序性能</li>
<li>理解链接时出现的错误</li>
<li>避免安全漏洞</li>
</ul>
<h2 id="处理器读并解释储存在内存中的指令"><a href="#处理器读并解释储存在内存中的指令" class="headerlink" title="处理器读并解释储存在内存中的指令"></a>处理器读并解释储存在内存中的指令</h2><ul>
<li><p>shell是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。</p>
</li>
<li><p>系统的硬件组成</p>
<ul>
<li><p><strong>总线</strong>：贯穿整个系统的是一组电子管道，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送字长的字节块，也就是<strong>字</strong>。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节（32位），要么是8个字节（64位）。</p>
</li>
<li><p><strong>I&#x2F;O设备</strong>是系统和外部世界的联系通道。每个I&#x2F;O设备通过一个控制器或适配器与I&#x2F;O总线相连。</p>
<ul>
<li>控制器和适配器之间的区别主要在于它们的封装方式。</li>
<li><strong>控制器</strong>是I&#x2F;O设备本身或者系统的主印制电路板（通常称作主板上）的芯片组。</li>
<li><strong>适配器</strong>是一块插在主板插槽上的卡。</li>
</ul>
</li>
<li><p><strong>主存</strong>是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。</p>
<ul>
<li>从物理上来说，主存是由一组<strong>动态随机存储器（DRAM）</strong>芯片组成的。</li>
<li>从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。</li>
</ul>
</li>
<li><p><strong>处理器</strong>是中央处理单元（CPU）的简称，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为<strong>程序计数器（PC）</strong>。</p>
<ul>
<li><p>在任何时刻，PC都指向主存中的某条及其语言指令（即含有该条指令的地址）。而PC更新时指向的下一条指令并不一定和在内存中刚刚执行的指令相邻。</p>
<ul>
<li><strong>加载</strong>：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。</li>
<li><strong>存储</strong>：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。</li>
<li><strong>操作</strong>：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li>
<li><strong>跳转</strong>：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖PC中原来的值。</li>
</ul>
</li>
<li><p>指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>运行 hello 程序</p>
<ul>
<li>初始时，shell程序执行它的指令，等待我们输入一个指令。当我们在键盘上输入字符串<code>./hello</code>后，shell程序将字符逐一读入寄存器，再把它存放内存中。</li>
<li>当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入。然后shell执行一系列指令来加载可执行的<code>hello</code>文件。这些指令将<code>hello</code>目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串<code>&quot;hello, world\n&quot;</code>。<ul>
<li>利用<strong>直接存储器存取（DMA）</strong>技术，数据可以不通过处理器而直接从磁盘到达主存。</li>
</ul>
</li>
<li>一旦目标位文件中的<code>hello</code>中的代码和数据被加载到主存，处理器就开始执行<code>hello</code>程序的<code>main</code>程序中的机器语言指令。这些指令将<code>&quot;hello, world\n&quot;</code>字符串中的字节从主存赋值到寄存器文件，再从寄存器文件复制到显示设备，最终显示在屏幕上。</li>
</ul>
</li>
</ul>
<h2 id="高速缓存至关重要"><a href="#高速缓存至关重要" class="headerlink" title="高速缓存至关重要"></a>高速缓存至关重要</h2><ul>
<li>较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。</li>
<li>针对这种处理器和主存之间的差异，系统设计者采用了更小更快的存储设备，称为<strong>高速缓存存储器（cache memory，简称为cache或高速缓存）</strong>，作为暂时的集结区域，存放处理器近期可能会需要的信息。</li>
</ul>
<h2 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h2><ul>
<li>每个计算机系统中的存储设备都被组织成了一个存储器层次结构。</li>
<li>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。</li>
<li>操作系统的两个基本功能：<ul>
<li>防止硬件被失控的应用程序滥用。</li>
<li>向应用程序提供简单一致的机制来控制复杂而又通常大小不相同的低级硬件设备。</li>
</ul>
</li>
<li>文件是对I&#x2F;O设备的抽象。<ul>
<li>文件就是字节序列，每个 I&#x2F;O 设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。</li>
</ul>
</li>
<li>虚拟内存是对主存和磁盘 I&#x2F;O 设备的抽象表示。<ul>
<li>每个进程看到的内存都是一致的，称为虚拟地址空间。它们可分为以下区域：<ul>
<li><strong>程序代码和数据</strong>。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。</li>
<li><strong>堆</strong>。代码和数据区后紧随着的是运行时堆。代码和数据区在进程的一开始运行时就被指定了大小，而堆可以在运行时动态地扩展和收缩。</li>
<li><strong>共享库</strong>。大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</li>
<li><strong>栈</strong>。位于用户虚拟地址空间顶部的是<strong>用户栈</strong>，编译器用它来实现函数调用。和堆一样，<strong>用户栈</strong>在程序执行期间可以动态地扩展和收缩。</li>
<li><strong>内核虚拟内存</strong>。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。</li>
</ul>
</li>
</ul>
</li>
<li>进程是对处理器、主存和 I&#x2F;O 设备的抽象表示。<ul>
<li>进程是操作系统对一个正在运行的程序的一种抽象。</li>
<li><strong>并发运行</strong>是说一个进程的指令和另一个进程的指令是交错执行的。</li>
<li>传统系统在一个时刻只能执行一个程序，而先进的<strong>多核</strong>处理器同时能执行多个程序。</li>
<li>无论是单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为<strong>上下文切换</strong>。</li>
<li>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是<strong>上下文</strong>，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行<strong>上下文切换</strong>，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。</li>
<li>从一个进程到另一个进程的转换是由操作系统<strong>内核</strong>管理的。内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。</li>
<li>一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</li>
</ul>
</li>
</ul>
<h2 id="系统之间利用网络通信"><a href="#系统之间利用网络通信" class="headerlink" title="系统之间利用网络通信"></a>系统之间利用网络通信</h2><ul>
<li>现代系统经常通过网络和其他系统连接到一起。</li>
</ul>
<h2 id="重要主题"><a href="#重要主题" class="headerlink" title="重要主题"></a>重要主题</h2><ul>
<li>Amdahl定律的主要思想是当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。</li>
<li><strong>并发</strong>是一个通用的概念，指一个同时具有多个活动的系统。</li>
<li><strong>并行</strong>指的是用并发来使一个系统运行得更快。</li>
<li>处理必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为<strong>单处理系统</strong>。</li>
<li>当构建一个由但操作系统内核控制的多处理器组成的系统时，我们就得到了一个<strong>多处理系统</strong>。</li>
<li>多核处理器是将多个 CPU（称为“核”）集成在一个集成电路芯片上。</li>
<li>超线程，有时称为<strong>多线程</strong>，是一项允许一个 CPU 执行多个控制流的技术。</li>
<li>多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。其次，它可以使应用程序执行地更快。</li>
<li>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为<strong>指令级并行</strong>。</li>
<li>在<strong>流水线</strong>中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。</li>
<li>如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为<strong>超标量</strong>。</li>
<li>允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。</li>
<li><strong>虚拟机</strong>提供对整个计算机的抽象，包括操作系统、处理器和程序。</li>
</ul>
<h1 id="第二章-信息的表示与处理"><a href="#第二章-信息的表示与处理" class="headerlink" title="第二章 信息的表示与处理"></a>第二章 信息的表示与处理</h1><ul>
<li>现代计算机存储和处理的信息以二进制信号表示（<strong>位</strong>），他们形成了数字革命的基础。</li>
<li>当把位组合在一起，再加上某种<strong>解释</strong>，我们就可以描述任何有限集合的元素。</li>
<li><strong>无符号</strong>编码基于传统的二进制表示法，表示大于或等于零的数字。</li>
<li><strong>补码</strong>编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。</li>
<li><strong>浮点数</strong>编码是表示实数的科学记数法以2为基数的版本。</li>
<li>当结果太大以至于不能表示时，某些运算就会<strong>溢出</strong>。</li>
<li>整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精准的；而浮点数虽然可以编码一个较大的数值范围，但这种表示只是近似的。浮点数的计算可能因为运算过程的不同而影响正常结果，整数则不会。</li>
</ul>
<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><ul>
<li>大多数计算机使用8位的块（字节 byte），作为最小的可寻址的内存单位，而不是位。</li>
<li>机器级程序将内存视为一个非常大的字节数组，称为<strong>虚拟内存</strong>。</li>
<li>内存的每一个字节都由一个唯一的数字来标识，称为它的<strong>地址</strong>。</li>
<li>所有可能的地址的集合就称为<strong>虚拟地址空间</strong>。</li>
</ul>
<h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><ul>
<li>一个字节由8位组成。在二进制表示法中，它的值域是00000000<sub>2 </sub>~ 11111111<sub>2</sub>。如果看成十进制整数，它的值域就是0<sub>10</sub> ~ 255<sub>10</sub>。</li>
<li>二进制和十六进制的之间的转换可以通过展开每个十六进制数字，将它转换为二进制格式。</li>
<li>将一个十进制数字 x 转换为十六进制，可以反复地用16除 x。</li>
</ul>
<h3 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h3><ul>
<li>每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）。字长决定的最重要的系统参数就是虚拟地址空间的最大大小。</li>
<li>对于一个字长为 ω 位的机器而言，虚拟地址的范围为0 ~ 2<sup>ω </sup> - 1。</li>
<li>大多数64位机器也可以运行为32位机器编译的程序，这是一种向后兼容。</li>
<li>数据类型 long 一般在32位程序中为4字节，在64位程序中则为8字节。为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99引入一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化，其中就有数据类型 int32_t 和 int64_t，它们分别为4个字节和8个字节。</li>
</ul>
<h3 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h3><ul>
<li><strong>小端法</strong>：最低有效字节在最前面的方式。</li>
<li><strong>大端法</strong>：最高有效字节在最前面的方式。</li>
<li>许多比较新的微处理器是<strong>双端法</strong>，可以把配置成作为大端或者小端的机器运行。</li>
<li><strong>反汇编器</strong>：一种确定可执行程序文件所表示的指令序列的工具。</li>
</ul>
<h3 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h3><ul>
<li>在使用 ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小无关。因而，文本数据比二进制数据具有更强的平台独立性。</li>
</ul>
<h3 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h3><ul>
<li>不同的机器类型使用不同且不兼容的指令和编码方式。</li>
</ul>
<h3 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h3><ul>
<li><p>位向量就是固定长度为 ω 、由0和1组成的串。</p>
</li>
<li><table>
<thead>
<tr>
<th>~</th>
<th></th>
<th></th>
<th>&amp;</th>
<th>0</th>
<th>1</th>
<th></th>
<th>|</th>
<th>0</th>
<th>1</th>
<th></th>
<th>^</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td><strong>0</strong></td>
<td>1</td>
<td></td>
<td><strong>0</strong></td>
<td>0</td>
<td>0</td>
<td></td>
<td><strong>0</strong></td>
<td>0</td>
<td>1</td>
<td></td>
<td><strong>0</strong></td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>0</td>
<td></td>
<td><strong>1</strong></td>
<td>0</td>
<td>1</td>
<td></td>
<td><strong>1</strong></td>
<td>1</td>
<td>1</td>
<td></td>
<td><strong>1</strong></td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="C-语言的位级运算"><a href="#C-语言的位级运算" class="headerlink" title="C 语言的位级运算"></a>C 语言的位级运算</h3><ul>
<li>C 语言的一个有用的特性就是它支持布尔运算。</li>
<li>位级运算的一个常见用法就是实现<strong>掩码</strong>运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。</li>
</ul>
<h3 id="C语言中的逻辑计算"><a href="#C语言中的逻辑计算" class="headerlink" title="C语言中的逻辑计算"></a>C语言中的逻辑计算</h3><ul>
<li>C语言还提供了一组逻辑运算符 || 、&amp;&amp; 和 !，分别对应 OR 、AND 和 NOT运算。逻辑运算认为所有非零的参数都表示 TRUE，而参数0表示 FALSE。它们返回1或者0，分别表示结果为 TRUE 或者为 FALSE。</li>
<li>逻辑运算符 &amp;&amp; 和 || 与它们对应的位级运算 &amp; 和 | 之间第二个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。</li>
</ul>
<h3 id="C语言中的移位运算"><a href="#C语言中的移位运算" class="headerlink" title="C语言中的移位运算"></a>C语言中的移位运算</h3><ul>
<li>C 语言还提供了一组<strong>移位</strong>运算，向左或者向右移动位模式。C 表达式 x&lt;&lt;k 会生成一个值，x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个0。移位运算时从左至右可结合的。</li>
<li>一般而言，机器支持两种形式的右移：<strong>逻辑右移</strong>和<strong>算术右移</strong>。<ul>
<li>逻辑右移是在左端补 k 个0。</li>
<li>算术右移是在左端补 k 个最高有效位的值，它对有符号整数数据的运算非常有用。</li>
</ul>
</li>
<li>C 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移——算术右移或者逻辑右移都可以。</li>
<li>对于无符号数，右移必须是逻辑的。</li>
<li>与 C 相比，Java 对于如何进行右移有明确的定义。表达是 x&gt;&gt;k 会将 x 算术右移 k 个位置，而 x&gt;&gt;&gt;k 会对 x 做逻辑右移。</li>
</ul>
<h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2>]]></content>
      <categories>
        <category>札</category>
      </categories>
  </entry>
  <entry>
    <title>《被讨厌的勇气》</title>
    <url>/2024/10/30/%E6%9C%AD/%E3%80%8A%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%E3%80%8B/</url>
    <content><![CDATA[<ul>
<li><p>决定我们自身的不是过去的经历，而是我们自己赋予经历的意义。</p>
</li>
<li><p>答案不应该是从别人那里得到，而应该是自己亲自找出来。</p>
</li>
<li><p>现在的你之所以不幸正是因为你自己亲手选择了“不幸”，而不是因为生来就不幸。</p>
</li>
<li><p>你自己主动选择了自己的生活方式。</p>
</li>
<li><p>无论是继续选择与之前一样的生活方式还是重新选择新的生活方式，那都在于你自己。</p>
</li>
<li><p>阿德勒说“无论是追求优越性还是自卑感，都不是病态，而是一种能够促进健康、正常的努力和成长的刺激“。只要处理得当，自卑感也可以成为努力和成长的催化剂。</p>
</li>
<li><p>所谓“追求优越性”是指自己不断超前迈进，而不是比别人高出一等的意思。</p>
</li>
<li><p>健全的自卑感不是来自于与别人的比较，而是来自与“理想的自己”的比较。</p>
</li>
<li><p>个人的愤怒很快就会冷却，而公愤则会长时间地持续。因私愤而流露的发怒只不过是为了让别人屈服的一种工具而已。</p>
</li>
<li><p>眼镜模糊了，只能看到眼前的胜负就会走错道路，我们只有摘掉竞争或胜负之争的眼镜才能够改变完善自己。</p>
</li>
<li><p>倘若自己都不为自己活出自己的人生，那还有谁会为自己而活呢？</p>
</li>
<li><p>如果一味寻求别人的认可、在意别人的评价，那最终就会活在别人的人生中。</p>
</li>
<li><p>能够改变自己的只有自己。</p>
</li>
<li><p>真正的自由是一种把滚落下来的自己从下面向上推的态度。</p>
</li>
<li><p>不畏惧被人讨厌而是勇往直前，不随波逐流而是激流勇进，这才是对人而言的自由。</p>
</li>
<li><p>你正因为不想被他人认为自己不好，所以才在意他人的视线。这不是对他人的关心，而是对自己的执著。</p>
</li>
<li><p>自己人生的主人公是“我”。这种认识没有问题。但是，这并不意味着“我”君临于世界的中心。“我”是自己人生的主人公，同时也是共同体的一员、是整体的一部分。</p>
</li>
<li><p>别人并不是为了满足你的期待而活。</p>
</li>
<li><p>归属感不是生来就有的东西，要靠自己的手去获得。</p>
</li>
<li><p>如果是因为你的反对就能崩塌的关系，那么这种关系从一开始就就没有必要缔结，由自己主动舍弃也无所谓。活在害怕关系破裂的恐惧之中，那是为他人而活的一种不自由的生活方式。</p>
</li>
<li><p>人只有在能够感觉自己有价值的时候才可以获得勇气。</p>
</li>
<li><p>重要不是被给予了什么，而是如何去利用被给予的东西。</p>
</li>
<li><p>对人而言，最大的不幸就是不喜欢自己。</p>
</li>
<li><p>人生是连续的刹那，根本不存在过去和未来。你是想要通过关注过去或未来为自己寻找免罪符。过去发生了什么与你的“此时此刻”没有任何关系，未来会如何也不是“此时此刻”要考虑的事情。</p>
</li>
<li><p>人生中最大的谎言就是不活在“此时此刻”。纠结过去、关注未来，把微弱而模糊的光打向人生整体，自认为看到了些什么。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>札</category>
      </categories>
  </entry>
  <entry>
    <title>Hello 算法</title>
    <url>/2024/03/04/%E7%AE%97%E6%B3%95/Hello%20%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.hello-algo.com/">Hello 算法 </a></p>
]]></content>
      <categories>
        <category>Algo</category>
      </categories>
  </entry>
  <entry>
    <title>第一章 绪论</title>
    <url>/2023/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li><p>数据：数据是<strong>信息的载体</strong>，是描述客观事物属性的数、字符及所有<strong>能输入到计算机中并被计算机程序识别</strong>和处理的符号的集合。数据是计算机程序加工的原料。</p>
</li>
<li><p>数据元素、数据项：<strong>数据元素</strong>是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干<strong>数据项</strong>组成，数据项是构成数据元素的不可分割的最小单位。</p>
</li>
<li><p>数据结构：相互之间存在一种或多种特定<strong>关系</strong>的数据元素的集合。</p>
</li>
<li><p>数据对象：具有<strong>相同性质</strong>的数据元素的集合，是数据的一个子集。</p>
</li>
<li><p>数据类型：一个值的集合和定义在此集合上的一组操作的总称。</p>
<ul>
<li>原子类型。其值不可再分的数据类型。</li>
<li>结构类型。其值可以再分解为若干成分（分量）的数据类型。</li>
</ul>
</li>
<li><p>抽象数据类型（Abstract Data Type, ADT）：抽象数据组织及与之相关的操作。</p>
<ul>
<li>原子类型。其值不可分解。</li>
<li>固定聚合类型。其值由确定数目的成分按某种结构组成。</li>
<li>可变聚合类型。其值的成分数目不确定。</li>
</ul>
</li>
<li><p>多形数据类型：其值的成分不确定的数据类型。</p>
</li>
</ul>
<h1 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h1><ul>
<li>逻辑结构<ul>
<li>集合：各个元素同属一个集合，别无其他关系。</li>
<li>线性结构：数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一前驱，除了最后一个元素，所有元素都有唯一后继。</li>
<li>树性结构：数据元素之间是一对多的关系。</li>
<li>图状结构（网状结构）：数据元素之间是多对多的关系。</li>
</ul>
</li>
<li>物理结构（存储结构）<ul>
<li>顺序存储：把<strong>逻辑上相邻的元素存储在物理位置上也相邻的存储单元中</strong>，元素之间的关系由存储单元的邻接关系来体现。<ul>
<li>若采用<strong>顺序存储</strong>，则各个数据元素在物理上必须是<strong>连续的</strong>；若采用<strong>非顺序存储</strong>，则各个数据元素在物理上可以是<strong>离散的</strong>。</li>
<li>数据的<strong>存储结构</strong>会<strong>影响存储空间分配的方便程度</strong>。</li>
<li>数据的<strong>存储结构</strong>会<strong>影响对数据运算的速度</strong>。</li>
</ul>
</li>
<li>链式存储：<strong>逻辑上相邻的元素在物理位置上可以不相邻</strong>，借助指示元素存储地址的指针来表示元素之间的逻辑关系。</li>
<li>索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。</li>
<li>散列存储：根据元素的关键字直接计算出该元素的存储地址，又称<strong>哈希（Hash）存储</strong>。</li>
</ul>
</li>
<li>数据的运算<ul>
<li>施加在数据上的运算包括运算的定义和实现。</li>
<li><strong>运算的定义</strong>是<strong>针对逻辑结构</strong>的，指出运算的功能。</li>
<li><strong>运算的实现</strong>是<strong>针对存储结构</strong>的，指出运算的具体操作步骤。</li>
</ul>
</li>
</ul>
<h1 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h1><ul>
<li><strong>算法（Algorithm）</strong>是<strong>对特定问题求解步骤的一种描述</strong>，它是指令的有限序列，其中的每条指令表示一个或多个操作。</li>
<li>算法的特性<ul>
<li><strong>有穷性</strong>。一个算法必须总在执行有穷步后结束，且每一步都可在有穷时间内完成。<ul>
<li><strong>算法</strong>必须是<strong>有穷</strong>的，而<strong>程序</strong>可以是<strong>无穷</strong>的。</li>
</ul>
</li>
<li><strong>确定性</strong>。算法中每条指令必须有确切的含义，对于<strong>相同的输入</strong>只能得出<strong>相同的输出</strong>。</li>
<li><strong>可行性</strong>。算法中描述的操作都可以通过已经实现的<strong>基本运算执行有限次</strong>来实现。</li>
<li><strong>输入</strong>。一个算法<strong>有零个或多个输入</strong>，这些输入取自于某个特定的对象的集合。</li>
<li><strong>输出</strong>。一个算法<strong>有一个或多个输出</strong>，这些输出是与输入有某种特定关系的量。</li>
</ul>
</li>
<li>“好”算法的特质：<ul>
<li><strong>正确性</strong>。算法应能正确地求解问题。</li>
<li><strong>可读性</strong>。算法应具有良好的可读性，以帮助人们理解。</li>
<li>健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</li>
<li><strong>高效率</strong>与<strong>低存储量需求</strong>。<ul>
<li>高效率：花的时间少。时间复杂度低。</li>
<li>低存储量需求：不费内存。空间复杂度低。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h1><h2 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h2><ul>
<li><strong>事先预估</strong>算法<strong>时间开销T(n)<strong>与</strong>问题规模n</strong>的关系（T表示”time”）。</li>
<li>在T(n)中可以只考虑阶数高的部分。</li>
<li>大O表示“同阶”，同等数量级。即：当n趋近于无穷大时，二者之比为常数。</li>
<li>加法规则：T(n) &#x3D; T1(n)+T2(n) &#x3D; O(f(n)) + O(g(n)) &#x3D; O(max(f(n), g(n)))</li>
<li>乘法规则：T(n) &#x3D; T1(n) * T2(n) &#x3D; O(f(n)) *  O(g(n)) &#x3D; O(f(n) * g(n))</li>
<li>O(n) &lt; O(log<del>2</del>n) &lt; O(n) &lt; O(nlog<del>2</del>n) &lt;O(n^2^) &lt; O(n^3^) &lt; O(2^n^) &lt; O(n!) &lt; O(n^n^)</li>
<li>顺序执行的代码只会影响常数项，可以忽略。只需挑循环中的<strong>一个基本操作</strong>分析它的执行次数与n的关系即可。如果有多层嵌套循环，只需关注最深层循环循环了几次。</li>
<li>最坏时间复杂度：最坏情况下算法的时间复杂度。</li>
<li>平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间。</li>
<li>最好时间复杂度：最好情况下算法的时间复杂度。（不常用）</li>
</ul>
<h2 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h2><ul>
<li>算法<strong>原地工作</strong>：算法所需的内存空间为常量。</li>
<li>函数递归调用带来的内存开销：空间复杂度 &#x3D; 递归调用的深度</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>第二章 线性表</title>
    <url>/2023/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><ul>
<li>线性表示具有<strong>相同</strong>数据类型的 n（n &gt;&#x3D; 0)个<strong>数据元素</strong>的<strong>有限序列</strong>，其中 n <strong>为表长</strong>，当 n &#x3D; 0时线性表是一个<strong>空表</strong>。若用L命名线性表，则其一般表示为 L &#x3D; (a<sub>1</sub>, a<sub>2</sub>, a<sub>i</sub>, a<sub>i+1</sub>, a<sub>n</sub>)。每个数据元素所占空间一样大。<ul>
<li>有次序。</li>
<li>有限（所有整数按递增次序排列不是一个线性表）。</li>
<li>a<sub>i</sub> 是线性表中的“第 i 个”元素线性表的<strong>位序</strong>。</li>
<li>a<sub>1</sub> 是<strong>表头元素</strong>；a<sub>n</sub> 是<strong>表尾元素</strong></li>
<li>除第一个元素外，每个元素有且仅有一个<strong>直接前驱</strong>；除最后一个元素外，每个元素有且仅有一个<strong>直接后继</strong>。</li>
</ul>
</li>
</ul>
<h2 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h2><ul>
<li><code>InitList(&amp;L)</code>：<strong>初始化</strong>表。构造一个空的线性表 L，<strong>分配内存空间</strong>。</li>
<li><code>Destroy(&amp;L)</code>：<strong>销毁</strong>操作。销毁线性表，并<strong>释放</strong>线性表 L 所占用的<strong>内存空间</strong>。</li>
<li><code>LinstInsert(&amp;L, i, e)</code>：<strong>插入</strong>操作。在表L中的第 i 个位置上插入指定元素e。</li>
<li><code>ListDelete(&amp;L, i, &amp;e)</code>：删除操作。删除表 L 中的第 i 个位置的元素，并用 e 返回删除元素的值。</li>
<li><code>LocateElem(L, i)</code>：<strong>按值查找</strong>操作。在表 L 中查找具有给定关键字值的元素。</li>
<li><code>GetElem(L, i)</code>：<strong>按位查找</strong>操作。获取表 L 中第 i 个位置的元素的值。</li>
<li><code>Length(L)</code>：求表长。返回线性表 L 的长度，即 L 中数据元素的个数。</li>
<li><code>PrintList(L)</code>：输出操作。按前后顺序输出线性表 L 的所有元素值。</li>
<li><code>Empty(L)</code>：判空操作。若 L 为空表，则返回 true，否则返回 false。</li>
</ul>
<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><h2 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h2><ul>
<li>用顺序存储的方式实现线性表顺序存储。把<strong>逻辑上相邻</strong>的元素存储在<strong>物理位置上也相邻</strong>的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</li>
</ul>
<h2 id="顺序表的实现"><a href="#顺序表的实现" class="headerlink" title="顺序表的实现"></a>顺序表的实现</h2><ul>
<li><p><strong>静态</strong>分配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态</strong>分配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType* data;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">    <span class="type">int</span> lengeh;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SeqList&amp; L, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* p = L.data;</span><br><span class="line">    L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>((L.MaxSize + len) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        L.data[i] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">    L.MaxSize = L.MaxSize + len;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序表的特点</p>
<ul>
<li><strong>随机访问</strong>，即可以在 O(1) 时间内找到第i个元素。</li>
<li>存储密度高，每个结点只存储数据元素。</li>
<li>拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）。</li>
<li>插入、删除操作不方便，需要移动大量元素。</li>
</ul>
</li>
</ul>
<h2 id="顺序表的插入和删除"><a href="#顺序表的插入和删除" class="headerlink" title="顺序表的插入和删除"></a>顺序表的插入和删除</h2><ul>
<li><p><strong>插入</strong>操作。在表 L 中的第 i 个位置上插入指定元素e。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">LinstInsert</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length &gt;= MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = L.length; j &gt;= i; j--) &#123;</span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好时间复杂度：O(1)</p>
<p>最坏时间复杂度：O(n)</p>
<p>平均时间复杂度：O(n)</p>
</li>
<li><p><strong>删除</strong>操作。删除表 L 第 i 个位置的元素，并用 e 返回删除元素的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, <span class="type">int</span>&amp; e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">        L.length--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好时间复杂度：O(1)</p>
<p>最坏时间复杂度：O(n)</p>
<p>平均时间复杂度：O(n)</p>
</li>
</ul>
<h2 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h2><ul>
<li><p><strong>按位查找</strong>操作。获取表 L 中第 i 个位置的元素的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
</li>
<li><p><strong>按值查找</strong>操作。在表 L 中查找具有给定关键字值的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SeqList L, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好时间复杂度：O(1)</p>
<p>最坏时间复杂度：O(n)</p>
<p>平均时间复杂度：O(n)</p>
</li>
</ul>
<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><h2 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h2><ul>
<li><p>顺序表：每个结点中只存放数据元素。</p>
<ul>
<li>优点：可随机存取，存储密度高。</li>
<li>缺点：要求大片连续空间，改变容量不方便。</li>
</ul>
</li>
<li><p>单链表：每个结点除了存放数据元素外，还要存储指向下一个结点的指针。</p>
<ul>
<li>优点：不要求大片连续空间，改变容量方便。</li>
<li>缺点：不可随机存取，要耗费一定空间存放指针。</li>
</ul>
</li>
<li><p>结构体定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, * LinkList;</span><br></pre></td></tr></table></figure>

<p>强调这是一个<strong>单链表</strong>：使用<code>LinkList</code></p>
<p>强调这是一个<strong>结点</strong>：使用<code>LNode*</code></p>
</li>
<li><p>不带头结点的单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList&amp; L)</span> &#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;<span class="comment">// 空表，暂时还没有任何结点（防止脏数据）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>带头结点的单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList&amp; L)</span> &#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>头结点不存储数据。</p>
</li>
</ul>
<h2 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h2><ul>
<li><p><strong>插入</strong>操作。在表L中的<strong>第i个位置</strong>上插入指定元素e。</p>
<ul>
<li><strong>带头结点</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;<span class="comment">//此句和下一句不能颠倒</span></span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好时间复杂度：O(1)</p>
<p>最坏时间复杂度：O(n)</p>
<p>平均时间复杂度：O(n)</p>
<ul>
<li><strong>不带头结点</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">        LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode* p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>后插</strong>操作。在 p 结点之后插入元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextNode</span><span class="params">(LNode* p, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>)<span class="comment">// 某些情况下内存分配失败（如内存不足）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>前插</strong>操作。在 p 结点之前插入元素 e。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode* p, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;<span class="comment">//新节点s连到p之后</span></span><br><span class="line">    s-&gt;data = p-&gt;data;<span class="comment">//将p中元素复制到s中</span></span><br><span class="line">    p-&gt;data = e;<span class="comment">//p中元素覆盖为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
</li>
</ul>
<h2 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h2><ul>
<li><p><strong>删除</strong>操作。删除表中<strong>第 i 个位置</strong>的元素，并用 e 返回删除元素的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType&amp; e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* q = p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好时间复杂度：O(1)</p>
<p>最坏时间复杂度：O(n)</p>
<p>平均时间复杂度：O(n)</p>
</li>
<li><p><strong>删除指定结点p</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(LNode* p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：不满足p是最后一个结点的情况。若需要删除最后一个结点，只能从表头依次寻找p的前驱。</p>
</li>
</ul>
<h2 id="单链表的查找"><a href="#单链表的查找" class="headerlink" title="单链表的查找"></a>单链表的查找</h2><ul>
<li><p><strong>按位</strong>查找，返回第i个元素（带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode* <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode* p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平均时间复杂度：O(n)</p>
</li>
<li><p>封装（基本操作）的好处：避免重复代码，简洁、易维护。</p>
</li>
<li><p><strong>按值</strong>查找，找到<code>数据域 == e</code>的结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  LNode* <span class="title function_">LocateElem</span><span class="params">(LinkList L, ElemType e)</span> &#123;</span><br><span class="line">      LNode* p = L-&gt;next;</span><br><span class="line">      <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">          p = p-&gt;next;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">- 求表的长度。</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  <span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span> &#123;</span><br><span class="line">      <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          p = p-&gt;next;</span><br><span class="line">          len++;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
</li>
</ul>
<h2 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h2><ul>
<li><p><strong>尾插法</strong>建立单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList&amp; L)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    LNode* s,* r = L;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">9999</span>) &#123;<span class="comment">//输入9999表示结束</span></span><br><span class="line">        s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：设置一个指向表尾结点的指针。</p>
</li>
<li><p><strong>头插法</strong>建立单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList&amp; L)</span> &#123;</span><br><span class="line">      LNode *s;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">      L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      <span class="keyword">while</span>(x != <span class="number">9999</span>) &#123;<span class="comment">//输入9999表示结束</span></span><br><span class="line">          s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">          s-&gt;data = x;</span><br><span class="line">          s-&gt;next = L-&gt;next;</span><br><span class="line">          L-&gt;next = s;</span><br><span class="line">          <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> L;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"># 双链表</span><br><span class="line"></span><br><span class="line">- 单链表：无法逆向检索，有时候不太方便。</span><br><span class="line"></span><br><span class="line">- 双链表：可双向检索，存储密度略低于单链表。</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">      ElemType data;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>* <span class="title">prior</span>, * <span class="title">next</span>;</span></span><br><span class="line">  &#125;DNode, * DLinkList;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双链表的初始化（带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinklist&amp; L)</span> &#123;</span><br><span class="line">    L = (DNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双链表的插入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode* p, DNode* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;<span class="comment">//将s结点插入到p结点之后</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    	p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双链表的删除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNextDNode</span><span class="params">(DNode* p)</span> &#123;<span class="comment">//删除p结点的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode* q = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双链表的遍历</p>
<ul>
<li><strong>后向</strong>遍历</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>前向</strong>遍历</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>前向</strong>遍历（跳过<strong>头结点</strong>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;prior != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双链表不可随机存取，按位查找、按值查找操作都只能用遍历方法实现。时间复杂度O(n)</p>
</li>
</ul>
<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><ul>
<li><p>单链表：从一个结点出发只能找到后续的各个结点。</p>
</li>
<li><p>循环单链表：从一个结点出发可以找到其他任何一个结点。</p>
</li>
<li><p>初始化循环单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList&amp; L)</span> &#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = L;<span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在循环单链表中如果需要经常对表头&#x2F;表尾结点操作，可将表头&#x2F;表尾设为头结点。</p>
</li>
<li><p>初始化循环双链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinklist&amp; L)</span> &#123;</span><br><span class="line">    L = (DNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = L;</span><br><span class="line">    L-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环双链表的插入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode* p, DNode* s)</span> &#123;</span><br><span class="line">    s-&gt;next = p-&gt;next;<span class="comment">//将s结点插入到p结点之后</span></span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环双链表的删除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNextDNode</span><span class="params">(DNode* p)</span> &#123;<span class="comment">//删除p结点的后继结点q</span></span><br><span class="line">    DNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><ul>
<li><p>定义：分配一整片连续的内存空间，各个结点集中安置（用数组方式实现的链表）。</p>
<ul>
<li>与数组不同之处：数组各个元素是按照数据下标0至n依次排序的。而在每个结点包含数据元素和下一个结点的数组下标（游标）两个信息，因而静态链表不一定依次排序。</li>
<li>每个数据元素4B，每个游标4B（每个结点8B），设起始地址为addr（不是e<sub>0</sub>地址），则e<sub>1</sub>的存放地址为addr + 8*2。</li>
</ul>
</li>
<li><p>结构体定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;<span class="comment">//下一个数据下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;SLinkList[MaxSize]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SLinkList a</code>可用 SLinkList 定义“一个长度为 MaxSize 的 Node 型数组”</li>
</ul>
</li>
<li><p>初始化静态链表：</p>
<ul>
<li>把 a[0] 的 next 设为-1。</li>
<li>把其他结点的 next 设为一个特殊的值来表示空闲，如-2。</li>
</ul>
</li>
<li><p>查找：从头结点出发依次往后遍历结点。</p>
</li>
<li><p>插入位序为i的结点：</p>
<ol>
<li>找到一个空的结点，存入数据元素。</li>
<li>从头结点出发找到位序为 i-1 的结点。</li>
<li>修改新结点的 next。</li>
<li>修改 i-1 号结点的 next。</li>
</ol>
</li>
<li><p>删除某个结点：</p>
<ol>
<li>从头结点出发找到前驱结点。</li>
<li>修改前驱结点的游标。</li>
<li>被删除结点的 next 设为-2。</li>
</ol>
</li>
<li><p>静态链表的优点：增删操作不需要大量移动元素</p>
</li>
<li><p>静态链表的缺点：</p>
<ul>
<li>不能随机存取，只能从头结点开始依次往后查找。</li>
<li><strong>容量固定不可变。</strong></li>
</ul>
</li>
</ul>
<h1 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h1><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ul>
<li>都属于线性表，都是线性结构。</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><ul>
<li>顺序表：<ul>
<li>优点：支持随机存取、存储密度高。</li>
<li>缺点：大片连续空间分配不方便，改变容量不方便。</li>
</ul>
</li>
<li>链表：<ul>
<li>优点：离散的小空间分配方便，改变容量方便。</li>
<li>缺点：不可随机存取，存储密度低。</li>
</ul>
</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>初始化：<ul>
<li>顺序表：需要预分配大片连续空间。若分配内存过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源。<ul>
<li>静态分配：静态数组：容量不可改变。</li>
<li>动态分配：动态数组（malloc、free）：容量可以改变，但需要移动大量元素，时间代价高。</li>
</ul>
</li>
<li>链表：只需分配一个头结点（也可以不要头结点，只声明一个头指针），以后方便拓展。</li>
</ul>
</li>
<li>销毁：<ul>
<li>顺序表：修改<code>length</code>&#x3D;0。<ul>
<li>静态分配（静态数组）：系统自动回收空间。</li>
<li>动态分配（动态数组：malloc、free）：需要手动 free。</li>
</ul>
</li>
<li>链表：依次删除各个结点（free）。</li>
</ul>
</li>
<li>插入删除：<ul>
<li>顺序表：需要将后续元素后移&#x2F;前移。<ul>
<li>时间复杂度：O(n)。时间开销主要来自于移动元素。若数据元素很大，则移动的时间代价很高。</li>
</ul>
</li>
<li>链表：只需要修改指针。<ul>
<li>时间复杂度：O(n)。时间开销主要来自于查找元素。查找元素的时间代价更低。</li>
</ul>
</li>
</ul>
</li>
<li>查找：<ul>
<li>顺序表：<ul>
<li>按位查找：O(1)</li>
<li>按值查找：O(n)。若表内元素有序，则可在O(log<sub>2</sub>n)时间内找到。</li>
</ul>
</li>
<li>链表：<ul>
<li>按位查找：O(n)</li>
<li>按值查找：O(n)</li>
</ul>
</li>
</ul>
</li>
<li>表长难以预估、经常要增加&#x2F;删除元素：链表。</li>
<li>表长可预估、查询（搜索）操作较多：顺序表。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>第六章 图</title>
    <url>/2024/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><ul>
<li><strong>图 G</strong> 由<strong>顶点集 V</strong> 和<strong>边集 E</strong> 组成，记为 G &#x3D; (V, E)，其中 V(G) 表示图 G 中顶点的有限非空集；E(G) 表示图 G 中顶点之间的关系（边）集合。若 V &#x3D; {v<sub>1</sub>, v<sub>2</sub>, …, v<sub>n</sub>}，则用 |V| 表示图 G 中<strong>顶点的个数</strong>，也称<strong>图 G 的阶</strong>，E &#x3D; {(u, v) | u ∈ U, v ∈ V}，用 <strong>|E|</strong> 表示图 G 中<strong>边的条数</strong>。</li>
<li>线性表可以是空表，树可以是空树，但图不可以是空，即 <strong>V 一定是非空集</strong>。而 <strong>E 可以为空集</strong>。</li>
<li>若 E 是<strong>无向边</strong>（简称<strong>边</strong>）的有限集合时，则图 G 为<strong>无向图</strong>。边是顶点的无序对，**记为(v, w)或(w, v)<strong>，因为</strong>(v, w) &#x3D; (w, v)**，其中 v、w 是顶点。可以说顶点 w 和顶点 v 互为邻接点。边(v, w)依附于顶点 w 和 v，或者说边(v, w)和顶点 v、w 相关联。</li>
<li>若 E 是<strong>有向边</strong>（也称<strong>弧</strong>）的有限集合时，则图 G 为<strong>有向图</strong>。弧是顶点的有序对，<strong>记为&lt;v, w&gt;<strong>，其中 v、w 是顶点，v 称为</strong>弧尾</strong>，w 称为<strong>弧头</strong>，&lt;v, w&gt; 称为从顶点 v 到顶点 w 的弧，也称 v 邻接到 w，或 w 邻接自 v。**&lt;v, w&gt; !&#x3D; &lt;w, v&gt;**。</li>
<li>简单图<ul>
<li>不存在重复边</li>
<li>不存在顶点到自身的边</li>
</ul>
</li>
<li>多重图：图 G 中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则 G 为多重图。</li>
<li>对于无向图：<ul>
<li>顶点 v 的度是指依附于该顶点的边的条数，记为 TD(v)</li>
<li>在具有 n 个顶点、e 条边的无向图中，$\sum\limits_{i&#x3D;1}^nTD(V_i) &#x3D; 2e$，即无向图的全部顶点的度的和等于边数的2倍。</li>
</ul>
</li>
<li>对于有向图：<ul>
<li>入度是以顶点 v 为终点的有向边的数目，记为 ID(v)</li>
<li>出度是以顶点 v 为起点的有向边的数目，记为 OD(v)</li>
<li>顶点的 v 的度等于其入度和出度之和，即 TD(v) &#x3D; ID(v) + OD(v)</li>
<li>在具有 n 个顶点、 e 条边的有向图中， $\sum\limits_{i&#x3D;1}^nID(V_i) &#x3D; \sum\limits_{i&#x3D;1}^nOD(V_i) &#x3D; e$</li>
</ul>
</li>
<li><strong>路径</strong>——顶点 v<sub>p</sub> 到顶点 v<sub>p</sub> 之间的一条路径是指顶点序列，V<sub>p</sub>, V<sub>i1</sub>, V<sub>i2</sub>, …, V<sub>q</sub>。</li>
<li><strong>回路</strong>——第一个顶点和最后一个顶点相同的路径称为回路或环。</li>
<li><strong>简单路径</strong>——在路径序列中，顶点不重复出现的路径称为简单路径。</li>
<li><strong>简单回路</strong>——除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</li>
<li><strong>路径长度</strong>——路径上边的数目。</li>
<li><strong>点到点的距离</strong>——从顶点 u 出发到顶点 v 的<strong>最短路径</strong>若存在，则<strong>此路径的长度称为从 u 到 v 的距离</strong>；若从 u 到 v 根本<strong>不存在路径</strong>，则记<strong>该距离为无穷（∞）</strong>。</li>
<li><strong>无向图</strong>中，若从顶点 v 到顶点 w 有路径存在，则称 v 和 w 是<strong>连通</strong>的。若图 G 中任意两个顶点都是连通的，则称图 G 为<strong>连通图</strong>，否则称为<strong>非连通图</strong>。<ul>
<li>对于 n个顶点的<strong>无向图</strong> G，<ul>
<li>若 G 是<strong>连通图</strong>，则<strong>最少</strong>有 n-1 条边</li>
<li>若 G 是<strong>非连通图</strong>，则<strong>最多</strong>可能有 $C_{n-1}^2$条边</li>
</ul>
</li>
</ul>
</li>
<li><strong>有向图</strong>中，若从顶点 v 到顶点 w 和从顶点 w 到顶点 v之间都有路径，则称这两个顶点是<strong>强连通</strong>的。<ul>
<li>对于 n 个顶点的有向图 G，若 G 是<strong>强连通图</strong>，则<strong>最少</strong>有 n 条边（形成<strong>回路</strong>）</li>
</ul>
</li>
<li>设有两个图 G &#x3D; (V, E) 和 G’ &#x3D; (V’, E’)，若 V‘ 是 V 的子集，且 E’ 是 E 的子集，则称 G’ 是 G 的<strong>子图</strong>。</li>
<li>若有满足 V(G’) &#x3D; V(G) 的子图 G’，则称其为 G 的<strong>生成子图</strong>。</li>
<li><strong>无向图</strong>中的<strong>极大连通子图</strong>（子图必须连通，且包含尽可能多的顶点和边）称为无向图的<strong>连通分量</strong>。</li>
<li><strong>有向图</strong>中的<strong>极大强连通子图</strong>（子图必须强连通，同时保留尽可能多的边）称为有向图的<strong>强连通分量</strong>。</li>
<li><strong>连通图</strong>的<strong>生成树</strong>是<strong>包含图中全部顶点的一个极小连通子图</strong>（边尽可能的少，但要保持连通）。若图中顶点树为 n，则它的生成树含有 n-1 条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。</li>
<li>在<strong>非连通图</strong>中，<strong>连通分量的生成树</strong>构成了非连通图的<strong>生成森林</strong>。</li>
<li><strong>边的权</strong>——在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。</li>
<li><strong>带权图&#x2F;网</strong>——边上带有权值的图称为<strong>带权图</strong>，也称<strong>网</strong>。</li>
<li><strong>带权路径长度</strong>——当图是带权图时，一条<strong>路径上所有边的权值之和</strong>，称为该路径的带权路径长度。</li>
<li><strong>无向完全图</strong>——无向图中任意两个顶点之间都存在边。<ul>
<li>若无向图的顶点数 |V| &#x3D; n，则 |E|∈[0, $C^2_n$] &#x3D; [0, n(n-1)&#x2F;2]</li>
</ul>
</li>
<li><strong>有向完全图</strong>——有向图中任意两个顶点之间都存在方向相反的两条弧。<ul>
<li>若有向图的顶点数 |V| &#x3D; n，则 |E|∈[0, 2$C^2_n$] &#x3D; [0, n(n-1)]</li>
</ul>
</li>
<li>边数很少的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong>。二者没有绝对的界限，一般来说 |E| &lt; |V|log|V| 时，可以将 G 视为稀疏图。</li>
<li><strong>树</strong>——<strong>不存在回路</strong>，且<strong>连通</strong>的<strong>无向图</strong><ul>
<li>n 个顶点的树，必有 n-1 条边</li>
<li>n 个顶点的图，<strong>若 |E| &gt; n-1，则一定有回路</strong></li>
</ul>
</li>
<li><strong>有向树</strong>——一个顶点的入度为0，其余顶点的入度均为1的<strong>有向图</strong>，称为有向树。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>第五章 树与二叉树</title>
    <url>/2024/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h1><h2 id="数的定义和基本术语"><a href="#数的定义和基本术语" class="headerlink" title="数的定义和基本术语"></a>数的定义和基本术语</h2><ul>
<li>树：从树根生发，逐级分支。</li>
<li>空树：结点数为0的树。</li>
<li>非空树的特性：<ul>
<li>有且仅有一个根结点。</li>
<li>没有后继的结点称为“叶子结点”（或终端结点）。</li>
<li>有后继的结点称为“分支结点”（或非终端结点）。</li>
<li>除了根结点外，任何一个结点都<strong>有且仅有一个</strong>前驱。</li>
<li>每个结点可以有一个或多个后驱。</li>
</ul>
</li>
<li>树是 n （n &gt;&#x3D; 0）个<strong>结点</strong>的有限集合，n &#x3D; 0 时，称为<strong>空树</strong>，这是一种特殊情况。在任意一颗<strong>非空树</strong>中应满足：<ol>
<li>有且仅有一个特定的称为<strong>根</strong>的结点。</li>
<li>当 n &gt; 1 时，其余结点可分为 m (m &gt; 0)个<strong>互不相交的有限集合</strong> T<sub>1</sub>,T<sub>2</sub>,…T<sub>m</sub>，其中每个集合本身又是一颗树，并且称为根结点的<strong>子树</strong>。</li>
</ol>
</li>
<li>树是递归定义的数据结构。</li>
<li>结点之间的关系描述：<ul>
<li>祖先结点</li>
<li>子孙结点</li>
<li>双亲结点（父结点）</li>
<li>孩子结点</li>
<li>兄弟结点</li>
<li>堂兄弟结点</li>
<li>两个结点之间的<strong>路径</strong>：只能从上往下</li>
<li><strong>路径长度</strong>：经过几条边</li>
</ul>
</li>
<li>结点和树的属性描述：<ul>
<li>结点的层次（深度）——从上往下数</li>
<li>结点的高度——从下往上数</li>
<li>树的高度（深度）——总共多少层</li>
<li><strong>结点的度</strong>——有几个孩子（分支）</li>
<li><strong>树的度</strong>——各结点的度的最大值</li>
</ul>
</li>
<li>有序树：逻辑上看，树中结点的各子树从左至右是<strong>有次序的</strong>，不能互换。</li>
<li>有序树：逻辑上看，树中结点的各子树从左至右是<strong>无次序的</strong>，不能互换。</li>
<li>森林：森林是 m(M &gt;&#x3D; 0)棵互不相交的树的集合。</li>
</ul>
<h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><ul>
<li><p>结点数 &#x3D; 总度数 + 1</p>
</li>
<li><p>树的度——各结点度的最大值</p>
</li>
<li><p>m叉树——每个结点最多只能有m个孩子的树</p>
</li>
<li><table>
<thead>
<tr>
<th>度为 m 的树</th>
<th>m 叉树</th>
</tr>
</thead>
<tbody><tr>
<td>任意结点的度 &lt;&#x3D; m（最多 m 个孩子）</td>
<td>任意结点的度 &lt;&#x3D; m（最多 m 个孩子）</td>
</tr>
<tr>
<td>至少有一个结点度 &#x3D; m（有 m 个孩子）</td>
<td>允许所有结点的度都 &lt;  m</td>
</tr>
<tr>
<td>一定是非空树，至少有 m + 1 个结点</td>
<td>可以是空树</td>
</tr>
</tbody></table>
</li>
<li><p>度为 m 的树第 i 层至多有 m<sup>i-1</sup>个结点（i &gt;&#x3D; 1）</p>
<ul>
<li>m 叉树第 i 层至多有m<sup>i-1</sup>个结点（i &gt;&#x3D; 1）</li>
</ul>
</li>
<li><p>高度为 h 的 m 叉树至多有$\frac{m^h-1}{m-1}$（等比求和）</p>
</li>
<li><p>高度为 h 的 m 叉树至少有 h 个结点；高度为 h 同时度为 m 的树至少有 h+m-1 个结点。</p>
</li>
<li><p>具有 n 个结点的 m 叉树的最小高度为 log<sub>m</sub>(n(m-1)+1)。</p>
</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的定义和基本术语"><a href="#二叉树的定义和基本术语" class="headerlink" title="二叉树的定义和基本术语"></a>二叉树的定义和基本术语</h2><ul>
<li>m 叉树是 n （n &gt;&#x3D; 0）个结点的有限集合：<ul>
<li>或者为<strong>空二叉树</strong>，即 n &#x3D; 0。</li>
<li>或者由一个<strong>根结点</strong>和两个互不相交的被称为根的<strong>左子树</strong>和<strong>右子树</strong>组成。左子树和右子树分别是一颗二叉树。</li>
<li>特点：<ul>
<li>每个结点至多只有两棵子树</li>
<li>左右子树不能颠倒（二叉树<strong>是有序树</strong>）</li>
</ul>
</li>
</ul>
</li>
<li>二叉树是递归定义的数据结构。</li>
<li>二叉树的五种状态：<ul>
<li>空二叉树</li>
<li>只有左子树</li>
<li>只有右子树</li>
<li>只有根结点</li>
<li>左右子树都有</li>
</ul>
</li>
<li>几个特殊的二叉树：<ul>
<li><strong>满二叉树</strong>。一棵高度为 h，且含有2<sup>h</sup>-1个结点的二叉树。特点：<ul>
<li>只有最后一层有叶子结点。</li>
<li>不存在度为1的结点。</li>
<li>按层序从1开始编号，结点 i 的左孩子为 2i，右孩子为 2i+1；结点 i 的父结点为 i&#x2F;2。</li>
</ul>
</li>
<li><strong>完全二叉树</strong>。当且进当其每个结点都与高度为 h 的满二叉树中编号为 1~n 的结点一一对应时，称为完全二叉树。特点：<ul>
<li>只有最后两层可能有叶子结点。</li>
<li>最多只有一个度为1的结点。</li>
<li>按层序从1开始编号，结点 i 的左孩子为 2i，右孩子为 2i+1；结点 i 的父结点为 i&#x2F;2。</li>
<li>i &lt;&#x3D; n&#x2F;2 为分支结点，i &gt; n&#x2F;2 为叶子结点。</li>
<li>如果某结点只有一个孩子，那么一定是左孩子。</li>
</ul>
</li>
<li><strong>二叉排序树</strong>。一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：<ul>
<li><strong>左子树</strong>上所有结点的<strong>关键字</strong>均<strong>小于根结点</strong>的关键字。</li>
<li><strong>右子树</strong>上所有结点的<strong>关键字</strong>均<strong>大于根结点</strong>的关键字。</li>
<li>左子树和右子树又各是一颗二叉排序树。</li>
</ul>
</li>
<li><strong>平衡二叉树</strong>。树上任一结点的<strong>左子树</strong>和<strong>右子树</strong>的<strong>深度之差不超过1</strong>。<ul>
<li>平衡二叉树能有更高的搜索效率。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ul>
<li>设非空二叉树度为0、1和2的结点个数分别为n<sub>0</sub>、n<sub>1</sub>和n<sub>2</sub>，则 n<sub>0</sub> &#x3D; n<sub>2</sub> + 1（叶子结点比二分支结点多一个）</li>
<li>二叉树第 i 层至多有 2<sup>i-1</sup>个结点（i &gt;&#x3D; 1）</li>
<li>高度为 h 的二叉树至多有$2^h-1$（等比求和）</li>
<li>具有 n 个(n &gt; 0)结点的完全二叉树的高度 h 为 log<sub>2</sub>(n+1) 或 log<sub>2</sub>n + 1</li>
<li>对于完全二叉树，可以由结点数 n 推出度为0、1和2的结点个数分别为n<sub>0</sub>、n<sub>1</sub>和n<sub>2</sub><ul>
<li>完全二叉树最多只有一个度为1的结点，即 n<sub>1</sub> &#x3D; 0或1，而n<sub>0</sub> &#x3D; n<sub>2</sub> + 1故n<sub>0 </sub>+ n<sub>2</sub> 一定是奇数<ul>
<li>若完全二叉树有 2k （偶数）个结点，则必有n<sub>1</sub> &#x3D; 1，n<sub>0</sub> &#x3D; k，n<sub>2</sub> &#x3D; k-1</li>
<li>若完全二叉树有 2k-1 （奇数）个结点，则必有n<sub>1</sub> &#x3D; 0，n<sub>0</sub> &#x3D; k，n<sub>2</sub> &#x3D; k-1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h3><ul>
<li><p>顺序存储的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    ElemType value;	<span class="comment">//结点中的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;	<span class="comment">//结点是否为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode t[MaxSize];</span><br></pre></td></tr></table></figure>

<p>定义一个长度为 MaxSize 的数组 t，按照从上至下、从左至右的顺序依次存储<strong>完全二叉树</strong>中的各个结点。</p>
</li>
<li><p>几个重要的基本操作</p>
<ul>
<li>i 的左孩子—— 2i</li>
<li>i 的右孩子—— 2i+1</li>
<li>i 的父结点—— i&#x2F;2</li>
<li>i 所在的层次—— log<sub>2</sub>(n+1))或 log<sub>2</sub>n + 1</li>
</ul>
</li>
<li><p>若<strong>完全二叉树</strong>中共有 n 个结点</p>
<ul>
<li>判断 i 是否有左孩子——2i &lt;&#x3D; n</li>
<li>判断 i 是否有右孩子——2i+1 &lt;&#x3D; n</li>
<li>判断 i 是否是叶子或分支结点——i &gt; n&#x2F;2</li>
</ul>
</li>
<li><p>如果不是<strong>完全二叉树</strong>，依然按层序将各结点顺序存储，则无法从结点编号反映出结点间的逻辑关系。</p>
</li>
<li><p>二叉的顺序存储中，一定要把二叉树的结点编号与<strong>完全二叉树</strong>对应起来。</p>
</li>
<li><p>最坏情况：高度为 h 且只有 h 个结点的单支树（所有结点只有右孩子），也至少需要 2<sup>h</sup>-1个存储单元。</p>
</li>
</ul>
<h3 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h3><ul>
<li><p>链式存储的代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;	<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<p>n 个结点的二叉链表共有 n+1 个空链域。</p>
</li>
<li><p>二叉树的建立</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ElemType</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一棵空树</span></span><br><span class="line">BiTree root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根结点</span></span><br><span class="line">root = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));</span><br><span class="line">root-&gt;data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode * p = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;lchild = p;	<span class="comment">//作为根结点的左孩子</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>三叉链表——方便找父结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;	<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">//左、右孩子指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span>	<span class="comment">//父结点指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二叉树的先-中-后序遍历"><a href="#二叉树的先-中-后序遍历" class="headerlink" title="二叉树的先&#x2F;中&#x2F;后序遍历"></a>二叉树的先&#x2F;中&#x2F;后序遍历</h2><ul>
<li><p>遍历：按照某种次序把所有结点都访问一遍。</p>
</li>
<li><p>层次遍历：基于树的层次特性确定的次序规则。</p>
</li>
<li><p>先&#x2F;中&#x2F;后序遍历：基于树的递归特性确定的次序规则。</p>
<ul>
<li>先序遍历：根左右（NLR）</li>
<li>中序遍历：左根右（LNR）</li>
<li>后序遍历：左右根（LRN）</li>
</ul>
</li>
<li><p>二叉树的递归特性：</p>
<ul>
<li>要么是个空二叉树。</li>
<li>要么就是由“根结点+左子树+右子树”组成的二叉树。</li>
</ul>
</li>
<li><p>算术表达式的“分析树”</p>
<ul>
<li>先序遍历：根左右 -&gt; 前缀表达式</li>
<li>中序遍历：左根右 -&gt; 中缀表达式（需要加界限符）</li>
<li>后序遍历：左右根 -&gt; 后缀表达式</li>
</ul>
</li>
<li><p><strong>先序遍历</strong>的代码实现</p>
<ol>
<li>若二叉树为空，则什么都不做</li>
<li>若二叉树非空：<ol>
<li>访问根节点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        visit(T);	<span class="comment">//访问根结点</span></span><br><span class="line">        PreOrder(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>中序遍历</strong>的代码实现</p>
<ol>
<li>若二叉树为空，则什么都不做</li>
<li>若二叉树非空：<ol>
<li>先序遍历左子树</li>
<li>访问根节点</li>
<li>先序遍历右子树</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        InOrder(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        visit(T);	<span class="comment">//访问根结点</span></span><br><span class="line">        InOrder(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>后序遍历</strong>的代码实现</p>
<ol>
<li>若二叉树为空，则什么都不做</li>
<li>若二叉树非空：<ol>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
<li>访问根节点</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        PostOrder(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">        visit(T);	<span class="comment">//访问根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先序遍历——第一次路过时访问结点</p>
</li>
<li><p>中序遍历——第二次路过时访问结点</p>
</li>
<li><p>后序遍历——第三次路过时访问结点</p>
</li>
<li><p>应用：求树的深度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="comment">//树的深度 = Max(左子树深度，右子树深度)+1</span></span><br><span class="line">        <span class="keyword">return</span> l &gt; r ? l+<span class="number">1</span> : r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><ul>
<li><p>算法思想：</p>
<ol>
<li>初始化一个辅助<strong>队列</strong></li>
<li>根结点入队</li>
<li>若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾（如果有的话）</li>
<li>重复上一步直至队列为空</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点（链式存储）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    BiTNode * data;	<span class="comment">//存指针而不是结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *front, *rear;	<span class="comment">//队头队尾</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);	<span class="comment">//初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q, T);	<span class="comment">//将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(Q)) &#123;	<span class="comment">//队列不空则循环</span></span><br><span class="line">        DeQueue(Q, p);	<span class="comment">//队列结点出队</span></span><br><span class="line">        visit(p);	<span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q, p-&gt;lchild);	<span class="comment">//左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q, p-&gt;rchild);	<span class="comment">//右孩子入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><ul>
<li>一个中&#x2F;前&#x2F;后&#x2F;层序遍历序列可能对应<strong>多种</strong>二叉树形态。<strong>中序</strong> + 前&#x2F;后&#x2F;层序遍历可得到唯一二叉树。</li>
<li>由前序&#x2F;后序&#x2F;层序找到树的根结点，并根据中序序列划分左右子树，再找到左右子树根结点。</li>
</ul>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><ul>
<li><p>如何找到指定结点 p 在中序遍历序列中的前驱和后继：从根结点出发，重新进行一次中序遍历，指针 q 记录当前访问的结点，指针 pre 记录上一个被访问的结点。</p>
</li>
<li><p>当 q &#x3D;&#x3D; p 时，pre 为前驱。</p>
</li>
<li><p>当 pre &#x3D;&#x3D; p 时，q 为后继。</p>
</li>
<li><p>中序线索二叉树：</p>
<ul>
<li>前驱线索：左孩子指针充当</li>
<li>后继线索：右孩子指针充当</li>
</ul>
</li>
<li><p>线索二叉树的存储结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点（链式存储）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThtreadNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag, rtag;	<span class="comment">//左、右线索标志 tag:1 表示线索  tag:0 表示孩子</span></span><br><span class="line">&#125; TreadNode, *TreadTree;	</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二叉树线索化"><a href="#二叉树线索化" class="headerlink" title="二叉树线索化"></a>二叉树线索化</h2><ul>
<li><p>借用 pre 指针找到中序前驱</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        InOrder(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        visit(T);	<span class="comment">//访问根结点</span></span><br><span class="line">        InOrder(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点 q</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTNode *q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q == p)	<span class="comment">//当前访问结点刚好是结点 p</span></span><br><span class="line">        final = pre;	<span class="comment">//找到 p 的前驱</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        pre = q;	<span class="comment">//pre 指向当前访问的结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助全局变量，用于查找结点 p 的前驱</span></span><br><span class="line">BiTNode * p;	<span class="comment">//p 指向目标结点</span></span><br><span class="line">BiTNode * pre == <span class="literal">NULL</span>;	<span class="comment">//指向当前访问的结点的前驱</span></span><br><span class="line">BiTNode * final == <span class="literal">NULL</span>;	<span class="comment">//用于记录最终结果</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>中序线索化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量 pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树 T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span> &#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;	<span class="comment">//pre初始化为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;	<span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        InThread(T);	<span class="comment">//中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;	<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThtreadNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag, rtag;	<span class="comment">//左、右线索标志 tag:1 表示线索  tag:0 表示孩子</span></span><br><span class="line">&#125; TreadNode, *TreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        InThread(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        visit(T);	<span class="comment">//访问根结点</span></span><br><span class="line">        InThread(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;	<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;	<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先序线索化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量 pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树 T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatePreThread</span><span class="params">(ThreadTree T)</span> &#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;	<span class="comment">//pre初始化为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;	<span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">       PreThread(T);	<span class="comment">//先序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;	<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThtreadNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag, rtag;	<span class="comment">//左、右线索标志 tag:1 表示线索  tag:0 表示孩子</span></span><br><span class="line">&#125; TreadNode, *TreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        visit(T);	<span class="comment">//访问根结点</span></span><br><span class="line">        <span class="keyword">if</span> (T-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        	PreThread(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreThread(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;	<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;	<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序线索化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量 pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序线索化二叉树 T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatePostThread</span><span class="params">(ThreadTree T)</span> &#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;	<span class="comment">//pre初始化为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;	<span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">       PostThread(T);	<span class="comment">//后序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;	<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThtreadNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag, rtag;	<span class="comment">//左、右线索标志 tag:1 表示线索  tag:0 表示孩子</span></span><br><span class="line">&#125; TreadNode, *TreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PreThread(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreThread(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">        visit(T);	<span class="comment">//访问根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;	<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;	<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线索二叉树——找前驱-后继"><a href="#线索二叉树——找前驱-后继" class="headerlink" title="线索二叉树——找前驱&#x2F;后继"></a>线索二叉树——找前驱&#x2F;后继</h2><ul>
<li><p>在中序线索二叉树中找到指定结点 *p 的中序后继 next</p>
<ul>
<li>若 p-&gt;rtag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;rchild</li>
<li>若 p-&gt;rtag &#x3D;&#x3D; 0，则 next &#x3D; p的右子树中最左下结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到以 p 为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span> &#123;</span><br><span class="line">    <span class="comment">//循环找到最左下结点（不一定是叶结点）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在中序线索二叉树中找到结点 p 的后继结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Nextnode</span><span class="params">(ThreadNode *p)</span> &#123;</span><br><span class="line">    <span class="comment">//右子树中最左下结点</span></span><br><span class="line">    <span class="keyword">if</span>  (p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;	<span class="comment">//rtag == 1直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行中序遍历（利用线索实现的非递归算法）	空间复杂度：O(1)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadNode *T)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = Firstnode(T); p != <span class="literal">NULL</span>; p = Nextnode(p))</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在中序线索二叉树中找到指定结点 *p 的中序前驱 pre</p>
<ul>
<li>若 p-&gt;ltag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;lchild</li>
<li>若 p-&gt;ltag &#x3D;&#x3D; 0，则 next &#x3D; p的左子树中最右下结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到以 p 为根的子树中，最后一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Lastnode</span><span class="params">(ThreadNode *p)</span> &#123;</span><br><span class="line">    <span class="comment">//循环找到最右下结点（不一定是叶结点）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在中序线索二叉树中找到结点 p 的前驱结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Prenode</span><span class="params">(ThreadNode *p)</span> &#123;</span><br><span class="line">    <span class="comment">//左子树中最右下结点</span></span><br><span class="line">    <span class="keyword">if</span>  (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Firstnode(p-&gt;lchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild;	<span class="comment">//rtag == 1直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RevInorder</span><span class="params">(ThreadNode *T)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = Lastnode(T); p != <span class="literal">NULL</span>; p = Prenode(p))</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在先序线索二叉树中找到指定结点 *p 的先序后继 next</p>
<ul>
<li>若 p-&gt;rtag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;rchild</li>
<li>若 p-&gt;rtag &#x3D;&#x3D; 0，则 <ul>
<li>若 p 有左孩子，则先序后继为左孩子</li>
<li>若 p 没有左孩子，则先序后继为右孩子</li>
</ul>
</li>
</ul>
</li>
<li><p>在先序线索二叉树中找到指定结点 *p 的先序前驱 pre</p>
<ul>
<li>若 p-&gt;ltag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;lchild</li>
<li>若 p-&gt;ltag &#x3D;&#x3D; 0，则<ul>
<li>p 必有左孩子。由于先序遍历中左右子树中的结点只可能是根的后继，不可能是前驱。只能从头开始先序遍历找前驱。</li>
<li>若改用三叉链表可以找到父节点<ul>
<li>p 为左孩子，则 p 的父结点即为其前驱</li>
<li>p 为右孩子，<ul>
<li>其左兄弟为空，则 p 的父结点即为其前驱</li>
<li>其左兄弟非空，则 p 的前驱为左兄弟子树中最后一个被先序遍历的结点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在后序线索二叉树中找到指定结点 *p 的后序前驱 pre</p>
<ul>
<li>若 p-&gt;ltag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;lchild</li>
<li>若 p-&gt;ltag &#x3D;&#x3D; 0，则 p 必有左孩子<ul>
<li>若 p 有右孩子，则后序前驱为右孩子</li>
<li>若 p 没有右孩子，则后序前驱为左孩子</li>
</ul>
</li>
</ul>
</li>
<li><p>在后序线索二叉树中找到指定结点 *p 的先序后继 next</p>
<ul>
<li>若 p-&gt;rtag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;rchild</li>
<li>若 p-&gt;rtag &#x3D;&#x3D; 0，则 <ul>
<li>p 必有右孩子。由于先序遍历中左右子树中的结点只可能是根的后继，不可能是前驱。只能从头开始先序遍历找前驱。</li>
<li>若改用三叉链表可以找到父节点<ul>
<li>p 为右孩子，则 p 的父结点即为其前驱</li>
<li>p 为左孩子，<ul>
<li>其右兄弟为空，则 p 的父结点即为其前驱</li>
<li>其右兄弟非空，则 p 的前驱为右兄弟子树中第一个被后序遍历的结点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h1><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><ul>
<li><p>双亲表表示法（顺序存储）</p>
<ul>
<li>用数组顺序存储各个结点。每个结点中保存<strong>数据元素、指向双亲结点（父节点）的“指针”</strong>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100	<span class="comment">//树中最多结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">//树的结点定义</span></span><br><span class="line">    ElemType data;	<span class="comment">//数据元素</span></span><br><span class="line">    <span class="type">int</span> parent;	<span class="comment">//双亲位置域</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];	<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> n;	<span class="comment">//结点数</span></span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优缺点：</p>
<ul>
<li><p>优点：找双亲（父结点）方便</p>
</li>
<li><p>缺点：找孩子不方便，只能从头到尾遍历整个数组</p>
</li>
<li><p>适用于“找父亲“多，”找孩子“少的应用场景。如：并查集</p>
</li>
</ul>
</li>
<li><p>双亲表示法也可表示<strong>森林</strong>，每棵树的根结点双亲指针 &#x3D; -1。</p>
</li>
</ul>
</li>
<li><p>孩子表示法（顺序存储 + 链式存储）</p>
<ul>
<li>用数组顺序存储各个节点。每个结点中保存<strong>数据元素、孩子链表头指针</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> child;	<span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>	<span class="comment">//下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>	<span class="comment">//第一个孩子</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n, r;</span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure>

<ul>
<li>优缺点：<ul>
<li>优点：找孩子很方便</li>
<li>缺点：找双亲（父结点）不方便，只能遍历每个链表</li>
<li>适用于“找父亲“少，”找孩子“多的应用场景。如：服务流程树</li>
</ul>
</li>
<li>用孩子表示法存储<strong>森林</strong>，需要记录多个根的位置。</li>
</ul>
</li>
<li><p>孩子兄弟表示法（链式存储）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure>

<ul>
<li>树的孩子兄弟表示法与二叉树类似，采用<strong>二叉链表</strong>实现。每个结点内保存<strong>数据元素</strong>和<strong>两个指针</strong>，但两个指针的含义和二叉树结点不同。</li>
<li>存储<strong>森林</strong>时，森林中每棵树的根结点视为平级的兄弟关系。</li>
</ul>
</li>
</ul>
<h2 id="树、森林和二叉树的转化"><a href="#树、森林和二叉树的转化" class="headerlink" title="树、森林和二叉树的转化"></a>树、森林和二叉树的转化</h2><ul>
<li>树转换为二叉树<ol>
<li>先在二叉树中，画一个根结点。</li>
<li>按“树的层序”依次处理每个结点。<ul>
<li>处理一个结点的方法是：如果当前处理的结点在树中有孩子，就把所有孩子结点用右指针串成一串，并在二叉树中把第一个孩子挂在当前结点的左指针上。</li>
</ul>
</li>
</ol>
</li>
<li>森林转换为二叉树<ol>
<li>先把所有树的根结点画出来，在二叉树中用右指针串成一串。</li>
<li>按“森林的层序”依次处理每个结点。<ul>
<li>处理一个结点的方法是：如果当前处理的结点在树中有孩子，就把所有孩子结点用右指针串成一串，并在二叉树中把第一个孩子挂在当前结点的左指针上。</li>
</ul>
</li>
</ol>
</li>
<li>二叉树转换为树</li>
</ul>
<ol>
<li>先画出树的根结点</li>
<li>从树的根结点开始，按“树的层序”恢复每个结点的孩子<ul>
<li>如何恢复一个结点的孩子，在二叉树中，如果当前处理的结点有左孩子，就把左孩子和一整串右指针拆下来，按顺序挂在当前结点的下面。</li>
</ul>
</li>
</ol>
<ul>
<li>二叉树转换为森林<ol>
<li>先把二叉树的根结点和一整串右指针拆下来，作为多棵树的根结点</li>
<li>按“森林的层序”恢复每个结点的孩子<ul>
<li>如何恢复一个结点的孩子，在二叉树中，如果当前处理的结点有左孩子，就把左孩子和一整串右指针拆下来，按顺序挂在当前结点的下面。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="树、森林的遍历"><a href="#树、森林的遍历" class="headerlink" title="树、森林的遍历"></a>树、森林的遍历</h2><ul>
<li><p>树的先根遍历（深度优先遍历）。若树非空，先访问根结点，再依次对每棵子树进行先根遍历。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树的先根遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (R != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        visit(R);	<span class="comment">//访问根结点</span></span><br><span class="line">        <span class="keyword">while</span> (R 还有下一个子树 T)</span><br><span class="line">            Prerder(T);	<span class="comment">//先根遍历下一棵子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>树的后根遍历（深度优先遍历）。若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树的后根遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode *R)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (R != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (R 还有下一个子树 T)</span><br><span class="line">            Prerder(T);	<span class="comment">//后根遍历下一棵子树</span></span><br><span class="line">        visit(R);	<span class="comment">//访问根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树的后根遍序列与这棵树相应二叉树的中序序列相同。</p>
</li>
<li><p>数的层次遍历（用队列实现）（广度优先遍历）</p>
<ol>
<li>若树非空，则根结点入队</li>
<li>若队列非空，队头元素出队并访问，同时该元素的孩子依次入队</li>
<li>重复上一步直至队空</li>
</ol>
</li>
<li><p>先序遍历森林。</p>
<ul>
<li>若森林为非空，则按如下规则进行遍历：<ul>
<li>访问森林中第一棵树的根结点</li>
<li>先序遍历第一棵树中根结点的子树森林</li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林</li>
</ul>
</li>
<li>效果等同于依次对二叉树的先序遍历。</li>
</ul>
</li>
<li><p>中序遍历森林。</p>
<ul>
<li>若森林为非空，则按如下规则进行遍历：<ul>
<li>中序遍历森林中第一棵树的根结点的子树森林</li>
<li>访问第一棵树的根结点</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林</li>
</ul>
</li>
<li>效果等同于依次对各个树进行后根遍历</li>
<li>转化为二叉树后效果等同于依次对二叉树的中序遍历</li>
</ul>
</li>
</ul>
<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><ul>
<li>结点的<strong>权</strong>：有某种现实含义的数值（如：表示结点的重要性等）</li>
<li><strong>结点的带权路径长度</strong>：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积</li>
<li><strong>树的带权路径长度</strong>：树中所有<strong>叶结点</strong>的带权路径长度之和（WPL，Weighted Path Length）</li>
<li>在含有 n 个带权叶结点的二叉树中，其中<strong>带权路径长度（WPL）最小的二叉树</strong>称为<strong>哈夫曼树</strong>，也称<strong>最优二叉树</strong>。</li>
<li>哈夫曼树的构造：给定 n 个权值分别为 w<sub>1</sub>，w<sub>2</sub>，…，w<sub>n</sub> 的结点。<ol>
<li>将这 n 个结点分别作为 n 棵仅含一个结点的二叉树，构成森林 F。</li>
<li>构造一个新结点，从 F 中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。</li>
<li>从 F 中删除刚才选出的两棵树，同时将新得到的树加入 F 中。</li>
<li>重复以上两步，直至 F 中只剩下一棵树为止。</li>
</ol>
</li>
<li>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。</li>
<li>哈夫曼树的结点总数为 2n-1。</li>
<li>哈夫曼树中不存在度为1的结点。</li>
<li>哈夫曼树并不唯一，但 WPL 必然相同且为最优。</li>
<li>固定长度编码——每个字符用相等长度的二进制位表示。</li>
<li>可变长度编码——允许对不同字符用不等长的二进制位表示。</li>
<li>若没有一个编码是另一个编码的前缀，则称这样的编码为<strong>前缀编码</strong>。非前缀编码有歧义。</li>
<li>由哈夫曼树得到哈夫曼编码——字符集中的每个字符作为一个叶子结点，每个字符出现的频度作为结点的权值，再构建哈夫曼树。</li>
</ul>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><ul>
<li><p>用互不相交的树，表示多个“集合”	</p>
<ul>
<li>如何“<strong>查</strong>”到一个元素到底属于哪一个集合——从指定元素出发，找到根结点</li>
<li>如何把两个集合“<strong>并</strong>”为一个集合——让一棵树成为另一棵树的子树即可</li>
</ul>
</li>
<li><p>“并查集”的存储结构：参考树的双亲表示法</p>
<ul>
<li>集合的两个基本操作——“并”和“查”<ul>
<li>Find——“查”操作：确定一个指定元素所属集合</li>
<li>Union——“并”操作：将两个不相交的集合合并为一个</li>
<li>并查集（Disjoint Set）是逻辑结构——集合的一种具体实现，只进行“并”和“查”两种基本操作</li>
</ul>
</li>
</ul>
</li>
<li><p>“并查集”的代码实现——初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 13</span></span><br><span class="line"><span class="type">int</span> UFSets[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化并查集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initial</span><span class="params">(<span class="type">int</span> S[])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">        S[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>“并查集”的代码实现——并、查</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Find “查”操作，找 x 所属集合（返回 x 所属根结点）	最坏时间复杂度：O(n)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x] &gt;= <span class="number">0</span>)	<span class="comment">//循环寻找 x 的根</span></span><br><span class="line">        x = S[x];</span><br><span class="line">    <span class="keyword">return</span> x;	<span class="comment">//根的S[]小于0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Union “并”操作，将两个集合合并为一个	时间复杂度：O(1)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> Root1, <span class="type">int</span> Root2)</span> &#123;</span><br><span class="line">    <span class="comment">//要求 Root1 与 Root2 是不同的集合</span></span><br><span class="line">    <span class="keyword">if</span> (Root1 == Root2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将根 Root2 连接到另一根 Root1 下面</span></span><br><span class="line">    S[Root2] = Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优化思路：在每次 Union 操作构建树的时候，尽量不让树长高</p>
<ul>
<li>用根结点的绝对值表示树的结点总数（例如 -6 而不是 -1）</li>
<li>Union 操作，让小树合并到大树</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Union “并”操作，小树合并到大树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> Root1, <span class="type">int</span> Root2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Root1 == Root2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (S[Root2] &gt; S[Root1]) &#123;	<span class="comment">//Root2 结点数更少</span></span><br><span class="line">        S[Root1] += S[Root2];	<span class="comment">//累加结点总数</span></span><br><span class="line">        S[Root2] = Root1;	<span class="comment">//小树合并到大树</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        S[Root2] += S[Root1];	<span class="comment">//累加结点总数</span></span><br><span class="line">        S[Root1] = Root2;	<span class="comment">//小树合并到大树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法构造的树高不超过 log<sub>2</sub>n+1</p>
</li>
<li><p>并查集的进一步优化</p>
<ul>
<li><p>Find 操作的优化（压缩路径）：先找到根结点，再将查找路径上所有结点都挂到根结点下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Find “查”操作优化，先找到根结点，再进行“压缩路径”</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> root = x;</span><br><span class="line">    <span class="keyword">while</span> (S[root] &gt;= <span class="number">0</span>)</span><br><span class="line">        root = S[root];	<span class="comment">//循环找到根</span></span><br><span class="line">    <span class="keyword">while</span> (x != root) &#123;	<span class="comment">//压缩路径	</span></span><br><span class="line">        <span class="type">int</span> t = S[x];	<span class="comment">//t 指向 x 的父结点下</span></span><br><span class="line">        S[x] = root;	<span class="comment">//x 直接挂到根结点下</span></span><br><span class="line">        x = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;	<span class="comment">//返回根结点编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次 Find 操作，先找根，再“压缩路径”，可使树的高度不超过 O(α(n))。α(n) 是一个增长很缓慢的函数，对于常见的 n 值，通常 α(n) &lt;&#x3D; 4，因此优化后并查集的 Find、Union 操作时间开销都很低。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>第四章 串</title>
    <url>/2024/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="定义和基本操作"><a href="#定义和基本操作" class="headerlink" title="定义和基本操作"></a>定义和基本操作</h1><ul>
<li><p><strong>串</strong>，即<strong>字符串（String）</strong>是由零个或多个<strong>字符</strong>组成的有限序列。一般记为 S &#x3D; ‘a<sub>1</sub>a<sub>2</sub>……a<sub>n</sub>‘（n &gt;&#x3D; 0)。其中，S 是<strong>串名</strong>，单引号（有的地方用双引号）括起来的字符序列是串的值；a<sub>i</sub>可以是字母、数字或其他字符；串中字符的个数 n 称为<strong>串的长度</strong>。n &#x3D; 0时的串称为<strong>空串</strong>（用∅表示）</p>
</li>
<li><p>子串：串中任意个连续的字符组成 的子序列。</p>
</li>
<li><p>主串：包含子串的串。</p>
</li>
<li><p>字符在主串中的位置：字符在串中的序号。</p>
</li>
<li><p>子串在主串中的位置：子串的第一个字符在主串中的位置。</p>
</li>
<li><p>空串和空格串：</p>
<ul>
<li>M &#x3D; ‘’（空串）</li>
<li>N &#x3D; ‘   ‘（三个空格符号组成的空格串，每个空格字符占1B）</li>
</ul>
</li>
<li><p>串是一种特殊的线性表，数据元素之间呈线性关系。</p>
</li>
<li><p>串的数据对象限定为字符集（如中文字符、英文字符、数字字符和标点符号等）。</p>
</li>
<li><p>串的基本操作，如增删改查等<strong>通常以子串为操作对象</strong>。</p>
</li>
<li><p>基本操作：</p>
<ul>
<li><code>StrAssign(&amp;T, chars)</code>：赋值操作。把串T赋值为 chars。</li>
<li><code>StrCopy(&amp;T, S)</code>：复制操作。由串 S 复制得到串 T。</li>
<li><code>StrEmpty(S)</code>：判空操作。若 S 为空串，则返回 TRUE，否则返回 FALSE。</li>
<li><code>StrLength(S)</code>：求串长。返回串 S 的元素个数。</li>
<li><code>ClearString(&amp;S)</code>：清空操作。将 S 清为空串。</li>
<li><code>DestroyString(&amp;S)</code>：销毁串。将串 S 销毁（回收存储空间）。</li>
<li><code>Concat(&amp;Y, S1, S2)</code>：串联接。用 T 返回由 S1 和 S2联接而成的新串。</li>
<li><code>SubString(&amp;Sub, S, pos, len)</code>：：求子串。用 sub 返回串 S 的第 pos 个字符起长度为 len 的子串。</li>
<li><code>Index(S, T)</code>：定位操作。若主串中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置；否则函数值为0。</li>
<li><code>StrCompare(S, T)</code>：比较操作。若 S &gt; T，则返回值 &gt; 0；若 S &#x3D; T，则返回值 &#x3D; 0；若 S &lt; T，则返回值 &lt; 0。</li>
</ul>
</li>
<li><p>字符集：</p>
<ul>
<li>英文字符——ASCII字符集</li>
<li>中英文——Unicode字符集</li>
<li>基于同一个字符集，可以有多种编码方案。</li>
</ul>
</li>
</ul>
<h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><ul>
<li><p>顺序存储</p>
<ul>
<li><p>静态数组实现（定长顺序存储）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255	<span class="comment">//预定义最大串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];	<span class="comment">//每个分量存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;	<span class="comment">//串的实际长度</span></span><br><span class="line">&#125; SString;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态数组实现（堆分配存储）</p>
<ul>
<li>用完需要手动 free</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;	<span class="comment">//按串长分配存储区，ch 指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> length;	<span class="comment">//串的长度</span></span><br><span class="line">&#125; HString;</span><br><span class="line">HString S;</span><br><span class="line">S.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MAXLEN * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">S.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>四种顺序存储方案：</p>
<ul>
<li>最后一个位置放 length</li>
<li>第一个位置放 length</li>
<li>没有 length，以 ‘\0’ 表示结尾</li>
<li>ch[0] 废弃不用，最后一个位置放 length</li>
</ul>
</li>
<li><p>串的链式存储</p>
<ul>
<li><p>存储密度低：每个字符1B，每个指针4B</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ch;	<span class="comment">//每个结点存1个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StringNode, * String;</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储密度提高</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];	<span class="comment">//每个结点存多个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125; StringNode, * String;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>SubString(&amp;Sub, S, pos, len)</code>：：求子串。用 sub 返回串 S 的第 pos 个字符起长度为 len 的子串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255	<span class="comment">//预定义最大串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];	<span class="comment">//每个分量存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;	<span class="comment">//串的实际长度</span></span><br><span class="line">&#125; SString;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求子串</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SubString</span><span class="params">(SString &amp;sub, SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">//子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span> (pos + len - <span class="number">1</span> &gt; S.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt; pos + len; i++)</span><br><span class="line">        SUb.ch[i - pos + <span class="number">1</span>] = S.ch[i];</span><br><span class="line">    Sub.length = len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>StrCompare(S, T)</code>：比较操作。若 S &gt; T，则返回值 &gt; 0；若 S &#x3D; T，则返回值 &#x3D; 0；若 S &lt; T，则返回值 &lt; 0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Strcompare</span><span class="params">(SString S, SString T)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= S.length &amp;&amp; i &lt;= T.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] != T.ch[i])</span><br><span class="line">            <span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//扫描过的所有字符都相同，则长度长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.length-T.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Index(S, T)</code>：定位操作。若主串中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置；否则函数值为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, n = Strlength(S), m = StrLength(T);</span><br><span class="line">    SString sub;	<span class="comment">//用于暂存子串</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n - m + <span class="number">1</span>) &#123;</span><br><span class="line">        SubString(sub, S, i, m);</span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub, T) != <span class="number">0</span>)</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> i;	<span class="comment">//返回子串在主串中的位置</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//S 中不存在与 T 相等的子串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h1><ul>
<li><p>字符串模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置。</p>
<ul>
<li>子串——主串的一部分，一定能找到</li>
<li>模式串——不一定能在主串中找到</li>
</ul>
</li>
<li><p>朴素模式匹配算法：主串长度为 n，模式串长度为 m。将主串中<strong>所有长度为 m 的子串</strong>依次与模式串对比，直到找到一个完全匹配的子串，或所有子串都不匹配为止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == T.ch[i]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j +<span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最坏时间复杂度：O(nm)</p>
</li>
</ul>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="KMP算法的实现"><a href="#KMP算法的实现" class="headerlink" title="KMP算法的实现"></a>KMP算法的实现</h2><ul>
<li><p>朴素模式匹配算法</p>
<ul>
<li>一旦发现当前这个子串中某个字符不匹配，就只能转而匹配下一个子串（从头开始）</li>
<li>不匹配的字符之前，一定是和模式串一致的</li>
</ul>
</li>
<li><p>KMP算法中主串指针不回溯。</p>
</li>
<li><p>算法实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> next[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;=T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;	<span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];	<span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length)</span><br><span class="line">        <span class="keyword">return</span> i - T.length;	<span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KMP算法，最坏时间复杂度 O(m+n)，其中，求 next 数组时间复杂度 O(m)</p>
</li>
</ul>
<h2 id="求-next-数组"><a href="#求-next-数组" class="headerlink" title="求 next 数组"></a>求 next 数组</h2><ul>
<li>next 数组的作用：当模式串的第 j 个字符失配时，从模式串的第 next[j] 的继续往后匹配。</li>
<li>任何模式串都一样，第一个字符不匹配时，只能匹配下一个子串。因此，next[1] 都为0。</li>
<li>任何模式串都一样，第二个字符不匹配时，只能匹配下一个子串。因此，next[2] 都为1。</li>
<li>在不匹配的位置前边，划一条分界线。模式串一步一步往右移，直到分界线之前“能对上”，或模式串完全跨过分界线为止。此时 j 指向哪儿，next 数组值就是多少。</li>
</ul>
<h2 id="KMP算法的进一步优化"><a href="#KMP算法的进一步优化" class="headerlink" title="KMP算法的进一步优化"></a>KMP算法的进一步优化</h2><ul>
<li><p>求 nextval 数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= T; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (T.ch[next[j]] == T.ch[j])</span><br><span class="line">        nextval[j] = nextval[next[j]];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nextval[j] = next[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 nextval 数组代替 next 数组进行计算。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>第三章 栈和队列</title>
    <url>/2024/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h1><ul>
<li>栈（Stack）：一种操作受限的线性表，<strong>只允许在一端进行插入和删除操作</strong>的线性表。<ul>
<li>特点：后进先出（Last In First Out，LIFO）</li>
<li>逻辑结构：与普通线性表相同</li>
<li>数据的运算：插入、删除操作有区别</li>
</ul>
</li>
<li>重要术语：<ul>
<li>空栈：栈里面没有任何数据元素</li>
<li>栈顶：允许插入和删除的一端</li>
<li>栈底：不允许插入和删除的一端</li>
</ul>
</li>
<li>基本操作：<ul>
<li><code>InitStack(&amp;S)</code>：<strong>初始化</strong>栈。构造一个空栈 S，<strong>分配内存空间</strong>。</li>
<li><code>DestroyStack(&amp;S)</code>：<strong>销毁</strong>栈。销毁并<strong>释放</strong>栈 S 所占用的<strong>内存空间</strong>。</li>
<li><code>Push(&amp;S, x)</code>：<strong>进栈</strong>，若栈 S 未满，则将 x 加入使其成为新栈顶。 </li>
<li><code>Pop(&amp;S, &amp;x)</code>：<strong>出栈</strong>，若栈 S 非空，则弹出栈顶元素，并用 x 返回。</li>
<li><code>GetTop(S, &amp;x)</code>：<strong>读栈顶元素</strong>。若栈 S 非空，则用 x 返回栈顶元素。</li>
<li><code>StackEmpty(S)</code>：判断一个栈 S 是否为空。若 S 为空，返回 ture，否则返回 false。</li>
</ul>
</li>
<li>n 个不同元素进栈，出栈元素不同排列的个数为$\frac{1}{n+1}C^n_{2n}$，上述公式称为卡特兰（Catalan）数，可采用数学归纳法证明。</li>
</ul>
<h1 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h1><ul>
<li><p>顺序栈的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">	<span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">	<span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(Sqtack &amp;S)</span> &#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;	<span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)	<span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> 			<span class="comment">//不空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进栈操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">	<span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MaxSize - <span class="number">1</span>)	<span class="comment">//栈满，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top = S.top + <span class="number">1</span>;	<span class="comment">//指针先加1</span></span><br><span class="line">    S.data[S.top] = x;	<span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="comment">//以上两行代码等价于 S.data[++S.top] = x;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出栈操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">	<span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)	<span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];	<span class="comment">//栈顶元素先出栈</span></span><br><span class="line">    S.top = S.top - <span class="number">1</span>;	<span class="comment">//指针再减一</span></span><br><span class="line">    <span class="comment">//以上两行代码等价于 x = S.data[S.top--];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读栈顶操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">	<span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)	<span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];	<span class="comment">//x记录栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化，入栈，出栈和读栈顶都是O(1)时间复杂度。</p>
</li>
<li><p><code>SqStack S;</code>声明栈时分配内存，函数运行结束后系统自动回收内存。</p>
</li>
<li><p>栈满的条件：top &#x3D;&#x3D; MaxSize - 1</p>
</li>
<li><p>另一种方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">	<span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(Sqtack &amp;S)</span> &#123;</span><br><span class="line">    S.top = <span class="number">0</span>;	<span class="comment">//top指向下一个可以插入元素的位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">0</span>)	<span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> 			<span class="comment">//不空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line">S.data[S.top] = x;</span><br><span class="line">S.top = S.top + <span class="number">1</span>;</span><br><span class="line">等价于 S.data[S.top++] = x;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">S.top = S.top - <span class="number">1</span>;</span><br><span class="line">x = S.data[S.top];</span><br><span class="line">等价于 x = S.data[--S.top];</span><br></pre></td></tr></table></figure>

<p>栈满的条件：top &#x3D;&#x3D; MaxSize</p>
</li>
<li><p>顺序栈的缺点：栈的大小不可变。</p>
</li>
<li><p>共享栈：两个栈共享同一片空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">	<span class="type">int</span> top0;	<span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;	<span class="comment">//1号栈栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(Sqtack &amp;S)</span> &#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;	<span class="comment">//初始化栈顶指针</span></span><br><span class="line">    S.top1 = MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈满的条件：top0 + 1 &#x3D;&#x3D; top1</p>
</li>
</ul>
<h1 id="链栈的实现"><a href="#链栈的实现" class="headerlink" title="链栈的实现"></a>链栈的实现</h1><ul>
<li><p>链栈：用链式存储方式实现的栈。</p>
</li>
<li><p>链栈的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> &#123;</span></span><br><span class="line">    ElemType data;	<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>	<span class="comment">//指针域</span></span><br><span class="line">&#125; *LiStack;	<span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进栈：对头结点后插操作。</p>
</li>
<li><p>出栈：对头结点“后删”操作。</p>
</li>
<li><p>进栈和出栈操作都只能在栈顶一端进行（链头作为栈顶）。</p>
</li>
<li><p>实现方式推荐不带头结点。</p>
</li>
</ul>
<h1 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h1><ul>
<li>队列（Queue）：一种操作受限的线性表，<strong>只允许在一端进行插入，在另一端删除</strong>的线性表。<ul>
<li>特点：先进先出（Firstt In First Out，FIFO）</li>
</ul>
</li>
<li>重要术语：<ul>
<li>空队列：队列里面没有任何数据元素。</li>
<li>队尾：允许插入的一端。</li>
<li>队头：允许删除的一端。</li>
</ul>
</li>
<li>基本操作：<ul>
<li><code>InitQueue(&amp;Q)</code>：<strong>初始化</strong>队列。构造一个空队列 Q。</li>
<li><code>DestroyQueue(&amp;Q)</code>：<strong>销毁</strong>队列。销毁并<strong>释放</strong>队列 Q 所占用的<strong>内存空间</strong>。</li>
<li><code>Push(&amp;Q, x)</code>：<strong>进队</strong>，若队列 Q 未满，则将 x 加入使其成为新的队尾。 </li>
<li><code>Pop(&amp;Q, &amp;x)</code>：<strong>出队</strong>，若队列 Q 非空，则弹出队顶元素，并用 x 返回。</li>
<li><code>GetTop(Q, &amp;x)</code>：<strong>读队头元素</strong>。若队列 Q 非空，则用 x 返回队头元素。</li>
<li><code>QueuekEmpty(Q)</code>：判断一个队列 Q 是否为空。若 Q 为空，返回 ture，否则返回 false。</li>
</ul>
</li>
</ul>
<h1 id="队列的顺序实现"><a href="#队列的顺序实现" class="headerlink" title="队列的顺序实现"></a>队列的顺序实现</h1><ul>
<li><p>队列的顺序实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemeType date[MaxSize];	<span class="comment">//静态数组存放队列元素</span></span><br><span class="line">	<span class="type">int</span> front, rear;	<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>

<p>队头指针指向头元素；队尾指针指向下一个应该插入的位置</p>
</li>
<li><p>初始化操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemeType date[MaxSize];	<span class="comment">//静态数组存放队列元素</span></span><br><span class="line">	<span class="type">int</span> front, rear;	<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> &#123;</span><br><span class="line">    <span class="comment">//初始时 队头、队尾指针指向0</span></span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>入队操作（循环队列）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemeType date[MaxSize];	<span class="comment">//静态数组存放队列元素</span></span><br><span class="line">	<span class="type">int</span> front, rear;	<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队（循环队列）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MaxSize == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//队满则报错</span></span><br><span class="line">    Q.data[Q.rear] = x;	<span class="comment">//新元素插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;	<span class="comment">//队尾指针加1取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出队操作（循环队列）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出队（删除一个队头元素，并用x返回）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//队空则报错</span></span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取队头元素的值，用x返回</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetHead</span><span class="params">(SqQueue Q, ElemType &amp;x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//队空则报错</span></span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断队列已满&#x2F;已空</p>
<ul>
<li><p>方案一：</p>
<ul>
<li>队满条件：队尾指针的下一个位置是队头<code>(Q.rear + 1) % MaxSize == Q.front</code></li>
<li>队空条件：<code>Q.rear == Q.front</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemeType date[MaxSize];	<span class="comment">//静态数组存放队列元素</span></span><br><span class="line">	<span class="type">int</span> front, rear;	<span class="comment">//队头指针和队尾指针（初始化时 rear = front = 0)</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方案二：</p>
<ul>
<li>队满条件：<code>size == MaxSize</code></li>
<li>队空条件：<code>size == 0</code></li>
<li>插入成功 size++；删除成功 size–</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemeType date[MaxSize];	<span class="comment">//静态数组存放队列元素</span></span><br><span class="line">	<span class="type">int</span> front, rear;	<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">    <span class="type">int</span> size;	<span class="comment">//队列当前长度（初始化时：size = 0）</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方案三：</p>
<ul>
<li>队满条件：<code>front == rear &amp;&amp; tag == 1</code></li>
<li>队空条件：<code>front == rear &amp;&amp; tag == 0</code></li>
<li>插入成功 <code>tag = 0</code>；删除成功 <code>tag = 1</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemeType date[MaxSize];	<span class="comment">//静态数组存放队列元素</span></span><br><span class="line">	<span class="type">int</span> front, rear;	<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">    <span class="type">int</span> tag;	<span class="comment">//最近进行的是删除/插入（初始化时：tag = 0）</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>队尾指针指向队尾元素下一个位置</li>
<li>队尾指针指向指向队尾元素<ul>
<li>初始化：front &#x3D; 0；rear &#x3D; n-1</li>
<li>插入：队尾指针先后移，再插入元素</li>
<li>判空：(Q.rear+1)%MaxSize &#x3D;&#x3D; Q.front</li>
<li>判满：<ul>
<li>牺牲一个存储单元</li>
<li>增加辅助变量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="队列的链式实现"><a href="#队列的链式实现" class="headerlink" title="队列的链式实现"></a>队列的链式实现</h1><ul>
<li><p>队列的链式实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> &#123;</span>	<span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front, *rear;	<span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125; LinkQueue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化（带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> &#123;</span>	<span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front, *rear;	<span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列（带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span> &#123;</span><br><span class="line">    <span class="comment">//初始时 front 和 rear 都指向头结点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpy</span><span class="params">(LinkQueue Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化（不带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化队列（不带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span> &#123;</span><br><span class="line">    <span class="comment">//初始时 front 和 rear 都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear= <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpy</span><span class="params">(LinkQueue Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>入队（带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span> &#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = s;	<span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear = s;	<span class="comment">//修改表尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入队（不带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span> &#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>) &#123;	<span class="comment">//在空队列中插入第一个元素</span></span><br><span class="line">        Q.front = s;	<span class="comment">//修改队头队尾指针</span></span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		Q.rear-&gt;next = s;	<span class="comment">//新结点插入到 rear 结点之后</span></span><br><span class="line">        Q.rear = s;	<span class="comment">//修改 rear 指针</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出队（带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队头元素出队（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//空队</span></span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    x = p-&gt;data;	<span class="comment">//用变量 x 返回队头元素</span></span><br><span class="line">    Q.front-&gt;next = p-&gt;next;	<span class="comment">//修改头结点的 next 指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)	<span class="comment">//此次是最后一个极点出队</span></span><br><span class="line">        Q.rear == Q.front;	<span class="comment">//修改 rear 指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);	<span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出队（不带头结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队头元素出队（不带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//空队</span></span><br><span class="line">    LinkNode *p = Q.front;	<span class="comment">//p 指向此次出队的结点</span></span><br><span class="line">    x = p-&gt;data;	<span class="comment">//用变量 x 返回队头元素</span></span><br><span class="line">    Q.front = p-&gt;next;	<span class="comment">//修改 front 指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)	<span class="comment">//此次是最后一个极点出队</span></span><br><span class="line">        Q.front == <span class="literal">NULL</span>;	<span class="comment">//front 指向 NULL</span></span><br><span class="line">        Q.rear == <span class="literal">NULL</span>;	<span class="comment">//rear 指针 NULL</span></span><br><span class="line">    <span class="built_in">free</span>(p);	<span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链式存储——一般不会队满，除非内存不足。</p>
</li>
</ul>
<h1 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h1><ul>
<li>只允许从<strong>两端插入</strong>，<strong>两端删除</strong>的线性表。<ul>
<li><strong>输入</strong>受限的双端队列：只允许从<strong>一端插入</strong>，<strong>两端删除</strong>的线性表。</li>
<li><strong>输出</strong>受限的双端队列：只允许从<strong>两端插入</strong>，<strong>一端删除</strong>的线性表。</li>
</ul>
</li>
</ul>
<h1 id="栈的应用——括号匹配问题"><a href="#栈的应用——括号匹配问题" class="headerlink" title="栈的应用——括号匹配问题"></a>栈的应用——括号匹配问题</h1><ul>
<li><p>最后出现的左括号最先被匹配（LIFO）</p>
</li>
<li><p>算法实现：依次扫描所有字符，遇到左括号进栈，遇到右括号则弹出栈顶元素检查是否匹配。</p>
<ul>
<li>匹配失败情况：<ul>
<li>剩余左（右）括号</li>
<li>左右括号不匹配</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数（存在存满情况可用 链栈）</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> date[MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;s)</span>;</span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>;</span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S, <span class="type">char</span> x)</span>;</span><br><span class="line"><span class="comment">//栈顶元素出栈，用 x 返回</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S, <span class="type">char</span> &amp;x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bracketCheck</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(S);	<span class="comment">//初始化一个栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            Push(S, str[i]);	<span class="comment">//匹配到左括号，入栈</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(StackEmpty(S))	<span class="comment">//匹配到右括号，且当前栈空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//匹配失效</span></span><br><span class="line">            <span class="type">char</span> topElem;</span><br><span class="line">            Pop(S, topElem);	<span class="comment">//栈顶元素出栈</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StackEmpty(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="栈的应用——表达式求值"><a href="#栈的应用——表达式求值" class="headerlink" title="栈的应用——表达式求值"></a>栈的应用——表达式求值</h1><ul>
<li><strong>中缀表达式</strong>：运算符在两个操作数中间</li>
<li><strong>后缀表达式</strong>（逆波兰表达式）：运算符在两个操作数后面</li>
<li><strong>前缀表达式</strong>（波兰表达式）：运算符在两个操作数前面</li>
<li><strong>中缀转后缀</strong>的<strong>手算</strong>方法：<ol>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>选择下一个运算符，按照（<strong>左操作数 右操作数 运算符</strong>）的方式组成一个新的操作数</li>
<li>如果还有运算符没被处理，就继续上一步</li>
</ol>
</li>
<li><strong>“左优先“</strong>原则：只要<strong>左边</strong>的运算符能先计算，就优先算<strong>左边</strong>的。保证手算和机算结果相同。</li>
<li><strong>从左往右</strong>扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对运算，合体为一个操作数。</li>
<li>用栈实现<strong>后缀表达式</strong>的<strong>计算</strong>：<ol>
<li><strong>从左往右</strong>扫描下一个元素，直到处理完所有元素</li>
<li>若扫描到操作数则压入栈，回到上一步；否则执行下一步</li>
<li>若扫描到运算符，则弹出两个栈顶元素（<strong>先出栈的是“右操作数”</strong>），执行相应运算，运算结果压回栈顶，回到第一步</li>
</ol>
</li>
<li><strong>中缀转前缀</strong>的<strong>手算</strong>方法：<ol>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>选择下一个运算符，按照（<strong>运算符 左操作数 右操作数</strong>）的方式组成一个新的操作数</li>
<li>如果还有运算符没被处理，就继续上一步</li>
</ol>
</li>
<li><strong>“右优先“</strong>原则：只要<strong>右边</strong>的运算符能先计算，就优先算<strong>右边</strong>的。保证手算和机算结果相同。</li>
<li>用栈实现<strong>前缀表达式</strong>的<strong>计算</strong>：<ol>
<li><strong>从右往左</strong>扫描下一个元素，直到处理完所有元素</li>
<li>若扫描到操作数则压入栈，回到上一步；否则执行下一步</li>
<li>若扫描到运算符，则弹出两个栈顶元素（<strong>先出栈的是“左操作数”</strong>），执行相应运算，运算结果压回栈顶，回到第一步</li>
</ol>
</li>
<li>中缀表达式转后缀表达式（<strong>机算</strong>）<ol>
<li>初始化一个栈，用于保存<strong>暂时还不能确定运算顺序的运算符</strong>。</li>
<li>从左到右处理各个元素，直到末尾。可能遇到三种情况：<ul>
<li>遇到<strong>操作数</strong>。直接假如后缀表达式。</li>
<li>遇到<strong>界限符</strong>。遇到 “(“ 直接入栈；遇到 “)” 则依次弹出栈内运算符并加入后缀表达式，直到弹出 “(“ 为止。注意：”(“ 不加入后缀表达式。</li>
<li>遇到<strong>运算符</strong>。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到 “(“ 或栈空则停止。之后再把当前运算符入栈。</li>
</ul>
</li>
<li>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</li>
</ol>
</li>
<li>中缀表达式的计算（用栈实现）：<ol>
<li>初始化两个栈，操作数栈和运算符栈</li>
<li>若扫描到操作数，压入操作数栈</li>
<li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应元素，运算结果再压回操作数栈）</li>
</ol>
</li>
</ul>
<h1 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h1><ul>
<li>函数调用的特点：最后被调用的函数最先执行结束（LIFO）</li>
<li>函数调用时，需要用到一个栈存储：<ul>
<li>调用返回地址</li>
<li>实参</li>
<li>局部变量</li>
</ul>
</li>
<li>适合用“递归”算法解决：可以把原始问题转换为<strong>属性相同</strong>，但<strong>规模较小</strong>的问题。例如：<ul>
<li>计算正整数的阶乘！</li>
<li>求斐波那契数列</li>
</ul>
</li>
<li>递归调用时，函数调用栈可称为“递归工作栈”。<ul>
<li>每进入一层递归，就将递归调用所需信息压入栈顶。</li>
<li>每退出一层递归，每退出一层递归，就从栈顶弹出相应信息。</li>
</ul>
</li>
<li>缺点：效率低，太多层递归可能会导致栈溢出；可能包含很多重复计算。</li>
<li>可以自定义栈将递归算法改造成非递归算法。</li>
</ul>
<h1 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h1><ul>
<li>树的层次遍历</li>
<li>图的广度优先遍历</li>
<li>队列在操作系统中应用<ul>
<li>多个进程争抢着使用有限的系统资源，<strong>FCFS</strong>（First Come First Service，先来先服务）是一种常用策略。</li>
<li>打印数据缓冲区。</li>
</ul>
</li>
</ul>
<h1 id="特殊矩阵压缩存储"><a href="#特殊矩阵压缩存储" class="headerlink" title="特殊矩阵压缩存储"></a>特殊矩阵压缩存储</h1><h2 id="数组的存储结构"><a href="#数组的存储结构" class="headerlink" title="数组的存储结构"></a>数组的存储结构</h2><ul>
<li>一维数组的存储结构<ul>
<li><code>ElemType a[10];</code>	</li>
<li>起始地址：LOC</li>
<li>各组元素大小相同，且物理上连续存放。<ul>
<li>数组元素 a[i] 的存放地址 &#x3D; LOC+ i*sizeof(Elemtype)</li>
<li>数组下标默认从0开始。</li>
</ul>
</li>
</ul>
</li>
<li>二维数组的存储结构<ul>
<li>两种存储策略：行优先存储；列优先存储。</li>
<li>起始地址：LOC</li>
<li>在M行N列的二维数组中<ul>
<li>若行优先存储，b[ i ] [ j ]的存储地址 &#x3D; LOC + (i * N + j) * sizeof(ElemType)</li>
<li>若列优先存储，b[ i ] [ j ]的存储地址 &#x3D; LOC + (i * M + i) * sizeof(ElemType)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="普通矩阵的存储"><a href="#普通矩阵的存储" class="headerlink" title="普通矩阵的存储"></a>普通矩阵的存储</h2><ul>
<li>可用二维数组存储</li>
<li>描述矩阵元素时行和列通常从1开始，描述数组时通常从0开始。</li>
</ul>
<h2 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="headerlink" title="对称矩阵的压缩存储"></a>对称矩阵的压缩存储</h2><ul>
<li>对称矩阵：元素值关于主对角线对称。</li>
<li>策略：只存储主对角线 + 下三角区。</li>
<li>按行优先原则将各元素存入一维数组中。<ul>
<li>共有$\frac{n * (n+1)}{2}$个元素，按行优先原则a<sub>i,j</sub>是第$\frac{i * (i -1)}{2} + j$个元素。</li>
<li>找上三角区元素：找a<sub>j,i</sub></li>
</ul>
</li>
<li>按列优先原则将各元素存入一维数组中。<ul>
<li>共有$\frac{n * (n+1)}{2}$个元素，按行优先原则a<sub>i,j</sub>是第[n + (n-1) + … + (n-j+2)] + (i-j) +1个元素。</li>
<li>找上三角区元素：找a<sub>j,i</sub></li>
</ul>
</li>
</ul>
<h2 id="三角矩阵的压缩存储"><a href="#三角矩阵的压缩存储" class="headerlink" title="三角矩阵的压缩存储"></a>三角矩阵的压缩存储</h2><ul>
<li><p>下三角矩阵：除了主对角线和下三角区，其余的元素都相同</p>
</li>
<li><p>压缩存储策略：</p>
<ul>
<li><p>按行优先原则将<strong>下三角区</strong>存入一维数组中。并在最后一个位置存储常量C。</p>
</li>
<li><p>共有$\frac{n * (n+1)}{2} + 1$个元素，按行优先原则：</p>
<ul>
<li>若i &gt;&#x3D; j，a<sub>i,j</sub>是第$\frac{i * (i -1)}{2} + j$个元素。</li>
<li>若i &lt; j，a<sub>i,j</sub>是第$\frac{n * (n + 1)}{2} + j$个元素。</li>
</ul>
</li>
<li><p>按行优先原则将<strong>上三角区</strong>存入一维数组中。并在最后一个位置存储常量C。</p>
</li>
<li><p>共有$\frac{n * (n+1)}{2} + 1$个元素，按行优先原则：</p>
<ul>
<li>若i &lt;&#x3D; j，a<sub>i,j</sub>是第[n + (n - 1) + … + (n - j + 2)] + (i - j) +1个元素。</li>
<li>若i &gt; j，a<sub>i,j</sub>是第$\frac{n * (n + 1)}{2} + j$个元素。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="三对角矩阵的压缩存储"><a href="#三对角矩阵的压缩存储" class="headerlink" title="三对角矩阵的压缩存储"></a>三对角矩阵的压缩存储</h2><ul>
<li>三对角矩阵：又称带状矩阵。主对角线及其相邻对角线元素可以不为0，其余元素均为0。（除了第一行和最后一行至多有两个不为0元素，其余行至多有三个不为0元素。</li>
<li>共有3n-2个元素，按行优先原则，a<sub>i,j</sub>是第2*i+j-2个元素。</li>
<li>第 k 个元素在第(k+2) &#x2F;3行，第k-2*i+3列。</li>
</ul>
<h2 id="稀疏矩阵的压缩存储"><a href="#稀疏矩阵的压缩存储" class="headerlink" title="稀疏矩阵的压缩存储"></a>稀疏矩阵的压缩存储</h2><ul>
<li>稀疏矩阵：非零元素远远少于矩阵元素的个数。</li>
<li>策略：<ul>
<li>顺序存储——三元组&lt;行，列，值&gt;（<code>struct</code>）</li>
<li>链式存储——十字链表法<ul>
<li>向下域down：指向同列的下一个非零元素</li>
<li>向右域right：指向同行的下一个非零元素</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>单相电和三相电</title>
    <url>/2024/07/08/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90/%E5%8D%95%E7%9B%B8%E7%94%B5%E5%92%8C%E4%B8%89%E7%9B%B8%E7%94%B5/</url>
    <content><![CDATA[<h1 id="单相与三相的区别"><a href="#单相与三相的区别" class="headerlink" title="单相与三相的区别"></a>单相与三相的区别</h1><ul>
<li><p><strong>电压等级</strong></p>
<ul>
<li><strong>单相电</strong>：电压通常为220V，适用于低功率设备的供电。</li>
<li><strong>三相电</strong>：电压通常为380V，能够提供更大的输出功率和电压，适用于高功率负载的供电。</li>
<li>单相电的电压是220V，是火线和零线之间的电压（相电压）。</li>
<li>三相电的每根相线之间的电压是380V（线电压）。</li>
</ul>
</li>
<li><p><strong>应用领域</strong></p>
<ul>
<li><p><strong>单相电</strong>：多用于居民用电，如家庭照明、家用电器等。由于大部分家庭电器不需要太大的功率和电压，因此单相电在家庭用电中占据主导地位。</p>
</li>
<li><p><strong>三相电</strong>：多用于工业领域，如电动机、变压器、发电机等设备的供电。三相电在发电、电能转换等方面存在优势，能够提供稳定且高效的电力供应。</p>
</li>
</ul>
</li>
<li><p><strong>电力传输特性</strong></p>
<ul>
<li><strong>单相电</strong>：电力传输相对简单，但受限于电压和功率，难以满足大规模工业用电的需求。</li>
<li><strong>三相电</strong>：三相电通过三根相线传输电力，每根相线之间的电压相位差为120度，这种相位差使得三相电在传输过程中能够保持电流和电压的平衡，从而实现更高的电力传输效率和负载均衡能力。此外，三相电还具有更好的稳定性和可靠性，能够减少电力线路的损耗和故障。</li>
</ul>
</li>
<li><p><strong>三相电的优势</strong>：</p>
<ul>
<li>三相电特殊的相位差使得三个相位的电流波形相互错开，总和起来近似恒定，因此供电更加稳定。同时，这种稳定的电流波形也减少了电流波动，有利于保证设备运行的稳定性和延长使用寿命。</li>
<li>通过三个相位的电势叠加，三相电能够提供更高的总功率。这种高功率输出特性使得三相电在工业生产、大型建筑、商业中心等需要大量电能的场所具有显著优势。</li>
<li>三相电在传输相同功率时，由于电流分布更为均匀，电能损耗较小，输电效率更高。这种高效传输特性使得三相电在远距离输电和大电流应用中具有显著优势。</li>
</ul>
</li>
</ul>
<h1 id="单相三线"><a href="#单相三线" class="headerlink" title="单相三线"></a>单相三线</h1><ul>
<li><p><strong>定义</strong>：单相三线制是指由一根相线（火线）、一根中性线（零线）和一根地线组成的供电方式。这种供电方式主要用于单相负载的供电。</p>
</li>
<li><p><strong>特点</strong>：</p>
</li>
<li><p><strong>相线</strong>：提供单相交流电的电压，通常为220V（在中国标准中）。</p>
</li>
<li><p><strong>中性线</strong>：在三相四线制供电系统中，中性线用于平衡三相负载的电流，并作为单相负载的回路。在单相三线制中，中性线同样作为单相负载的回路。</p>
</li>
<li><p><strong>地线</strong>：用于安全接地，防止电器设备漏电时对人体造成伤害。</p>
</li>
</ul>
<h1 id="三相三线"><a href="#三相三线" class="headerlink" title="三相三线"></a>三相三线</h1><ul>
<li><p><strong>定义</strong>：三相三线制是指由三根相线（火线）组成的供电方式，没有中性线。这种供电方式主要用于三相平衡负载的供电。三根火线分别为A线、B线和C线。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p><strong>三根相线</strong>：每根相线之间的电压相位差为120度，提供三相交流电。在三相三线制中，由于没有中性线，因此不能用于单相负载的供电。</p>
</li>
<li><p><strong>三相平衡</strong>：在三相三线制供电系统中，要求三相负载尽量平衡，以保证电流和电压的稳定。</p>
</li>
</ul>
</li>
</ul>
<h1 id="三相四线"><a href="#三相四线" class="headerlink" title="三相四线"></a>三相四线</h1><ul>
<li><p><strong>定义</strong>：三相四线制是指由三根相线和一根中性线组成的供电方式。这种供电方式既可用于三相负载的供电，也可用于单相负载的供电。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p><strong>三根相线</strong>：与三相三线制相同，提供三相交流电。</p>
</li>
<li><p><strong>中性线</strong>：在三相四线制中，中性线不仅用于平衡三相负载的电流，还作为单相负载的回路。这使得三相四线制供电系统能够同时满足三相和单相负载的供电需求。</p>
</li>
<li><p><strong>灵活性</strong>：由于三相四线制供电系统具有中性线，因此其供电方式更加灵活，适用范围也更广。</p>
</li>
</ul>
</li>
</ul>
<h1 id="单相负载"><a href="#单相负载" class="headerlink" title="单相负载"></a>单相负载</h1><p><strong>定义</strong>：单相负载是指电路中只有一个相位与负载相连的负载。在单相电路中，电源通常提供一根火线（相线）和一根零线（中性线），负载则连接在这两根线之间，从而获取电能进行工作。</p>
<h1 id="三相负载"><a href="#三相负载" class="headerlink" title="三相负载"></a>三相负载</h1><ul>
<li><strong>定义</strong>：三相负载是指在电力系统中，由三个独立的单相负载以一定的方式连接，并同时从三相电源获取电能的负载。这三个单相负载分别连接到三相电源的三个相位上，形成一个三相电路。三相负载是工业和商业应用中常见的负载类型，因为它们能够更有效地利用三相电源提供的能量，实现更高的功率输出和更好的负载均衡能力。</li>
<li><strong>特点</strong>：<ul>
<li>三相平衡</li>
<li>高效率</li>
<li>大功率</li>
</ul>
</li>
<li><strong>连接方式</strong>：<ul>
<li>星形</li>
<li>三角形</li>
</ul>
</li>
</ul>
<h1 id="三角形连接和星形连接"><a href="#三角形连接和星形连接" class="headerlink" title="三角形连接和星形连接"></a>三角形连接和星形连接</h1><ul>
<li><p><strong>三角形连接</strong></p>
<ul>
<li><p><strong>接线方式</strong>：</p>
<ul>
<li>将三相电源或负载中的每一相的末端与后续相的前端相连，然后再从3个连接点引出端线。这种接线方式因其形状似三角形而得名。</li>
<li>在电机中，三角形连接是将电机三相绕组的首尾互相连接，并将每个连接点引出作为相线。</li>
</ul>
</li>
<li><p><strong>电压电流特性</strong>：</p>
<ul>
<li>在三角形连接中，负载的相电压等于三相电源的线电压，即对于标准的三相电源，相电压为380V。</li>
<li>线电流与相电流的关系是：线电流是相电流的根号3倍（约1.73倍）。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li>三角形连接常用于大功率电机，因为它能够提供较高的相电压（380V），有助于提高电机的功率输出。</li>
<li>然而，三角形连接的启动电流较大，因此在某些情况下需要采用星形-三角形（Y-Δ）转换启动方式来降低启动电流。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>星形连接</strong></p>
<ul>
<li><strong>接线方式</strong>：<ul>
<li>将三相电源或负载的三个绕组的末端连接在一起，形成一个公共点（中性点），然后从每个绕组的始端引出端线。</li>
<li>在电机中，星形连接是将电机三相绕组的三条尾连接在一起，三条头接电源。</li>
</ul>
</li>
<li><strong>电压电流特性</strong>：<ul>
<li>在星形连接中，负载的相电压是三相电源线电压的1&#x2F;根号3倍（约0.577倍），即对于标准的三相电源，相电压为220V。</li>
<li>对于三相对称负载，线电流等于相电流。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>星形连接常用于小功率电机或需要降低启动电流的场合。由于相电压较低，因此启动电流也相应较小。</li>
<li>星形连接还可以方便地引出中性线，实现三相四线制供电，满足某些特定需求。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>电力电子</category>
      </categories>
  </entry>
  <entry>
    <title>电能表铭牌注册型号含义</title>
    <url>/2024/07/12/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90/%E7%94%B5%E8%83%BD%E8%A1%A8%E9%93%AD%E7%89%8C%E6%B3%A8%E5%86%8C%E5%9E%8B%E5%8F%B7%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<h1 id="类别代号"><a href="#类别代号" class="headerlink" title="类别代号"></a>类别代号</h1><ul>
<li>D——电能表</li>
</ul>
<h1 id="第一组别"><a href="#第一组别" class="headerlink" title="第一组别"></a>第一组别</h1><ul>
<li><p>D——单相</p>
</li>
<li><p>H——三相</p>
</li>
<li><p>J——直流</p>
</li>
<li><p>S——三相三线</p>
</li>
<li><p>T——三相四线</p>
</li>
</ul>
<h1 id="第二组别"><a href="#第二组别" class="headerlink" title="第二组别"></a>第二组别</h1><ul>
<li>A——数字化</li>
<li>E——机电式</li>
<li>S——电子式</li>
<li>Z——智能</li>
</ul>
<h1 id="特征描述1"><a href="#特征描述1" class="headerlink" title="特征描述1"></a>特征描述1</h1><ul>
<li>D——多功能</li>
<li>F——多费率</li>
<li>H——谐波</li>
<li>K——费控</li>
<li>P——最大需量</li>
<li>X——无功（“有功”和“有无功组合”缺省，“无功”放到特征描述栏，纯无功电能表时采用）</li>
<li>Y——预付费</li>
</ul>
<h1 id="特征描述2"><a href="#特征描述2" class="headerlink" title="特征描述2"></a>特征描述2</h1><ul>
<li>C——槽装式（嵌入式）</li>
<li>H——多用户</li>
<li>J——防窃电</li>
<li>L——长寿命</li>
<li>M——模组化</li>
<li>U——导轨</li>
</ul>
<h1 id="注册号"><a href="#注册号" class="headerlink" title="注册号"></a>注册号</h1><ul>
<li>如果产品是统一设计的，采用设计序号。</li>
</ul>
<h1 id="自由字段"><a href="#自由字段" class="headerlink" title="自由字段"></a>自由字段</h1><h1 id="连接符"><a href="#连接符" class="headerlink" title="连接符"></a>连接符</h1><ul>
<li><strong>-</strong></li>
</ul>
<h1 id="通信信道"><a href="#通信信道" class="headerlink" title="通信信道"></a>通信信道</h1><ul>
<li>B——蓝牙通信</li>
<li>C——CDMA</li>
<li>D——多种通信方式（具备种以上通信方式，例如双模）</li>
<li>F——WIFI</li>
<li>G——GPRS</li>
<li>H——HRF</li>
<li>J——微功率无线</li>
<li>L——有线网络</li>
<li>N——以太网</li>
<li>P——公用电话线</li>
<li>Q——光纤</li>
<li>W——230MHz专网</li>
<li>Y——音频</li>
<li>Z——载波</li>
<li>NB——NBIoT</li>
<li>4G——4G</li>
<li>5G——5G</li>
<li>其他字母组合——新通信方式简称</li>
</ul>
<h1 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h1><ul>
<li><strong>&#x2F;</strong></li>
</ul>
<h1 id="改进号"><a href="#改进号" class="headerlink" title="改进号"></a>改进号</h1><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><ul>
<li>DDZM1234-Z——单相智能电能表，M表示模组化，注册号为1234，通信信道为载波通信</li>
<li>DDZKM1234iot-Z&#x2F;a——单相费控智能电能表，M表示模组化，注册号为1234，物联网，通信信道为载波通信，a表示第一次改版</li>
<li>DTSY1234c——三相四线电子式预付费电能表，注册号为1234，c表示CPU卡</li>
<li>DTSY1234s——三相四线电子式预付费电能表，注册号为1234，s表示射频卡</li>
<li>DTEL862&#x2F;b——三相四线机电式电能表，L表示长寿命，设计序号为862，b表示第二次改版</li>
<li>DTSX1234——三相四线电子式无功电能表，注册号为1234</li>
<li>DJSF1234——直流电子式多费率电能表，注册号为1234</li>
</ul>
]]></content>
      <categories>
        <category>电力电子</category>
      </categories>
  </entry>
  <entry>
    <title>嵌入式通信协议总结</title>
    <url>/2024/07/16/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/weixin_45116099/article/details/136537514">一文总结嵌入式七大通信总线协议</a></p>
]]></content>
      <categories>
        <category>电力电子</category>
      </categories>
  </entry>
  <entry>
    <title>电力相关名词解释积累</title>
    <url>/2024/09/18/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90/%E7%94%B5%E5%8A%9B%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<h1 id="台区"><a href="#台区" class="headerlink" title="台区"></a>台区</h1><ul>
<li><strong>定义</strong>：台区是指（一台）变压器的供电范围或区域，是电力经济运行管理的名词。</li>
<li><strong>类型</strong>：按照负荷类型不同，台区可分为城市居民台区、商业台区、工业台区和农业台区四类。</li>
<li><strong>功能</strong>：电能运输与分配、电能质量检测、能源管理</li>
</ul>
<h1 id="功率因数"><a href="#功率因数" class="headerlink" title="功率因数"></a>功率因数</h1><ul>
<li><strong>定义</strong>：又称功率系数，是交流电路中有功功率（P）与视在功率（S）的比值，常用符号cosΦ表示，其中Φ为电压与电流之间的相位差。</li>
<li>视在频率是指电路的总功率，包括了有功功率和无功功率两个部分。</li>
<li>功率因数的大小反映了电路中有功功率在总功率中所占的比例。功率因数越高，说明电路中有功功率的比例越大，电能的利用效率也就越高。反之，功率因数低则表明电路中无功功率的比例较大，电能的利用效率低。</li>
</ul>
<h1 id="射频电磁场"><a href="#射频电磁场" class="headerlink" title="射频电磁场"></a>射频电磁场</h1><ul>
<li><strong>定义</strong>：射频电磁场（Radiofrequency Electromagnetic Fields，简称RF）是高频交流变化电磁波的简称。当交流电的频率达到10^5 Hz（即100 kHz）以上时，其周围就形成了高频率的电场和磁场，即射频电磁场。射频电磁场在多个领域有着广泛的应用和重要作用。</li>
</ul>
<h1 id="差模电流"><a href="#差模电流" class="headerlink" title="差模电流"></a>差模电流</h1><ul>
<li><strong>定义</strong>：差模电流是指在电源线与电源回线之间（或在信号线与信号回线之间）流动的、大小相同但方向相反的电流。这种电流通常是由电路中的工作信号或信号源产生的。差模电流是平衡电流的一种形式，其特点是电流在传输线中以相反的方向流动，从而减少了电磁辐射和对外界设备的干扰。</li>
<li><strong>应用与影响</strong>：在信号传输中，使用差模信号可以降低共模电流的影响，提高信号的传输质量。差模电流主要通过平衡传输线进行传输，这种传输方式通过将正负极性的信号分别传输以减少信号的失真和噪声。此外，在电磁兼容性（EMC）设计中，差模电流和共模电流是需要关注的重要参数。通过合理设计滤波电路和选择合适的滤波器，可以抑制和衰减传导干扰（包括差模干扰和共模干扰），确保电子设备的正常工作和性能稳定。</li>
</ul>
<h1 id="直流电压纹波"><a href="#直流电压纹波" class="headerlink" title="直流电压纹波"></a>直流电压纹波</h1><ul>
<li><strong>定义</strong>：直流电压纹波是由于直流稳定电源的电压波动而造成的一种现象。直流电源一般是由交流电源经整流稳压等环节而形成的，这就不可避免地在直流稳定量中带有一些交流成分，这种叠加在直流稳定量上的交流分量就被称为纹波。</li>
</ul>
<h1 id="潜动"><a href="#潜动" class="headerlink" title="潜动"></a>潜动</h1><ul>
<li><strong>定义</strong>：是指电能表在运行或校验时，只加电压而负载电流为零时，表盘仍然连续旋转的现象。简单来说，就是当电能表没有实际负载电流而通过电压时，其转盘会不正常地转动。</li>
<li><strong>电能表产生潜动的原因</strong>：<ul>
<li>有轻微负荷，如配电盘上的指示灯、带灯开关、线路负荷定量器、电压互感器、变压器、电焊机空载运行和功率因数过低等。</li>
<li>潜动试验不合格。一般电能表轻载正、负误差偏大。</li>
<li>没按正相序电源进行电能表接线。</li>
<li>三相电压严重不平衡。</li>
<li>电流互感器匝间短路或存在漏电，电路绝缘破损及电能表电流线圈烧毁等。</li>
</ul>
</li>
</ul>
<h1 id="浪涌试验"><a href="#浪涌试验" class="headerlink" title="浪涌试验"></a>浪涌试验</h1><ul>
<li><strong>定义</strong>：浪涌试验是指在电子设备中注入控制的电压和电流瞬态，模拟实际使用条件下可能发生的过电压和过电流，以评估设备的耐受能力。这些瞬态电压和电流可能由外部因素引起，如雷击、电源开关操作或其他用户的操作。</li>
</ul>
<h1 id="相位角"><a href="#相位角" class="headerlink" title="相位角"></a>相位角</h1><ul>
<li><strong>定义</strong>：某一物理量随时间（或空间位置）作正弦或余弦变化时，决定该量在任一时刻（或位置）状态的一个数值。</li>
</ul>
<h1 id="八种输入输出模式"><a href="#八种输入输出模式" class="headerlink" title="八种输入输出模式"></a>八种输入输出模式</h1><ul>
<li><strong>推挽输出</strong>(Push-Pull Output)：推挽输出模式是最常见的GPIO输出模式。在该模式下，引脚可以输出高电平或低电平，同时具有一定的驱动能力。引脚在输出低电平时形成低阻抗，输出高电平时形成高阻抗，可以驱动外部电路。</li>
<li><strong>开漏输出</strong>(Open-Drain Output)：开漏输出模式是一种能够输出低电平和高阻抗的GPIO模式。在该模式下，引脚只能输出低电平，要输出高电平需要通过外部上拉电阻或其他方式。通常用于与外部器件连接，例如与开漏输出的I2C总线器件进行通信。</li>
<li><strong>复用推挽输出</strong>(AF Push-Pull Output)：复用推挽输出模式允许将GPIO引脚用作特定外设功能。在该模式下，引脚可以输出高电平或低电平，并具有一定的驱动能力。</li>
<li><strong>复用开漏输出</strong>(AF Open-Drain Output)：复用开漏输出模式允许将GPIO引脚用作特定外设功能。在该模式下，引脚只能输出低电平，要输出高电平需要通过外部上拉电阻或其他方式。</li>
<li><strong>浮空输入</strong>(Floating Input)：浮空输入模式是一种高阻抗输入模式。在该模式下，引脚不连接到外部电路，处于高阻抗状态。可以通过读取引脚电平来检测外部信号。</li>
<li><strong>上拉输入</strong>(Pull-up Input)：上拉输入模式是一种具有内部上拉电阻的GPIO输入模式。在该模式下，引脚连接到外部电路，通过内部上拉电阻来维持默认电平为高电平。</li>
<li><strong>下拉输入</strong>(Pull-down Input)：下拉输入模式是一种具有内部下拉电阻的GPIO输入模式。在该模式下，引脚连接到外部电路，通过内部下拉电阻来维持默认电平为低电平。</li>
<li><strong>模拟输入</strong>(Analog Input)：模拟输入模式是一种用于ADC（模数转换器）输入的特殊模式。在该模式下，引脚可以接收连续变化的模拟信号。</li>
</ul>
<h1 id="VCC、VSS和VDD"><a href="#VCC、VSS和VDD" class="headerlink" title="VCC、VSS和VDD"></a>VCC、VSS和VDD</h1><ul>
<li>VCC：供电端电压</li>
<li>VSS：接地端电压（常作为接地点）</li>
<li>VDD：芯片内部工作电压</li>
</ul>
<h1 id="起动电流"><a href="#起动电流" class="headerlink" title="起动电流"></a>起动电流</h1><ul>
<li><strong>定义</strong>：在功率因数为1时，规定的电能表应起动并连续记录电能的最小电流值，多相电能表应带平衡负载。</li>
<li>功率因数为1是指有功功率等于视在功率。</li>
</ul>
<h1 id="最小电流"><a href="#最小电流" class="headerlink" title="最小电流"></a>最小电流</h1><ul>
<li><strong>定义</strong>：复合电能表准确度要求的电流最小值。</li>
<li><strong>代号</strong>：I<sub>min</sub></li>
</ul>
<h1 id="转折电流"><a href="#转折电流" class="headerlink" title="转折电流"></a>转折电流</h1><ul>
<li><strong>定义</strong>：规定的电流值，在大于等于该值时，与电能表准确度等级对应的最大允许误差在最小极限内。</li>
<li><strong>代号</strong>：I<sub>tr</sub></li>
</ul>
<h1 id="最大电流"><a href="#最大电流" class="headerlink" title="最大电流"></a>最大电流</h1><ul>
<li><strong>定义</strong>：规定的电能表持续承载并保持安全且满足准确度要求的电流的最大值。</li>
<li><strong>代号</strong>：I<sub>max</sub></li>
</ul>
<h1 id="标称电压"><a href="#标称电压" class="headerlink" title="标称电压"></a>标称电压</h1><ul>
<li><strong>定义</strong>：确定电能表相关性能所依据的电压值。</li>
<li><strong>代号</strong>：U<sub>nom</sub></li>
</ul>
<h1 id="标称频率"><a href="#标称频率" class="headerlink" title="标称频率"></a>标称频率</h1><ul>
<li><strong>定义</strong>：确定电能表相关性能所依据的频率值。</li>
</ul>
<h1 id="初始固有误差"><a href="#初始固有误差" class="headerlink" title="初始固有误差"></a>初始固有误差</h1><ul>
<li><strong>定义</strong>：在性能试验和耐久性试验之前，在参比条件下测定的电能表误差。</li>
</ul>
<h1 id="基本最大允许误差"><a href="#基本最大允许误差" class="headerlink" title="基本最大允许误差"></a>基本最大允许误差</h1><ul>
<li><strong>定义</strong>：除电流和功率因数在额定工作条件给出的范围内变化外，且电能表工作在参比条件下时，所允许的测量电能表指示的误差的极限值。</li>
</ul>
<h1 id="间谐波"><a href="#间谐波" class="headerlink" title="间谐波"></a>间谐波</h1><ul>
<li><p><strong>定义</strong>：其频率为信号基波频率非整数的信号部分。</p>
</li>
<li><p>由谐波次数扩展，间谐波次数是间谐波频率域基波频率的比值。该比值为非整数。</p>
<ul>
<li><strong>”非整数”的原因</strong>：<ul>
<li><strong>定义</strong>：间谐波（Interharmonics）定义为频率与基波频率的比值为非整数的频率分量。这是间谐波的基本定义，直接说明了其频率与基波频率之间不存在整数倍的关系。</li>
<li><strong>物理特性</strong>：间谐波与基波频率不存在同步关系，其频率分布可能是位于两个谐波频率之间的离散频率分量，也可能是连续频谱。这种非同步和非整数倍的关系使得间谐波具有独特的物理特性。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>间谐波的产生原因</strong>：</p>
<ul>
<li>非线性设备：随着电力电子元件等非线性设备在电力系统中的广泛应用，这些设备在工作过程中会产生非基波频率整数倍的谐波，即间谐波。这些谐波对电网的污染日益严重，是间谐波产生的主要原因之一。</li>
<li>波动负载：许多负载（不论是线性的还是非线性的）是波动的，这导致对于工频的“周期性”前提已不存在。因此，用傅立叶理论分析的结果可能不完全符合实际，从而产生了非整数倍基波频率的间谐波。</li>
<li>主动调制与控制：除了工频电力系统遭遇“外来”客观扰动外，主动调制（包括调幅、调频、调相）和主动控制（如电力电子变流器）也会产生间谐波。这些谐波是基波能量和外加能量综合作用的结果，其频率与基波频率之间不存在固定的整数倍关系。</li>
</ul>
</li>
</ul>
<h1 id="影响量"><a href="#影响量" class="headerlink" title="影响量"></a>影响量</h1><ul>
<li><strong>定义</strong>：电能表外部的、可能影响电能表的功能或计量性能的任一长时间的量。</li>
</ul>
<h1 id="干扰"><a href="#干扰" class="headerlink" title="干扰"></a>干扰</h1><ul>
<li><strong>定义</strong>：电能表外部的、可能影响电能表的功能或计量性能的任一短时间（瞬时）的量。</li>
</ul>
<h1 id="热稳定"><a href="#热稳定" class="headerlink" title="热稳定"></a>热稳定</h1><ul>
<li><strong>定义</strong>：当由热效应引起的误差偏移在20min内按认可的方法所测得的值（根据不同试验所确定的计量值）小于基本最大允许误差的0.1倍时，则可认为仪表达到热稳定。</li>
</ul>
<h1 id="电能表电压工作范围中“扩展的工作范围”"><a href="#电能表电压工作范围中“扩展的工作范围”" class="headerlink" title="电能表电压工作范围中“扩展的工作范围”"></a>电能表电压工作范围中“扩展的工作范围”</h1><ul>
<li><strong>定义</strong>：设备或系统能够正常工作的电压范围，这个范围超出了其标准或规定的工作电压范围，但仍在设备或系统能够安全、稳定运行的极限之内。这种扩展的工作范围设计通常是为了提高设备或系统的灵活性和适应性，以应对不同的工作条件和需求。</li>
</ul>
<h1 id="脉冲常数"><a href="#脉冲常数" class="headerlink" title="脉冲常数"></a>脉冲常数</h1><ul>
<li><p><strong>定义</strong>：，脉冲常数通常用来表征每度电（kWh）所对应的脉冲个数。单位通常为imp&#x2F;kWh（脉冲数&#x2F;千瓦时）或p&#x2F;kWh等。这种表示方式使得电能表能够通过计数脉冲个数来准确计量电能的消耗。</p>
</li>
<li><p><strong>为什么能用脉冲数计算电能消耗</strong>：电能的计量通常是通过记录脉冲信号来完成的。在电能表内部，有电流互感器、电压互感器和A&#x2F;D变换器等模块，这些模块将电能转化为数字信号，并输出脉冲信号给计量器。</p>
</li>
</ul>
<h1 id="传导干扰"><a href="#传导干扰" class="headerlink" title="传导干扰"></a>传导干扰</h1><ul>
<li><strong>定义</strong>：传导干扰是指通过导电介质把一个电网络上的信号耦合到另一个电网络的行为现象。</li>
<li><strong>分类</strong>：传导干扰可以分为共模传导干扰和差模传导干扰两种。共模传导干扰是指信号或干扰源以相同的方式影响多个电路，如共享电源线上的噪声干扰；差模传导干扰则是指信号或干扰源的差异在电路间引起的干扰，如差分信号传输中的干扰。</li>
<li><strong>产生原因</strong>：传导干扰的产生主要源于电子系统中不同电路之间的相互作用。它可以来自其他电子设备、电源线的噪声、开关电路、发射机和无线电频率干扰等。当这些干扰源通过电源线、信号线等物理连接传播到其他电路时，就会产生传导干扰。</li>
</ul>
<h1 id="准确度等级"><a href="#准确度等级" class="headerlink" title="准确度等级"></a>准确度等级</h1><ul>
<li>根据国际标准GB&#x2F;T 17215.321的规定<ul>
<li>A级代表2级</li>
<li>B级代表1级</li>
<li>C级代表0.5级</li>
<li>D级代表0.2级</li>
<li>E级代表0.1级</li>
</ul>
</li>
</ul>
<h1 id="功率因数0-5L和功率因数0-8C"><a href="#功率因数0-5L和功率因数0-8C" class="headerlink" title="功率因数0.5L和功率因数0.8C"></a>功率因数0.5L和功率因数0.8C</h1><ul>
<li><strong>功率因数0.5L</strong><ul>
<li><strong>含义</strong>：功率因数0.5L表示在交流电路中，电流与电压之间的相位差使得它们的余弦值为0.5，并且这个相位差是由于电感（L）引起的。具体来说，0.5表示电流滞后电压60°，即电压与电流的夹角为60度（cos60°&#x3D;0.5），这通常出现在感性电路中，即电压超前于电流60度。</li>
<li><strong>特性</strong>：感性电路的特点是电流滞后于电压，这种相位差导致电流的一部分并不用于产生有功功率（即驱动负载的实际功率），而是产生了无功功率，增加了电网中的能量损耗和负荷。</li>
</ul>
</li>
<li><strong>功率因数0.8C</strong><ul>
<li><strong>含义</strong>：功率因数0.8C表示在交流电路中，电流与电压之间的相位差使得它们的余弦值为0.8，但这个相位差是由于电容（C）引起的。具体来说，这里的“C”并不是直接表示功率因数的值，而是表示电容元件的电容，与“L”表示电感元件的电感相对应。然而，在实际应用中，当我们看到“0.8C”这样的表示时，更可能是指功率因数为0.8且电路呈现出容性特性（即电流超前电压）。但严格来说，“0.8C”并不是标准的功率因数表示方法，更常见的表示方式是直接写为cosφ&#x3D;0.8（容性）。</li>
<li><strong>特性</strong>：容性电路的特点是电流超前于电压，这种相位差同样导致一部分电流不用于产生有功功率，而是产生了无功功率。但与感性电路不同的是，容性电路在某些情况下可以通过与感性电路并联来相互补偿无功功率，从而提高整个电网的功率因数。</li>
</ul>
</li>
</ul>
<h1 id="电压线路和电流线路"><a href="#电压线路和电流线路" class="headerlink" title="电压线路和电流线路"></a>电压线路和电流线路</h1><ul>
<li><strong>电压线路</strong>：<ul>
<li><strong>主要作用</strong>：电压线路是电能表上用于测量电压的部分，也被称为V线。它主要用来测量电路中的电压，确认供电方的用电情况。</li>
<li><strong>实现方式</strong>：电压线路通常通过电压互感器或类似元件将高电压安全地转换为低电压进行测量，以保护测量设备和人员的安全。</li>
</ul>
</li>
<li><strong>电流线路</strong>：<ul>
<li><strong>主要作用</strong>：电流线路是电能表上用于测量电流的部分，也被称为A线。它主要用来测量电路中的电流，判断电路中电器设备的用电情况。</li>
<li><strong>实现方式</strong>：电流线路通常通过电流互感器将大电流转换为小电流进行测量，这种转换不仅降低了测量难度，还提高了测量精度和安全性。</li>
</ul>
</li>
<li><strong>接口位置</strong>：在电表上，电压线路的接口通常是高电压端，而电流线路的接口通常是低电压端。这是因为电流线路需要拥有低内阻，才能测量出准确的电流值；而电压线路则需要阻抗高一些才能将测得的值正常传输至电表中。</li>
<li><strong>测量原理</strong>：电压线路通过测量电压差来测量电路中的电压；而电流线路则通过测量电路中的电流大小来进行测量。</li>
</ul>
<h1 id="继电器"><a href="#继电器" class="headerlink" title="继电器"></a>继电器</h1><ul>
<li><strong>定义</strong>：一种电控制器件，是当输入量（激励量）的变化达到规定要求时，在电气输出电路中使被控量发生预定的阶跃变化的一种电器。它具有控制系统（又称输入回路）和被控制系统（又称输出回路）之间的互动关系。通常应用于自动化的控制电路中，它实际上是用小电流去控制大电流运作的一种“自动开关”。故在电路中起着自动调节、安全保护、转换电路等作用。</li>
<li><strong>工作原理</strong>：当输入量（如电压、电流、温度等）达到规定值时，继电器通过电磁效应、机械传动或声、光、热元件等使输出回路发生阶跃变化（通或断），从而控制或保护被控对象。</li>
<li><strong>分类</strong>：<ul>
<li>根据输入信号的性质可以分为电压继电器、电流继电器、时间继电器、温度继电器、速度继电器、压力继电器等；</li>
<li>根据工作原理可以分为电磁继电器、固体继电器、温度继电器、舌簧继电器、时间继电器、高频继电器等；</li>
<li>根据触点形式可以分为动合型（H型）、动断型（D型）、转换型（Z型）。</li>
</ul>
</li>
<li><strong>主要作用</strong>：<ul>
<li><strong>扩大控制范围</strong>：例如，多触点继电器控制信号达到某一定值时，可以按触点组的不同形式，同时换接、开断、接通多路电路。</li>
<li><strong>放大</strong>：例如，灵敏型继电器、中间继电器等，用一个很微小的控制量，可以控制很大功率的电路。</li>
<li><strong>综合信号</strong>：例如，当多个控制信号按规定的形式输入多绕组继电器时，经过比较综合，达到预定的控制效果。</li>
<li><strong>自动、遥控、监测</strong>：例如，自动装置上的继电器与其他电器一起，可以组成程序控制线路，从而实现自动化运行。</li>
</ul>
</li>
</ul>
<h1 id="电能潮流"><a href="#电能潮流" class="headerlink" title="电能潮流"></a>电能潮流</h1><ul>
<li><strong>定义</strong>：通常称为电力潮流（Power Flow），是电力系统在运行时，电流或功率从电源通过系统各元件流入负荷，分布于电力网各处的现象。</li>
<li><strong>计算</strong>：从电的产生到被负荷消耗，流过哪一路输配电线，各节点电压是多少，这种计算称为电力潮流计算或简称潮流计算。</li>
</ul>
<h1 id="智能电能表"><a href="#智能电能表" class="headerlink" title="智能电能表"></a>智能电能表</h1><ul>
<li><strong>定义</strong>：由测量单元、数据处理单元、通信单元等组成，具有电能量计量、信息存储及处理、实时监测、自动控制和信息交互等功能的电能表。</li>
</ul>
<h1 id="基本电流"><a href="#基本电流" class="headerlink" title="基本电流"></a>基本电流</h1><ul>
<li><strong>定义</strong>：确定直接接入电能表有关特性的电流值，I<sub>b</sub>&#x3D;10I<sub>tr</sub>。</li>
</ul>
<h1 id="额定电流"><a href="#额定电流" class="headerlink" title="额定电流"></a>额定电流</h1><ul>
<li><strong>定义</strong>：确定经互感器接入电能表有关特性的电流值，I<sub>n</sub>&#x3D;20I<sub>tr</sub>。额定电流和基本电流之间并不是2倍关系，二者是相对于<strong>不同电能表</strong>而言的表述，二者转折电流不同，而额定电流是等于基本电流的。这里的额定电流指的是电能表外部有<strong>互感器</strong>的情况。</li>
</ul>
<h1 id="需量"><a href="#需量" class="headerlink" title="需量"></a>需量</h1><ul>
<li><strong>定义</strong>：规定时间内的平均功率。</li>
</ul>
<h1 id="需量周期"><a href="#需量周期" class="headerlink" title="需量周期"></a>需量周期</h1><ul>
<li><strong>定义</strong>：测量平均功率的连续相等的时间间隔。</li>
</ul>
<h1 id="最大需量"><a href="#最大需量" class="headerlink" title="最大需量"></a>最大需量</h1><ul>
<li><strong>定义</strong>：在规定时间段内记录的需量的最大值。</li>
</ul>
<h1 id="滑差时间"><a href="#滑差时间" class="headerlink" title="滑差时间"></a>滑差时间</h1><ul>
<li><strong>定义</strong>：依次递推用来测量最大需量的小于需量周期的时间间隔。</li>
</ul>
<h1 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h1><ul>
<li><strong>定义</strong>：存储特定时刻重要数据的操作。</li>
</ul>
<h1 id="时段"><a href="#时段" class="headerlink" title="时段"></a>时段</h1><ul>
<li><strong>定义</strong>：将一天中的24小时划分成若干时间区段。</li>
</ul>
<h1 id="费率"><a href="#费率" class="headerlink" title="费率"></a>费率</h1><ul>
<li><strong>定义</strong>：与电能消耗时段相对应的计算电费的价格体系。</li>
</ul>
<h1 id="介质"><a href="#介质" class="headerlink" title="介质"></a>介质</h1><ul>
<li><strong>定义</strong>：售电系统和电能表之间以某种方法传递信息的媒体。</li>
<li><strong>分类</strong>：<ul>
<li><strong>固态介质</strong>：具备合理的电气接口，具有特定的封装形式的介质，如接触式IC卡等。</li>
<li><strong>虚拟介质</strong>：采用非固态介质传输信息的介质，可以为电力线载波、无线电、电话或线缆等。</li>
</ul>
</li>
</ul>
<h1 id="CPU卡"><a href="#CPU卡" class="headerlink" title="CPU卡"></a>CPU卡</h1><ul>
<li><strong>定义</strong>：配置有存储器和逻辑控制电路及微处理（MCU）电路，能多次重复使用的接触式IC卡。</li>
</ul>
<h1 id="ESAM"><a href="#ESAM" class="headerlink" title="ESAM"></a>ESAM</h1><ul>
<li><strong>定义</strong>：嵌入在设备内，实现安全存储、数据加&#x2F;解密，双向身份认证、存取权限控制、线路加密传输等安全控制功能的模块。</li>
</ul>
<h1 id="剩余金额"><a href="#剩余金额" class="headerlink" title="剩余金额"></a>剩余金额</h1><ul>
<li><strong>定义</strong>：在电能表中记录的可供用户使用的电费金额，该金额应大于等于零。</li>
</ul>
<h1 id="透支金额"><a href="#透支金额" class="headerlink" title="透支金额"></a>透支金额</h1><ul>
<li><strong>定义</strong>：用户已使用但未缴纳电费的金额值，该值小于零。</li>
</ul>
<h1 id="透支门限金额"><a href="#透支门限金额" class="headerlink" title="透支门限金额"></a>透支门限金额</h1><ul>
<li><strong>定义</strong>：允许用户合法使用的最大透支金额。</li>
</ul>
<h1 id="报警金额"><a href="#报警金额" class="headerlink" title="报警金额"></a>报警金额</h1><ul>
<li><strong>定义</strong>：剩余金额的报警限值，当剩余金额小于等于报警限值时，电能表给出或其他方式报警。</li>
</ul>
<h1 id="负荷开关"><a href="#负荷开关" class="headerlink" title="负荷开关"></a>负荷开关</h1><ul>
<li><strong>定义</strong>：负荷开关是一种用于控制电路中负载（如电气设备、灯具、电动机等）通断的电气开关装置。它通过手动或自动操作实现对电路的控制，具有可靠性高、操作简便、安全可靠等特点，广泛应用于电力系统、工业自动化控制、交通信号控制以及建筑智能化等领域。</li>
<li><strong>分类</strong>：可采用内置和外置方式。</li>
<li><strong>作用</strong>：控制用户用电。</li>
<li>表内的跳闸控制开关宜采用电磁继电器。</li>
</ul>
<h1 id="低压电力线载波"><a href="#低压电力线载波" class="headerlink" title="低压电力线载波"></a>低压电力线载波</h1><ul>
<li><strong>定义</strong>：将低压电力线作为数据&#x2F;信息传输载体的一种通信方式，简称“载波”。</li>
</ul>
<h1 id="公网通信"><a href="#公网通信" class="headerlink" title="公网通信"></a>公网通信</h1><ul>
<li><strong>定义</strong>：采用公网通信信道实现数据传输的通信。</li>
</ul>
<h1 id="阶梯电价"><a href="#阶梯电价" class="headerlink" title="阶梯电价"></a>阶梯电价</h1><ul>
<li><strong>定义</strong>：在一个约定的用电结算周期内，把用电量分为两段或多段，每一分段对应一个单位电价，单位电价在分段内保持不变，但是可随分段不同而变化，针对上述电量制定的单位电价。</li>
</ul>
<h1 id="临界电压"><a href="#临界电压" class="headerlink" title="临界电压"></a>临界电压</h1><ul>
<li><p><strong>定义</strong>：电能表能够启动工作的最低电压。</p>
</li>
<li><p>这里的<strong>启动工作</strong>表示电能表能够正常的计量、显示、记录事件，不强制要求响应背光点亮、通信、跳合闸、报警输出等。</p>
</li>
<li><p>对于<strong>三相电能表</strong>，当<strong>各相电压</strong>均达到标称电压的<strong>60％</strong>时或<strong>单相电压</strong>达到标称电压的<strong>85％</strong>单独工作时，电能表能够启动工作；对于<strong>单相电能表</strong>，当电压达到标称电压的<strong>60％</strong>时，电能表能够启动工作。</p>
</li>
</ul>
<h1 id="电压（电流）不平衡率"><a href="#电压（电流）不平衡率" class="headerlink" title="电压（电流）不平衡率"></a>电压（电流）不平衡率</h1><ul>
<li><strong>定义</strong>：在三相供电系统中，电压（电流）不平衡率为最大相电压（电流）和最小相电压（电流）之差占最大相电压（电流）的百分比。</li>
<li>对于<strong>电压不平衡率</strong>，<strong>三相三线</strong>情况下，用 <strong>U<sub>ab</sub></strong> 和 <strong>U<sub>cb</sub></strong> 参与运算。</li>
<li>对于<strong>电流不平衡率</strong>，<strong>三相三线</strong>情况下，<strong>B相电流</strong>不参与运算。</li>
</ul>
<h1 id="欠压"><a href="#欠压" class="headerlink" title="欠压"></a>欠压</h1><ul>
<li><strong>定义</strong>：在三相（或单相）供电系统中，某相电压大于设定的过压事件电压触发下限，且持续时间大于设定的欠压事件判定延时时间的工况。</li>
<li>当“<strong>过压时间电压触发下限</strong>”设定为“<strong>0</strong>”时，表示“<strong>过压事件</strong>”不启用。</li>
</ul>
<h1 id="过流"><a href="#过流" class="headerlink" title="过流"></a>过流</h1><ul>
<li><p><strong>定义</strong>：在三相（或单相）供电系统中，某相负荷电流大于设定的过流事件电流触发下限，且持续时间大于设定的过流事件判定延时时间的工况。</p>
</li>
<li><p>当“<strong>过流事件触发下限</strong>”设定为“<strong>0</strong>”时，表示“<strong>过流事件</strong>”不启用。</p>
</li>
</ul>
<h1 id="断流"><a href="#断流" class="headerlink" title="断流"></a>断流</h1><ul>
<li><strong>定义</strong>：在三相（或单相）供电系统中，某相电压大于断流事件电压的触发下限，同时该相电流小于设定的断流事件电流触发上限，且持续时间大于设定的断流事件判定延时时间的工况。</li>
<li><strong>三相三线</strong>情况下，电压用 <strong>U<sub>ab</sub></strong> 和 <strong>U<sub>cb</sub></strong> 参与运算，<strong>B相电流</strong>不参与运算。</li>
<li>当“<strong>断流事件电流触发上限</strong>“设定为”<strong>0</strong>“时，表示”<strong>断流事件</strong>“不启用。</li>
</ul>
<h1 id="电压不平衡"><a href="#电压不平衡" class="headerlink" title="电压不平衡"></a>电压不平衡</h1><ul>
<li><strong>定义</strong>：当三相电压中任一相大于电能表的临界电压，电压不平衡率大于设定的电压不平衡率限值，且持续时间大于设定的电压不平衡率判定延时时间的工况。</li>
<li>当“<strong>电压不平衡率限值</strong>”设定为“<strong>0</strong>”时，表示“<strong>电压不平衡事件</strong>”不启用。</li>
</ul>
<h1 id="电流不平衡"><a href="#电流不平衡" class="headerlink" title="电流不平衡"></a>电流不平衡</h1><ul>
<li><strong>定义</strong>：当三相电流中的任一相电流大于5%额定（基本）电流，电流不平衡率大于设定的电流不平衡率限值，且持续时间大于设定的电流不平衡判定延时时间的工况。</li>
<li>当“<strong>电流不平衡率限值</strong>”设定为“<strong>0</strong>”时，表示“<strong>电流不平衡事件</strong>”不启用。</li>
</ul>
<h1 id="电流严重不平衡"><a href="#电流严重不平衡" class="headerlink" title="电流严重不平衡"></a>电流严重不平衡</h1><ul>
<li><strong>定义</strong>：当三相电流中的任一相电流大于5%额定（基本）电流，电流不平衡率大于设定的电流<strong>严重</strong>不平衡率限值，且持续时间大于设定的电流<strong>严重</strong>不平衡判定延时时间的工况。</li>
<li>当“<strong>电流严重不平衡率限值</strong>”设定为“<strong>0</strong>”时，表示“<strong>电流严重不平衡事件</strong>”不启用。</li>
</ul>
<h1 id="功率因数超下限"><a href="#功率因数超下限" class="headerlink" title="功率因数超下限"></a>功率因数超下限</h1><ul>
<li><strong>定义</strong>：在三相（或单相）供电系统中，当总功率因数小于设定的功率因数超下限阈值，同时任意一相电流大于5%额定（基本）电流，或者当某相功率小于设定的功率因数超下限阈值，同时该相电流大于5%额定（基本）电流，且持续时间大于设定的功率因数超下限判定延时时间的工况。</li>
<li><strong>三相三线</strong>情况下，<strong>不判断</strong>分相功率因数超下限。</li>
<li>当“<strong>功率因数超下限阈值</strong>”设定为“<strong>0</strong>”时，表示“<strong>功率因数超下限事件</strong>”不启用。</li>
</ul>
<h1 id="有功功率反向"><a href="#有功功率反向" class="headerlink" title="有功功率反向"></a>有功功率反向</h1><ul>
<li><strong>定义</strong>：在三相供电系统中，当总或任一相有功功率方向为反向，同时该总或任一相有功功率大于设定的有功功率反向事件有功功率触发下限，且持续时间大于设定的有功功率反向事件判定延时时间的工况。</li>
<li>当“<strong>有功功率反向事件有功功率触发下限</strong>”设定为“<strong>0</strong>”时，表示“<strong>有功功率反向事件</strong>”不启用。</li>
<li>三相三电供电系统不要求分相功率反向。</li>
</ul>
<h1 id="过载"><a href="#过载" class="headerlink" title="过载"></a>过载</h1><ul>
<li><strong>定义</strong>：在三相（或单相）供电系统中，某相功率大于设定的过载事件有功功率触发下限，且持续时间大于设定的过载事件判定延时时间的工况。</li>
<li>当“<strong>过载事件有功功率触发下限</strong>”设定为“<strong>0</strong>”时，表示“<strong>过载事件</strong>”不启用。</li>
</ul>
<h1 id="断相"><a href="#断相" class="headerlink" title="断相"></a>断相</h1><ul>
<li><strong>定义</strong>：在三相供电系统中，当某相电压低于设定的断相事件电压触发上限，同时该相电流小于设定的断相事件电流触发上限，且持续时间大于设定的断相事件判定延时时间的工况。</li>
<li><strong>三相三线</strong>情况下，电压用 <strong>U<sub>ab</sub></strong> 和 <strong>U<sub>cb</sub></strong> 参与运算，不判断<strong>B相</strong>断相。</li>
<li>当“<strong>断相事件电压触发上限</strong>”设定为“<strong>0</strong>”时，表示“<strong>断相事件</strong>”不启用。</li>
</ul>
<h1 id="失流"><a href="#失流" class="headerlink" title="失流"></a>失流</h1><ul>
<li><strong>定义</strong>：在三相供电系统中，三相中至少有一相负荷电流大于失流事件电流触发下限，某相电压大于设定的失流事件电压触发下限，同时该相电流小于设定的失流事件电流触发上限值时，且持续时间大于设定的失流事件判定延时时间的工况。</li>
<li><strong>三相三线</strong>情况下，电压用 <strong>U<sub>ab</sub></strong> 和 <strong>U<sub>cb</sub></strong> 参与运算，<strong>B相电流</strong>不参与运算。</li>
<li>当“<strong>失流事件电流触发上限</strong>”设定为“<strong>0</strong>”时，表示“<strong>失流事件</strong>”不启用。</li>
</ul>
<h1 id="失压"><a href="#失压" class="headerlink" title="失压"></a>失压</h1><ul>
<li><strong>定义</strong>：在三相供电系统中，某相电流大于设定的失压事件电流触发下限，同时该相电压低于设定的失压事件电压触发上限，且持续时间大于设定的失压事件判定延时时间的工况。</li>
<li><strong>三相三线</strong>情况下，电压用 <strong>U<sub>ab</sub></strong> 和 <strong>U<sub>cb</sub></strong> 参与运算，不判断<strong>B相</strong>失压。</li>
<li>当“<strong>失压事件电流触发上限</strong>”设定为“<strong>0</strong>”时，表示“<strong>失压事件</strong>”不启用。</li>
</ul>
<h1 id="全失压"><a href="#全失压" class="headerlink" title="全失压"></a>全失压</h1><ul>
<li><strong>定义</strong>：在三相供电系统中，若三相电压均低于电能表的临界电压，且有任一相或多相负荷电流大于 5%额定（基本）电流，且持续时间大于 60s 的工况。</li>
<li>全失压时，不管电能表能否工作，都记录全失压；如果这时电能表还能工作，电压继续降低直到电能表不能工作时，不记录全失压结束，直到电压恢复至电能表启动工作时，再进行全失压事件的判断。</li>
<li>电能表停止工作后，在停止<strong>工作 60s 时</strong>检测且仅<strong>检测电流一次</strong>，进行全失压事件记录的判断，此后不再检测电流。</li>
<li>全失压发生时，分相失压事件记录结束。</li>
</ul>
<h1 id="掉电"><a href="#掉电" class="headerlink" title="掉电"></a>掉电</h1><ul>
<li><strong>定义</strong>：电能表供电电压低于电能表临界电压的工况。</li>
<li>电能表符合掉电工况时，不管电能表能否工作，都记录掉电；如果这时电能表还能工作，电压继续降低直到电能表不能工作时，则不记录掉电结束，等到电压恢复至电能表启动工作时，再进行记掉电事件的判断。</li>
<li>对于三相电能表，掉电工况为三相供电电压均低于电能表临界电压。</li>
<li>当电能表供电电源符合掉电的条件，即使电能表有辅助电源供电，也必须记录掉电状况。</li>
</ul>
<h1 id="电压逆相序事件"><a href="#电压逆相序事件" class="headerlink" title="电压逆相序事件"></a>电压逆相序事件</h1><ul>
<li><strong>定义</strong>：</li>
<li>在三相供电系统中，三相电压均大于电能表的临界电压，三相电压逆相序，且持续时间大于 60s 时记录的事件。</li>
</ul>
<h1 id="电流逆相序事件"><a href="#电流逆相序事件" class="headerlink" title="电流逆相序事件"></a>电流逆相序事件</h1><ul>
<li><strong>定义</strong>：在三相供电系统中，三相电压均大于电能表的临界电压，三相电流均大于 5%额定（基本）电流，三相电流逆相序，且持续时间大于 60s 时记录的事件。</li>
</ul>
<h1 id="有功需量超限"><a href="#有功需量超限" class="headerlink" title="有功需量超限"></a>有功需量超限</h1><ul>
<li><strong>定义</strong>：在三相供电系统中，总有功需量大于设定的有功需量超限事件的需量触发下限，且持续时间大于设定的需量超限事件判定延时时间的工况。</li>
<li>当“<strong>有功需量超限事件需量触发下限</strong>”设定为“<strong>0</strong>”时，表示“<strong>有功需量超限事件</strong>”不启用。</li>
</ul>
<h1 id="无功需量超限"><a href="#无功需量超限" class="headerlink" title="无功需量超限"></a>无功需量超限</h1><ul>
<li><strong>定义</strong>：在三相供电系统中，总无功需量大于设定的无功需量超限事件需量触发下限，且持续时间大于设定的需量超限事件判定延时时间的工况。</li>
<li>当“<strong>无功需量超限事件需量触发下限</strong>”设定为“<strong>0</strong>”时，表示“<strong>无功需量超限事件</strong>”不启用。</li>
</ul>
<h1 id="恒定磁场干扰事件"><a href="#恒定磁场干扰事件" class="headerlink" title="恒定磁场干扰事件"></a>恒定磁场干扰事件</h1><ul>
<li><strong>定义</strong>：三相电能表检测到外部有 100mT 以上强度的恒定磁场，且持续时间大于 5s 时记录的事件。</li>
</ul>
<h1 id="电源异常事件"><a href="#电源异常事件" class="headerlink" title="电源异常事件"></a>电源异常事件</h1><ul>
<li><strong>定义</strong>：电能表的外部供电为电能表正常工作电压范围（0.8U<sub>nom</sub>～1.15U<sub>nom</sub>）时，但电能表内部处理器工作电压异常导致处理器进入到低功耗状态，且持续时间大于 1s 时记录的事件。</li>
<li>内置负荷开关拉闸情况下不要求做此事件记录。</li>
<li>电能表在进入低功耗后记录且仅记录一次电源异常事件。</li>
</ul>
<h1 id="负荷开关误动作事件"><a href="#负荷开关误动作事件" class="headerlink" title="负荷开关误动作事件"></a>负荷开关误动作事件</h1><ul>
<li><strong>定义</strong>：电能表负荷开关实际状态与电能表发给负荷开关的命令状态不一致，且持续 5s 以上时记录的事件。</li>
</ul>
<h1 id="零线电流异常事件"><a href="#零线电流异常事件" class="headerlink" title="零线电流异常事件"></a>零线电流异常事件</h1><ul>
<li><strong>定义</strong>：在三相（或单相）供电系统中，零线电流和火线电流（三相电能表的火线电流为三相电流矢量和）中任一电流大于电流触发下限，零线电流、火线电流的不平衡率大于不平衡率限值，且持续时间大于设定的判定延时时间时记录的事件。</li>
<li>当“<strong>零线电流不平衡限制</strong>”设定为“<strong>0</strong>”时，表示“<strong>零线电流异常事件</strong>”不启用。</li>
<li>直接接入式电能表应采用抗直流采样元件实现零线电流测量及监测，经互感器接入式电能表不要求零线电流测量功能。</li>
<li>零线电流、火线电流的不平衡率为零线电流、火线电流的差值绝对值与零线电流、火线电流中最大值的比例。</li>
</ul>
<h1 id="计量芯片故障事件"><a href="#计量芯片故障事件" class="headerlink" title="计量芯片故障事件"></a>计量芯片故障事件</h1><ul>
<li><strong>定义</strong>：电能表微处理器与电能表的计量芯片通信失败，且持续时间大于设定的判定延时时间时记录的事件。</li>
</ul>
<h1 id="时钟故障事件"><a href="#时钟故障事件" class="headerlink" title="时钟故障事件"></a>时钟故障事件</h1><ul>
<li><strong>定义</strong>：当电能表时钟在运行过程或停上电过程中发生倒退、格式错乱、上电时刻时间小于掉电时间或大于掉电时间1000天等情况时记录的事件。</li>
<li>当电能表收到明文方式广播校时指令时，如果广播校时的校时范围大于最大校时偏差（默认5分钟），电能表不接受校时，同时记录时钟故障事件；每个自然日因为该原因最多只生成一条时钟故障事件记录。</li>
</ul>
<h1 id="“缺省”通信"><a href="#“缺省”通信" class="headerlink" title="“缺省”通信"></a>“缺省”通信</h1><ul>
<li><strong>定义</strong>：在电能表调制型红外接口的缺省通信中，“<strong>缺省</strong>”一词的含义是指系统或设备在出厂时预设的、未经用户修改的<strong>默认</strong>通信参数或设置。这些缺省参数和设置是制造商根据通用标准、设备性能以及用户常见需求而设定的，以确保设备在初次使用时能够正常工作，并与其他兼容设备或系统顺畅通信。</li>
</ul>
<h1 id="调制型红外接口"><a href="#调制型红外接口" class="headerlink" title="调制型红外接口"></a>调制型红外接口</h1><ul>
<li><strong>调制技术</strong>：调制技术是将数据信号（基带信号）与载波信号（高频信号）混合，以产生适合传输的信号的过程。在调制型红外接口中，数据信号被调制到红外光载波上，形成红外光脉冲信号进行传输。</li>
<li><strong>接口特点</strong>：<ul>
<li><strong>通信速率</strong>：调制型红外接口的通信速率通常较高，可以满足多种数据传输需求。具体速率取决于调制技术和接口设计，但一般高于无调制的红外接口。</li>
<li><strong>抗干扰能力强</strong>：由于采用了调制技术，红外光信号在传输过程中能够更好地抵抗环境干扰，如光线、电磁干扰等。</li>
<li><strong>传输距离远</strong>：调制型红外接口通常具有较远的传输距离，适用于需要远距离数据传输的场合。</li>
<li><strong>安全性高</strong>：红外光信号传输具有方向性，且难以穿透障碍物，因此具有较高的安全性。</li>
</ul>
</li>
<li><strong>作用</strong>：这种调制方式可以提高数据传输的抗干扰能力和传输距离。</li>
</ul>
<h1 id="有功总电量、有功尖电量、有功峰电量、有功平电量和有功谷电量"><a href="#有功总电量、有功尖电量、有功峰电量、有功平电量和有功谷电量" class="headerlink" title="有功总电量、有功尖电量、有功峰电量、有功平电量和有功谷电量"></a>有功总电量、有功尖电量、有功峰电量、有功平电量和有功谷电量</h1><ul>
<li>在电力系统中，为了更合理地分配电力资源、制定电价以及进行电力需求管理，通常会根据用电负荷的不同时间段来划分电量，这就是所谓的分时电量。具体来说，有功总电量是指一段时间内（如一个月）用户消耗的总电量，而不区分时间段。而有功尖电量、有功峰电量、有功平电量和有功谷电量则是根据用电负荷的高低来划分的。</li>
<li><strong>有功尖电量</strong>：这通常指的是在一天中用电负荷最高的时段（即尖峰时段）内消耗的电量。尖峰时段一般出现在白天的工作高峰，此时电力需求最大，电网负荷最重。尖峰电量的价格通常也是最高的，以鼓励用户在非高峰时段用电。</li>
<li><strong>有功峰电量</strong>：峰电量是指在一天中用电负荷相对较高的时段（即峰时段）内消耗的电量。峰时段虽然不如尖峰时段负荷高，但仍然属于用电高峰，因此峰电量的价格也会相应较高。</li>
<li><strong>有功平电量</strong>：平电量则是指在一天中用电负荷相对平稳的时段（即平时段）内消耗的电量。这个时段的电力需求较为稳定，电价也相对较低。</li>
<li><strong>有功谷电量</strong>：谷电量是指在一天中用电负荷最低的时段（即谷时段）内消耗的电量。谷时段一般出现在深夜至清晨，此时电力需求最低，电网负荷最轻。为了鼓励用户在谷时段用电，谷电量的价格通常是最低的。</li>
</ul>
<h1 id="数字地和模拟地"><a href="#数字地和模拟地" class="headerlink" title="数字地和模拟地"></a>数字地和模拟地</h1><ul>
<li><strong>数字地</strong>：数字地是数字信号的对地，主要是指TTL或CMOS芯片、I&#x2F;O接口芯片、CPU芯片等数字逻辑电路的地端，以及A&#x2F;D、D&#x2F;A转换器的数字地。它也可以理解为各种开关量信号的零电位，是数字电压信号的基准端。数字地也被称为逻辑地，在一个完整的微机控制系统中，通常存在多种类型的地，如低电平电路地线、强电设备的地、机壳或控制柜的外壳地等。</li>
<li><strong>模拟地</strong>：模拟地是模拟信号的对地，主要指放大器、采样-保持器和A&#x2F;D、D&#x2F;A中模拟信号的接地端。在微型机控制系统中，数字地和模拟地必须分别接地，即使一个芯片上同时包含数字和模拟两种地（如A&#x2F;D、D&#x2F;A或S&#x2F;H），也需要分别接地，并在一点处将两者连接起来。</li>
</ul>
<h1 id="接口带载能力"><a href="#接口带载能力" class="headerlink" title="接口带载能力"></a>接口带载能力</h1><ul>
<li><strong>定义</strong>：接口带载能力是指接口在外接负载后，其输出电压或电流的大小能否保持稳定，且不受外接负载变化影响的能力。简单来说，就是接口能否有效地驱动和支撑外部负载工作。</li>
</ul>
<h1 id="非激励态输出电压和激励态输出电压"><a href="#非激励态输出电压和激励态输出电压" class="headerlink" title="非激励态输出电压和激励态输出电压"></a>非激励态输出电压和激励态输出电压</h1><ul>
<li><strong>非激励态输出电压</strong>：非激励态输出电压是指当控制信号处于非激励（或称非激活、非工作）状态时，电路系统输出的电压值。</li>
<li><strong>激励态输出电压</strong>：激励态输出电压是指当控制信号处于激励（或称激活、工作）状态时，电路系统输出的电压值。</li>
</ul>
<h1 id="II类绝缘防护"><a href="#II类绝缘防护" class="headerlink" title="II类绝缘防护"></a>II类绝缘防护</h1><ul>
<li><strong>定义</strong>：电能表采用双重绝缘或加强绝缘作为主要的防电击措施。这种防护方式不依赖设备的外壳接地或安装条件，而是通过增加绝缘层的数量和厚度来提高电气安全性。</li>
<li><strong>实现方式</strong>：<ul>
<li><strong>双重绝缘</strong>：<ul>
<li>电能表的内部电路与外部可触及部分之间设置两层绝缘层。</li>
<li>这两层绝缘层各自独立，即使一层绝缘失效，另一层绝缘仍然能够提供保护。</li>
</ul>
</li>
<li><strong>加强绝缘</strong>：<ul>
<li>在某些情况下，可能采用单一但更厚的绝缘层，即加强绝缘。</li>
<li>这种绝缘层具有更高的电气强度和耐电压能力，以确保在异常情况下也不会发生电击危险。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="带热拔插操作"><a href="#带热拔插操作" class="headerlink" title="带热拔插操作"></a>带热拔插操作</h1><ul>
<li><strong>定义</strong>：热插拔操作通常指的是在设备带电的情况下进行插拔操作。</li>
</ul>
<h1 id="驻留时间"><a href="#驻留时间" class="headerlink" title="驻留时间"></a>驻留时间</h1><ul>
<li><strong>定义</strong>：规定频率下影响量施加的持续时间。</li>
</ul>
<h1 id="步进频率"><a href="#步进频率" class="headerlink" title="步进频率"></a>步进频率</h1><ul>
<li><strong>定义</strong>：试验中以固定的步长在一定范围不断变化的频率。</li>
</ul>
<h1 id="扫频测试"><a href="#扫频测试" class="headerlink" title="扫频测试"></a>扫频测试</h1><ul>
<li><strong>定义</strong>：扫频测试是一种通过改变测试信号的频率，观察被测设备在不同频率下的响应特性的测试方法。</li>
</ul>
<h1 id="电能寄存器"><a href="#电能寄存器" class="headerlink" title="电能寄存器"></a>电能寄存器</h1><ul>
<li><strong>定义</strong>：电能寄存器是电能计量中不可或缺的重要组件，它通过记录电能数据为电费计算、电力负荷分析、电力供需平衡等方面提供重要依据。</li>
<li><strong>分类</strong>：<ul>
<li><strong>正向有功电能寄存器</strong>：用于记录用户从电网中获取的电能，即用户用电的总电能值。</li>
<li><strong>反向有功电能寄存器</strong>：用于记录用户向电网输出的电能值，这在一些特殊情况下（如分布式发电系统）会发生。</li>
<li><strong>正向无功电能寄存器</strong>：用于记录用户从电网中获取的无功电能。无功电能是电网中用于建立和维护电磁场的能量，虽然不直接转化为有用功，但对电网的稳定运行至关重要。</li>
<li><strong>反向无功电能寄存器</strong>：记录用户向电网输出的无功电能。</li>
</ul>
</li>
</ul>
<h1 id="共模与差模"><a href="#共模与差模" class="headerlink" title="共模与差模"></a>共模与差模</h1><ul>
<li><strong>共模</strong>：<ul>
<li>也称对地噪声，是指信号线与参考点（通常为大地或机架）之间的电压差。</li>
<li>在电路中，共模信号表现为两个信号端点（或导线）对同一参考点（如地）有相同的电位变化或噪声。</li>
<li>例如，当平衡线对中引入到两个平衡端的噪声电压，或者由于信号源与接收器之间的地电位差而产生的直流电平，都属于共模信号。</li>
</ul>
</li>
<li><strong>差模</strong>：<ul>
<li>也称串模，是指两个信号线之间的电压差。</li>
<li>在电路中，差模信号表现为两个信号端点（或导线）之间的电位差，这种电位差是信号本身所携带的，用于传输有效信息。</li>
<li>差模信号由一个正向信号和一个反向信号组成，它们在导线上以相等但相反的幅度传输。</li>
</ul>
</li>
<li><strong>共模信号</strong>：<ul>
<li>两个信号的幅度相等、相位相同。</li>
<li>共模噪声对信号的传输具有干扰作用，容易导致信号失真和传输质量下降。</li>
<li>衡量共模抑制能力的参数称为共模抑制比（CMRR），它反映了差分放大器对共模信号的抑制能力。</li>
</ul>
</li>
<li><strong>差模信号</strong>：<ul>
<li>两个信号的幅度相等、相位相反。</li>
<li>差模信号的特点是其幅度大于单个信号的幅度，并且可以有效抵消外部干扰。</li>
<li>差模传输主要用于提高信号质量和增强信号传输能力。</li>
</ul>
</li>
</ul>
<h1 id="四象限"><a href="#四象限" class="headerlink" title="四象限"></a>四象限</h1><ul>
<li><strong>定义</strong>：电能表计量中的四象限是将一个平面坐标系的横轴定义为无功功率（Q），纵轴定义为有功功率（P），通过这两个轴将平面划分为四个区域，即四个象限。这四个象限按顺时针方向依次为Ⅰ象限、Ⅱ象限、Ⅲ象限和Ⅳ象限。</li>
<li><strong>Ⅰ象限</strong>：<ul>
<li><strong>定义</strong>：输入有功功率和输入无功功率（即P&gt;0，Q&gt;0）。</li>
<li><strong>特点</strong>：通常发生在用户设备为感性负载（如电动机）的情况下，电流滞后于电压。电网需要向用户设备提供有功功率和无功功率，以维持设备的正常运行。</li>
<li><strong>应用场景</strong>：大多数用户的正常用电状态都属于Ⅰ象限。</li>
</ul>
</li>
<li><strong>Ⅱ象限</strong>：<ul>
<li><strong>定义</strong>：输出有功功率和输入无功功率（即P&lt;0，Q&gt;0）。</li>
<li><strong>特点</strong>：通常发生在用户设备相当于一台欠励磁发电机的情况下。用户设备向电网输出有功功率，但同时还需要从电网中吸收无功功率，以维持设备的稳定运行。</li>
<li><strong>应用场景</strong>：某些具有自发电能力的用户（如小型水电站、风力发电站等）在发电不足或负荷过大时，可能会处于Ⅱ象限状态。</li>
</ul>
</li>
<li><strong>Ⅲ象限</strong>：<ul>
<li><strong>定义</strong>：输出有功功率和输出无功功率（即P&lt;0，Q&lt;0）。</li>
<li><strong>特点</strong>：通常发生在用户设备相当于一台过励磁发电机的情况下。用户设备不仅向电网输出有功功率，还向电网输出无功功率，这有助于改善电网的功率因数，提高电网的效率。</li>
<li><strong>应用场景</strong>：某些具有强大自发电能力的用户（如大型水电站、核电站等）在发电过剩或负荷较小时，可能会处于Ⅲ象限状态。</li>
</ul>
</li>
<li><strong>Ⅳ象限</strong>：<ul>
<li><strong>定义</strong>：输入有功功率和输出无功功率（即P&gt;0，Q&lt;0）。</li>
<li><strong>特点</strong>：通常发生在用户设备为容性负载（如电容器组）的情况下，电流超前于电压。电网需要向用户设备提供有功功率，但用户设备会向电网输出无功功率，这有助于减少电网中的无功功率流动，提高电网的稳定性。</li>
<li><strong>应用场景</strong>：电力系统中的无功补偿装置（如并联电容器组）在投入运行时，可能会使系统处于Ⅳ象限状态。</li>
</ul>
</li>
</ul>
<h1 id="电磁兼容、电磁干扰和电磁抗扰度"><a href="#电磁兼容、电磁干扰和电磁抗扰度" class="headerlink" title="电磁兼容、电磁干扰和电磁抗扰度"></a>电磁兼容、电磁干扰和电磁抗扰度</h1><ul>
<li><strong>电磁兼容（EMC）</strong>：电子、电气设备或系统在电子、电气设备或系统在预期的电磁环境中，按设计要求正常工作的能力。它是电子、电气设备或系统的一种重要的技术性能。<ul>
<li><strong>电磁干扰（EMI）</strong>：在一定环境中设备或系统在正常工作时，不应产生超过相应标准所要求的电磁能量，相对应的测试项目根据产品类型及标准不同而不同。</li>
<li><strong>电磁抗扰度（EMS）</strong>：在一定环境中设备或系统，在正常运行时，设备或系统能承受相应标准规定范围内的电磁能量干扰，相对应的测试项目也根据产品类型及标准不同而不同。</li>
<li><strong>电磁环境</strong>：系统或设备的工作环境。</li>
</ul>
</li>
</ul>
<h1 id="开漏输出"><a href="#开漏输出" class="headerlink" title="开漏输出"></a>开漏输出</h1><ul>
<li><p><strong>定义</strong>：开漏输出引脚是由单个晶体管（通常是N沟道MOSFET或NPN三极管）驱动的，它将引脚拉到只有一个电压（通常是地）。当输出设备关闭时，引脚被悬空（开放或高阻）。</p>
</li>
<li><p><strong>原理</strong>：以N沟道MOSFET为例，当MOSFET打开时，将信号拉到地（低电平）；当MOSFET关闭时，引脚则保持开放状态，此时引脚的电平状态由外部电路决定，通常需要一个上拉电阻将引脚拉至高电平。</p>
</li>
<li><p><strong>应用场景</strong></p>
<ul>
<li><p><strong>总线通信</strong>：如I2C、SMBus等总线标准采用开漏输出方式，以支持多设备共享总线和实现电平匹配。</p>
</li>
<li><p><strong>电平转换</strong>：在需要实现不同电平之间转换的场合，开漏输出可以通过外接不同电压的上拉电阻来实现。</p>
</li>
<li><p><strong>驱动LED</strong>：虽然开漏输出通常需要外接上拉电阻才能输出高电平，但在驱动LED等简单负载时仍然有其应用空间。</p>
</li>
</ul>
</li>
</ul>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><ul>
<li><strong>定义</strong>：数据链路层定义了在单个链路上如何传输数据，这些协议与被讨论的各种介质（如ATM、FDDI等）有关。数据链路层通过物理线路（物理链路）加上实现通信协议的硬件和软件，构成逻辑上的数据链路。</li>
<li><strong>功能</strong>：<ul>
<li>封装成帧</li>
<li>差错控制</li>
<li>流量控制</li>
<li>链路管理</li>
<li>MAC寻址</li>
<li>区别数据和控制信息</li>
<li>透明传输</li>
</ul>
</li>
</ul>
<h1 id="面向对象的用电信息数据交换协议"><a href="#面向对象的用电信息数据交换协议" class="headerlink" title="面向对象的用电信息数据交换协议"></a>面向对象的用电信息数据交换协议</h1><ul>
<li><strong>定义</strong>：基于面向对象的建模方法建立的一套使用于用电采集系统的互操作性数据交换通信协议。面对对象建模以接口类实现继承关系，以对象来封装数据及操作，以对象为互操作的基本要素。</li>
</ul>
<h1 id="对象标识"><a href="#对象标识" class="headerlink" title="对象标识"></a>对象标识</h1><ul>
<li><strong>定义</strong>：标识终端中对象唯一名称的编码。</li>
</ul>
<h1 id="逻辑名"><a href="#逻辑名" class="headerlink" title="逻辑名"></a>逻辑名</h1><ul>
<li><strong>定义</strong>：用于标识接口类的实例，它是接口类的第一个属性，它的值与对象标识一致。</li>
</ul>
<h1 id="类标识码"><a href="#类标识码" class="headerlink" title="类标识码"></a>类标识码</h1><ul>
<li><strong>定义</strong>：用于区别对象接口类的标识码，即接口类的名称。</li>
</ul>
<h1 id="服务器地址"><a href="#服务器地址" class="headerlink" title="服务器地址"></a>服务器地址</h1><ul>
<li><strong>定义</strong>：客户机&#x2F;服务器访问模型中的服务器的通信地址。</li>
</ul>
<h1 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h1><ul>
<li><strong>定义</strong>：服务器模型中逻辑设备的地址。</li>
</ul>
<h1 id="客户机地址"><a href="#客户机地址" class="headerlink" title="客户机地址"></a>客户机地址</h1><ul>
<li><strong>定义</strong>：客户机&#x2F;服务器访问模型中的客户机的通信地址。</li>
</ul>
<h1 id="采集启动时标"><a href="#采集启动时标" class="headerlink" title="采集启动时标"></a>采集启动时标</h1><ul>
<li><strong>定义</strong>：启动采集任务时的设备时钟当前值，其值只与启动时刻有关，与执行时间的长短无关。</li>
</ul>
<h1 id="采集成功时标"><a href="#采集成功时标" class="headerlink" title="采集成功时标"></a>采集成功时标</h1><ul>
<li><strong>定义</strong>：客户机成功接收到服务器响应时的设备时钟的当前值。</li>
</ul>
<h1 id="采集存储时标"><a href="#采集存储时标" class="headerlink" title="采集存储时标"></a>采集存储时标</h1><ul>
<li><strong>定义</strong>：采集到的数据进行存储的时间。</li>
</ul>
<h1 id="组地址"><a href="#组地址" class="headerlink" title="组地址"></a>组地址</h1><ul>
<li><strong>定义</strong>：具有某一相同属性的设备群组编码，如属于同一行业，同一变电站，同一线路，可以响应同一个命令。</li>
</ul>
<h1 id="通配地址"><a href="#通配地址" class="headerlink" title="通配地址"></a>通配地址</h1><ul>
<li><strong>定义</strong>：在十进制编码表示的地址码中出现了一位或多位采用了通配符的地址码。</li>
</ul>
<h1 id="消息鉴别码"><a href="#消息鉴别码" class="headerlink" title="消息鉴别码"></a>消息鉴别码</h1><ul>
<li><strong>定义</strong>：用于鉴别消息完整性的固定长度的认证标识。</li>
</ul>
<h1 id="透传"><a href="#透传" class="headerlink" title="透传"></a>透传</h1><ul>
<li><strong>定义</strong>：改变信号传递的形式而不改变信号传递的内容。</li>
</ul>
<h1 id="光伏越限"><a href="#光伏越限" class="headerlink" title="光伏越限"></a>光伏越限</h1><ul>
<li><strong>定义</strong>：主要是指光伏电站或分布式光伏发电系统在运行过程中，其电压、功率因数等参数超出了规定的范围或限制。</li>
</ul>
]]></content>
      <categories>
        <category>电力电子</category>
      </categories>
  </entry>
  <entry>
    <title>电力电子常见元器件</title>
    <url>/2024/07/12/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E5%B8%B8%E8%A7%81%E5%85%83%E5%99%A8%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="电阻"><a href="#电阻" class="headerlink" title="电阻"></a>电阻</h1><ul>
<li><p><strong>代号</strong>：R</p>
</li>
<li><p><strong>单位</strong>：欧姆（Ω）、千欧（KΩ）、兆欧（MΩ）等。</p>
</li>
<li><p><strong>作用</strong>：分流、限流、分压、降压、隔离和偏置等。</p>
<ul>
<li><strong>隔离</strong>：电阻的隔离作用并非传统意义上的物理隔离，而是通过电阻的特性（如分压、限流、阻抗匹配等）来实现电路信号或功能的某种隔离效果。具体来说，电阻在电路中可以防止不同部分之间的直接相互影响，确保信号的稳定传输和电路的正常工作。</li>
<li><strong>偏置</strong>：电阻的偏置作用主要体现在为电路中的电子元件（如晶体管、场效应管等）提供稳定的工作点电压或电流。通过设置合适的偏置电阻，可以确保电子元件在正常工作范围内进行操作，从而提高电路的稳定性和可靠性。</li>
</ul>
</li>
<li><p><strong>热敏电阻</strong>（RT）：分为正温度系数热敏电阻（PTC）和负温度系数热敏电阻（NTC）。</p>
</li>
<li><p><strong>光敏电阻</strong>（RL）：又称为光导管，在特定波长的光照射下，其阻值迅速变小。</p>
</li>
<li><p><strong>压敏电阻</strong>（RPS）：具有非线性伏安特性并有抑制瞬态过电压作用的固态电压敏感元件。当端电压低于某一阈值时，压敏电阻器的电流几乎等于零；超过此阈值时，电流值随端电压的增大而急剧增加。</p>
</li>
<li><p><strong>电位器</strong>（W或RP）：阻值可以调整的电阻。分为旋转式、直滑式和带开关式。</p>
</li>
<li><p><strong>好坏判别</strong>：用万用表电阻挡测得实际阻值与标称值一致或在允许误差范围内为好。(烧坏一般变黑色)。在路测量实际阻值≤标称值。</p>
</li>
</ul>
<h1 id="电容"><a href="#电容" class="headerlink" title="电容"></a>电容</h1><ul>
<li><p><strong>代号</strong>：C</p>
</li>
<li><p><strong>单位</strong>：法拉（F）、豪法（mF）、微法（uF）、钠法（nF）、皮法（pF）。</p>
</li>
<li><p><strong>特性</strong>：隔直流电通交流电</p>
</li>
<li><p><strong>作用</strong>：隔直、耦合、旁路、滤波、调谐回路和能量转换控制电路等方面。</p>
<ul>
<li><p><strong>耦合</strong>：电容耦合是一种利用分布电容进行信号传递的耦合方式，也被称为电场耦合或静电耦合。其主要作用体现在以下几个方面：</p>
<ul>
<li><strong>隔离强电和弱电系统</strong>：电容耦合可以隔离强电和弱电系统，确保弱电系统免受强电系统的干扰。</li>
<li><strong>提供高频信号通路</strong>：电容对高频信号的阻抗较小，因此能够提供高频信号的有效传输通路。</li>
<li><strong>阻止工频电流进入弱电系统</strong>：通过电容的耦合作用，可以阻止工频电流进入弱电系统，保护弱电系统的稳定运行。</li>
<li><strong>提高电路稳定性</strong>：在电子电路中，电容耦合常用于放大电路，以防止信号间的干扰，提高电路的整体稳定性。例如，在三极管放大电路中，电容耦合用于隔离前后级信号，防止直流偏置对放大电路的影响，同时实现交流信号的传输。</li>
</ul>
</li>
<li><p><strong>旁路</strong>：旁路电容是指在电路中并联一个电容器，以提供一条低阻抗的通道，将高频信号绕过某个电路元件。其主要作用包括：</p>
<ul>
<li><strong>滤波</strong>：旁路电容可以用来滤除电路中的高频噪声信号。在大多数电路中，电源线上会存在一些高频噪声，旁路电容可以将这些噪声引至地线，从而保持信号的净度。此外，旁路电容还可以平滑脉冲信号，将一个脉冲信号转换为一个连续的直流信号，提供更加稳定的电压。</li>
<li><strong>耦合</strong>：虽然旁路电容的主要作用不是耦合，但在某些情况下，它也可以用来实现不同电路之间的耦合。例如，在音频放大器中，旁路电容可以用来将输入和输出之间的直流偏置隔开，从而实现交流信号的传输。</li>
<li><strong>数据存储</strong>：由于电容器能够在充电和放电之间存储电荷，因此旁路电容也可以用来实现短期的数据存储。通过控制充放电过程，可以存储和读取数据。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>相关名词</strong></p>
<ul>
<li><strong>耐压</strong>：表示容器在长期工作过程中能接受的最高电压值</li>
<li><strong>容量</strong>：容量的大小就是表示能贮存电能的大小；电容对交流信号的阻碍作用称为容抗，它与交流信号的频率和电容量有关。</li>
</ul>
</li>
<li><p><strong>容量识别方法</strong>：</p>
<ul>
<li>容量大的电容其容量值在电容上直接表明</li>
<li>容量小的电容其容量值在电容上用字母表示或数字表示<ul>
<li>字母表示法：1m &#x3D; 1000uf；1P2 &#x3D; 1.2PF；1n &#x3D; 1000PF</li>
<li>数字表示法：<ul>
<li>示为小数的或标示为一位或两位整数的，标示数就是容量值；<ul>
<li>标为小数的，容量单位为uF；</li>
<li>标为整数的，容量单位为pF；</li>
</ul>
</li>
<li>用三位数字表示容量大小，前两位表示有效数字，第三位数字是倍率（或补几个“0”个数）。如：<ul>
<li>102表示10x10<sup>2</sup>PF &#x3D; 1000PF</li>
<li>224表示22x104PF &#x3D; 220000PF</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>好坏判别</strong>：两极短路放电后，用万用表电阻挡测，表针摆出后能返回到原处为好;表针摆出后不返回为短路;表针摆出后返回不到原处为好漏电;表针不摆出为开路;短路、开路、漏电严重为损坏。对于小电容，测量表针不摆动，再用串联“电笔法”或“交流信号法” 判定好坏。</p>
</li>
</ul>
<h1 id="电感"><a href="#电感" class="headerlink" title="电感"></a>电感</h1><ul>
<li><p><strong>代号</strong>：L</p>
</li>
<li><p><strong>别称</strong>：扼流器、电抗器、动态电抗器</p>
</li>
<li><p>在电路中常用“L”加数字表示，如：L6表示编号为6的电感。</p>
</li>
<li><p><strong>特性</strong>：通直流电阻交流电。 直流可通过线圈，直流电阻就是导线本身的电阻，压降很小;当交流信号通过线圈时，线圈两端将会产生自感电动势，自感电动势的方向与外加电压的方向相反，阻碍交流的通过，交流电频率越高，线圈阻抗越大。</p>
</li>
<li><p><strong>作用</strong>：滤波、升压、谐振、分频等。在电路中可与电容组成串、并联振荡电路。</p>
<ul>
<li><strong>谐振</strong>：电感的谐振作用主要体现在与电容器并联或串联构成的谐振电路中。谐振电路是一种能够选择特定频率信号进行放大或抑制的电路。</li>
<li><strong>分频</strong>：电感的分频作用通常与铁磁谐振现象相关，特别是在含有非线性电感（如铁心电感）的电路中更为显著。铁磁谐振是指在铁心电感元件中，由非线性电感和电容组成的电路在一定条件下产生的谐振现象。<strong>分频谐振</strong>是铁磁谐振的一种表现形式，指在某些特定的电路中，由于电容器和电感器之间的相互作用，使得电流和电压的频率变为原始频率的整数分之一时发生的谐振现象。</li>
</ul>
</li>
<li><p><strong>单位</strong>：亨（H）、毫亨（mH）、微亨（uH）</p>
</li>
<li><p><strong>好坏判别</strong>：用万用表电阻挡测有一定阻值不开、短路为好。(烧坏一般变黑色)。</p>
</li>
</ul>
<h1 id="电源变压器"><a href="#电源变压器" class="headerlink" title="电源变压器"></a>电源变压器</h1><ul>
<li><strong>代号</strong>：B</li>
<li>初级次级电压和线圈圈数之间的关系：式中N称为电压比（圈数比）。当N&lt;1时，则N1&gt;N2，V1&gt;V2，该变压器为降压变压器，反之则为升压变压器。</li>
<li><strong>绕制公式</strong>： N1&#x2F; N2 &#x3D;V1&#x2F; V2<ul>
<li>V1：输入电压；V2：与输出电压；N1：一级线圈匝数≥1000匝；N2：次级线圈匝数。</li>
<li>变压器线圈匝数越多，电磁感应越明显(输入电压V1&#x3D;220V或380V）。</li>
<li>次级线圈N2根据输出电压V2的需要决定匝数)。</li>
<li>输出功率与输入功率在理想变压器是一样的：P&#x3D;IU(一般输出功率只有70—90%)。</li>
</ul>
</li>
</ul>
<h1 id="脉冲变压器"><a href="#脉冲变压器" class="headerlink" title="脉冲变压器"></a>脉冲变压器</h1><ul>
<li>脉冲变压器是变压器一种特殊类型，它所变换的不是正弦电压，也不是交流方波，而是接近矩形的单极性脉冲。</li>
<li>脉冲变压器广泛应用于各种开关电源中。脉冲变压器一般是做脉冲高频信号耦合、阻抗变换、电压变换之用，指标要求比一般工频变压器高，铁芯常用高导磁铁合金或铁氧体，绕制要求比较严格。</li>
</ul>
<h1 id="扬声器"><a href="#扬声器" class="headerlink" title="扬声器"></a>扬声器</h1><ul>
<li><strong>代号</strong>：Y</li>
<li><strong>分类</strong>：<ul>
<li>按工作频率分低音、中音、高音；</li>
<li>按音圈阻抗分低阻抗和高阻抗、内磁式外磁式等。</li>
</ul>
</li>
<li><strong>好坏判别</strong>：用万用表R×1Ω挡或1.5V干电池，一边不断碰触两接线柱，能发出“喀喀”声。检测扬声器是粗略的，以听声音来主观评价它的质量好坏。</li>
<li>扬声器有两个接线柱（两根引线），当单只扬声器使用时两根引脚不分正负极性，多只扬声器同时使用时两个引脚有极性之分。</li>
<li><strong>额定功率</strong> <ul>
<li>单位：W或AV</li>
<li>扬声器的功率有标称功率和最大功率之分。标称功率称额定功率、不失真功率。</li>
</ul>
</li>
<li><strong>额定阻抗</strong><ul>
<li>单位：Ω</li>
<li>阻抗一般和频率有关。额定阻抗是指音频为400Hz时，从扬声器输入端测得的阻抗。它一般是音圈直流电阻的1.2~1.5倍。常见的阻抗有4Ω、8Ω、16Ω、32Ω等。</li>
</ul>
</li>
</ul>
<h1 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h1><ul>
<li><p><strong>代号</strong>：D或BG</p>
</li>
<li><p>由一个PN结构成。分正负极，P为正极，N为负极；</p>
</li>
<li><p><strong>分类</strong>：普通、稳压、变容、发光、开关和光电二极管。</p>
<ul>
<li><strong>变容二极管</strong>：又称“可变电抗二极管”，是一种特殊的半导体器件，其<strong>电容量</strong>可以随外加电压的变化而变化。<strong>二极管电容量</strong>是指二极管PN结之间的电容量。</li>
<li><strong>光电二极管</strong>：也被称为光敏二极管，是一种能够将光信号转换为电信号的半导体器件。</li>
</ul>
</li>
<li><p><strong>作用</strong>：整流、稳压、变容、发光（LED）、升压、开关等作用。</p>
</li>
<li><p><strong>好坏判别</strong>：用万用表R×1K挡对换表笔测，正向阻值3—9K，反向阻值∞(无穷大)为好。</p>
</li>
<li><p><strong>电极判别</strong>：用万用表R×1K挡对换表笔测，正向阻值3—9K时，黑表笔接的一端为正极，相反一端为负极。“小黑正”(注：从外观上看标有黑或白色的一端为负极)。</p>
</li>
<li><p><strong>特性</strong>：单相导电（电流只能从正极流向负极，反向不导电）。</p>
</li>
<li><p><strong>稳压二极管</strong>：起稳压作用;稳压管的负极接正电压，正极接负电压(和普通的二极管接法相反)，当加在稳压二极管的反向电压增加到大于稳压值时，稳压管就导通，形成一个反向电流，把负极电压限制在稳压值上。</p>
</li>
<li><p><strong>发光二极管</strong>：半导体二极管的一种，可以把电能转化成光能；代号LED；也具有单向导电性，反向击穿电压约5伏，使用时必须串联限流电阻以控制通过管子的电流。限流电阻R可用下式计算： R&#x3D;(E-UF)&#x2F;IF 式中E为电源电压，UF为LED的正向压降，IF为LED的一般工作电流。LED使用低压电源，供电电压在6-24V之间，消耗能量较同光效的白炽灯减少80%;使用10万小时后，光衰为初始的50%。</p>
</li>
<li><p><strong>光电二极管</strong>：和普通二极管一样，也是由一个PN结组成的半导体器件，也具有单方向导电特性。但在电路中它不是作整流元件，而是把光信号转换成电信号的光电传感器件。</p>
</li>
<li><p><strong>双向触发二极管</strong>：具有对称性的二端半导体器件。常用来触发双向可控硅 ，在电路中作过压保护定时、移相、调速、调光等用途。测量双向触发二极管正、反向电阻值。正常时其正、反向电阻值均应为无穷大。若测得正、反向电阻值均很小或为0，则说明该二极管已击穿损坏。</p>
</li>
</ul>
<h1 id="单相可控硅"><a href="#单相可控硅" class="headerlink" title="单相可控硅"></a>单相可控硅</h1><ul>
<li><strong>代号</strong>：BCR</li>
<li><strong>定义</strong>：一种半导体元器件，又称晶体闸流管，单向可控硅是由三个PN结PNPN组成的四层三端半导体器件与具有一个PN结的二极管相比，单向可控硅正向导通受控制极电流控制;可控硅对控制极电流没有放大作用。</li>
<li><strong>好坏判别</strong>：用万用表R×1K挡对换表笔测AK、AG正反向阻值均为∞，测GK正向阻值3—9K，反向阻值∞为好管。</li>
<li><strong>电极判别</strong>：用万用表R×1K挡对换表笔测GK，正向阻值3—9K时，黑表笔接的一端为G(控制)极，红表笔接的一端为K(阴极)极，另一端为A(阳极)极。</li>
<li><strong>作用</strong>：整流、稳压、开关等作用。</li>
<li><strong>工作原理</strong>：<ul>
<li>可控硅的导通条件：一是可控硅阳极与阴极间必须加正向电压，二是控制极也要加正向电压。以上两个条件，必须同时具备，可控硅才会处于导通状态。可控硅一旦导通后，即使降低控制极电压或去掉控制极电压，可控硅仍然导通。</li>
<li>可控硅关断条件：降低或去掉加在可控硅阳极至阴极之间的正向电压，使阳极电流小于最小维持电流以下。</li>
</ul>
</li>
</ul>
<h1 id="双向可控硅"><a href="#双向可控硅" class="headerlink" title="双向可控硅"></a>双向可控硅</h1><ul>
<li><strong>代号</strong>：SCR</li>
<li>双向可控硅具有两个方向轮流导通、关断的特性。双向可控硅实质上是两个反并联的单向可控硅，是由NPNPN五层半导体形成四个PN结构成、有三个电极的半导体器件。</li>
<li>由于主电极的构造是对称的(都从N层引出)，所以它的电极不像单向可控硅那样分别叫阳极和阴极，而是把与控制极相近的叫做第一电极A1，另一个叫做第二电极A2。</li>
<li>双向可控硅的主要缺点是承受电压上升率的能力较低。这是因为双向可控硅在一个方向导通结束时，硅片在各层中的载流子还没有回到截止状态的位置，必须采取相应的保护措施。</li>
<li><strong>电极和好坏判别</strong>：用万用表R×1挡或R×10挡对换表笔测T2、T1或T2、G极正、反阻值指针均不动;用万用表R×1挡或R×10挡对换表笔测T1和G极正、反向阻值均为几十至几百欧，其中必有一次阻值稍大，则稍大的一次红笔接的为G极，黑笔所接为T1极，余下是T2极。</li>
<li><strong>作用</strong>：交流控制电路，如温度控制、灯光控制、防爆交流开关和交流电机调速、换向、交流稳压等电路。</li>
</ul>
<h1 id="三极管"><a href="#三极管" class="headerlink" title="三极管"></a>三极管</h1><ul>
<li><p><strong>代号</strong>：BG或Q、V和T</p>
</li>
<li><p><strong>定义</strong>：一种电流控制型器件半导体元器件，又称晶体管;它由两个PN结构成，有三个电极，分别称基极(B)称集电极称(C)发射极(E);按导电类型分有PNP型和NPN型两种管;</p>
</li>
<li><p><strong>分类</strong>：按功率分有大、中、小功率三种管；按用途分有高、低频两种管。</p>
</li>
<li><p>晶体三极管的电流放大系数随温度升高而增大，在实际电路中，主要应用了放大电路和开关电路，是一种小电流控制大电流的放大元件。</p>
</li>
<li><p><strong>作用</strong>：放大(电压电流)、稳压、开关、振荡等作用。</p>
</li>
<li><p><strong>基极判别</strong>：用万用表R×1KΩ挡一支表笔固定某一极，另一支表笔去测另外两极，测量得两次阻值都比较小(3—9K)时，固定表笔接的脚就是基极。</p>
</li>
<li><p><strong>型号判别</strong>：根据测量得基极时固定表笔的颜色，若测量得基极时固定表笔的颜色为红表笔，则该管为PNP型;若测量得基极时固定表笔的颜色为黑表笔，则该管为NPN型。</p>
</li>
<li><p><strong>发射判别</strong>：用万用表R×10KΩ挡对换表笔去测另外两极，以测量得次阻值小的一次为准(30K以上);PNP型管红表笔接的脚就是E极“小红发”;NPN型管黑表笔接的脚就是E极“小黑发”;另一管脚为C极。</p>
</li>
<li><p><strong>好坏判别</strong>：</p>
<ul>
<li>用万用表R×1KΩ挡对换表笔测称B—C和B—E极，正向阻值3—9K，反向阻值∞(无穷大);</li>
<li>用万用表R×10K挡对换表笔测称C—E极，正向阻值30K以上，反向阻值∞(无穷大);</li>
<li>达以上两个条件为好管。</li>
</ul>
</li>
<li><p><strong>带阻尼型管好坏判别</strong>：</p>
<ul>
<li>用万用表R×1Ω或R×10Ω挡对换表笔测称B—E极，正向阻值均为十几至几十欧;</li>
<li>用万用表R×1K挡对换表笔测称C—E极，正向阻值3—9K反向阻值∞(无穷大);</li>
<li>达以上两个条件为好管。</li>
</ul>
</li>
<li><p><strong>放大能力测量</strong>：用万用表R×10KΩ挡;PNP管红表笔接C极，黑表笔接E极;NPN管黑表笔接C极，红表笔接E极;用手指接通B与C极时，表针摆动幅度越大说明该项管放大能力越好。表针无摆动为无放大能力已损坏。</p>
</li>
<li><p><strong>三极管的三种工作状态</strong></p>
<ul>
<li>放大状态：三极管的BE极加正向电压时，在正偏状态(BE极之间电压为0.5-0.7V)这时集电极与发射极之间的电流大小受基极控制，三极管处于放大(导通)状态。</li>
<li>饱和(导通)状态：三极管的BE极加正向电压时，在超正偏状态(BE极之间电压大于0.7V以上)这时集电极与发射极之间的电阻很小，就像开关闭合一样，三极管处于饱和(导通)状态。</li>
<li>截止状态：三极管的发射极加反向电压或两断电压为零时,这时集电极与发射极之间的电阻很大，就像开关断开一样，三极管处于截止(不导通)状态;(Vb ≤Ve)。</li>
</ul>
</li>
<li><p><strong>放大电路</strong>：当基极(输入端)输入一个较小的基极电流时，其集电极(输出端)将按比例产生一个较大的集电极电流，这个比例就是三极管的电流放大系数。(VC &gt;Vb &gt; Ve)</p>
<ul>
<li>放大作用的理解：三极管不会产生能量，但它可以通过小电流控制大电流;放大的原理就在于：通过小的变化的交流输入，控制大的静态直流起较大的相应的变化</li>
</ul>
</li>
<li><p><strong>开关电路</strong>：三极管在电路中通常用做电子开关。在开关状态下的三极管处于饱和(导通)状态和截止状态。</p>
</li>
<li><p><strong>三极管放大工作状态下各电极电压电流的变化关系</strong>：</p>
<ul>
<li>对于NPN型管：Vb↑–Ib↑–Ic↑–Vc↓–Ie↑–Ve↑;Vb↓–Ib↓–Ic↓–Vc↑–Ie↓–Ve↓</li>
<li>对于PNP型管：Vb↑–Ib↓–Ic↓–Ve↑–Ic↓–Vc↓;Vb↓–Ib↑–Ic↑–Ve↓–Ic↑–Vc↑</li>
<li>注：基极电压Vb;基极电流Ib;集电极电流Ic;集电极电压Vc;发射极电流Ie;发射极电压Ve;上升、增大↑;下降、变小↓</li>
</ul>
</li>
</ul>
<h1 id="光耦元件"><a href="#光耦元件" class="headerlink" title="光耦元件"></a>光耦元件</h1><ul>
<li><strong>代号</strong>：OC</li>
<li><strong>定义</strong>：光耦隔离就是采用光耦合器进行隔离,光耦合器的结构相当于把发光二极管和光敏(三极)管封装在一起。发光二极管把输入的电信号转换为光信号传给光敏管转换为电信号输出，由于没有直接的电气连接，这样既耦合传输了信号，又有隔离作用。</li>
</ul>
<h1 id="三端稳压器"><a href="#三端稳压器" class="headerlink" title="三端稳压器"></a>三端稳压器</h1><ul>
<li><strong>三端稳压器件</strong>：如78xx、79xx 系列三端稳压器件是最常用的线性降压型DC&#x2F;DC 转换器。单独的元件可用万用表测量各脚间电阻来粗略判别是否损坏，最好是接入电路中测量; 78系列输出是正压;79系列输出是负压。万用表测量其输出电压就可以判断其好坏了。</li>
<li><strong>用途</strong>：用于电路的稳压.输出固定电压，以防止电压过高烧毁电路。</li>
<li><strong>类别</strong>：三端稳压器的通用产品有78系列(正电源)和79系列(负电源)，输出电压由具体型号中的后面两个数字代表;有5V，6V，8V，9V，10V，12V，15V，18V，24V等档次;输出电流以78(或79)后面加字母来区分L表示0.1;AM表示0.5A，无字母表示1.5A，如78L05表求5V 0.1A。</li>
<li><strong>使用注意事项</strong>：(VI)和(Vo)之间的关系，输入&#x2F;输出之间要有2-3V及以上的电压差。例:7805 该三端稳压器的固定输出电压是5V，而输入电压至少大于7V。</li>
<li>79系列7905，-5V，引脚：1—地、2—进、3—出；78系列7805，+5V，引脚：1—进、2—地、3—出。</li>
</ul>
<h1 id="集成电路"><a href="#集成电路" class="headerlink" title="集成电路"></a>集成电路</h1><ul>
<li><strong>代号</strong>：IC</li>
<li><strong>定义</strong>：集成电路是一种微型电子器件或部件。采用一定的工艺，把一个电路中所需的晶体管、二极管、电阻、电容和电感等元件及布线互连一起，制作在一小块或几小块半导体晶片或介质基片上，然后封装在一个管壳内，成为具有所需电路功能的微型结构;其中所有元件在结构上已组成一个整体。</li>
<li><strong>分类</strong>：按其功能、结构的不同，可以分为模拟集成电路、数字集成电路和数&#x2F;模混合集成电路三大类。</li>
<li>芯片命名方式非常多，一般都是 字母+数字+字母：前面的字母是芯片厂商或是某个芯片系列的缩写。中间的数字是功能型号。如：MC7805和LM7805，从7805上可以看出它们的功能都是输出5V，只是厂家不一样。后面的字母多半是封装信息，要看厂商提供的资料才能知道具体字母代表什么封。引脚排列：有单列引脚、双列引脚、四列引脚，引脚读数从有“.”标示处读起或放正型号数字对正自己，从下排脚读起。</li>
</ul>
<h1 id="继电器"><a href="#继电器" class="headerlink" title="继电器"></a>继电器</h1><ul>
<li><strong>代号</strong>：J</li>
<li><strong>定义</strong>：电磁继电器KV是一种电子控制器件，一般由电磁铁、衔铁、弹簧片、触点等组成;它具有控制系统(又称输入回路)和被控制系统(又称输出回路)，通常应用于自动控制电路中，它实际上是用较小的电流，较低的电压去控制较大电流，较高的电压的一种电磁效应“自动开关”。故在电路中起着自动调节、安全保护、转换电路等作用。</li>
<li>继电器的“常开、常闭”触点，可以这样来<strong>区分</strong>：继电器线圈未通电时处于断开状态的静触点，称为“常开触点”;处于接通状态的静触点称为“常闭触点”。用万用表电阻档测一下，有阻值的脚是线圈。</li>
</ul>
<h1 id="电流互感器"><a href="#电流互感器" class="headerlink" title="电流互感器"></a>电流互感器</h1><ul>
<li><strong>代号</strong>：CT</li>
<li><strong>定义</strong>：电力系统中一种重要的测量设备，用于测量高电流并将其转换成适宜进行计量和保护的低电流信号。</li>
<li><strong>工作原理</strong>：电流互感器基于电磁感应原理工作。它由闭合的铁心和绕阻组成，包括一次绕组和二次绕组。一次绕组匝数很少，串在需要测量的电流的线路中；二次绕组匝数比较多，串接在测量仪表和保护回路中。当一次绕组中有电流流过时，会在铁心中产生交变磁通，进而在二次绕组中感应出相应的电流。</li>
<li><strong>主要作用</strong>：<ul>
<li><strong>电流测量</strong>：电流互感器能够将高电流转换为低电流输出，以满足计量和监测的要求。这对于电力系统的负荷管理、故障诊断和电能计量非常重要。</li>
<li><strong>电流保护</strong>：通过测量电流互感器的输出信号，可以实时监测电路中的电流情况。当电流超过预设的阈值时，电流保护装置会触发，采取相应的措施来避免电路的过载和短路，保护电力设备和系统安全。</li>
<li><strong>电流控制</strong>：电流互感器还可用于控制和调节电力系统中的电流，确保系统的稳定性、优化能源利用和提高工作效率。</li>
</ul>
</li>
<li><strong>类型</strong>：<ul>
<li><strong>环形电流互感器</strong>：最常见的类型，由环形的铁芯和绕组组成，体积小、重量轻、安装方便，常用于低压电力系统、电能计量和智能电网等领域。</li>
<li><strong>柱形电流互感器</strong>：由柱形的铁芯和绕组组成，具有高精度和较大的额定电流范围，适用于中高压电力系统、变电站和发电机等场合。</li>
<li><strong>分合式电流互感器</strong>：采用可分离的结构，可以在不中断电路的情况下安装或移除，广泛应用于高压电力系统、故障录波和保护装置等领域。</li>
<li><strong>封闭式电流互感器</strong>：在绝缘容器中封装，具有良好的绝缘性能和防护能力，适用于高湿度、污染或易燃环境下的应用。</li>
<li><strong>智能电流互感器</strong>：常用于智能电网、物联网和远程监测等应用，提供更高级别的数据处理和管理能力。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>电力电子</category>
      </categories>
  </entry>
  <entry>
    <title>界面挂载通用代码</title>
    <url>/2022/06/15/C++%E5%AD%A6%E4%B9%A0/MFC%E5%AD%A6%E4%B9%A0/%E7%95%8C%E9%9D%A2%E6%8C%82%E8%BD%BD%E9%80%9A%E7%94%A8%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>在MFC框架下将CInfoDlg界面挂载到主页面</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Context.m_pNewViewClass = <span class="built_in">RUNTIME_CLASS</span>(CInfoDlg);</span><br><span class="line"></span><br><span class="line">Context.m_pCurrentFrame = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">Context.m_pLastView = (CFormView *)m_spliter.<span class="built_in">GetPane</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">m_spliter.<span class="built_in">DeleteView</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">m_spliter.<span class="built_in">CreateView</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">RUNTIME_CLASS</span>(CInfoDlg), <span class="built_in">CSize</span>(<span class="number">600</span>, <span class="number">0</span>), &amp;Context);</span><br><span class="line"></span><br><span class="line">CInfoDlg *pNewView = (CInfoDlg *)m_spliter.<span class="built_in">GetPane</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">m_spliter.<span class="built_in">RecalcLayout</span>();</span><br><span class="line"></span><br><span class="line">pNewView-&gt;<span class="built_in">OnInitialUpdate</span>();</span><br><span class="line"></span><br><span class="line">m_spliter.<span class="built_in">SetActivePane</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>MFC</category>
      </categories>
  </entry>
  <entry>
    <title>CString和String类型转换</title>
    <url>/2022/06/27/C++%E5%AD%A6%E4%B9%A0/MFC%E5%AD%A6%E4%B9%A0/MFC%E4%B8%ADCString%E5%92%8CString%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>将String类型的sring1转换为CSting类型的cstring1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CStringA str;</span><br><span class="line"></span><br><span class="line">str1 =string1;</span><br><span class="line"></span><br><span class="line">cstring1 = str1.<span class="built_in">GetBuffer</span>();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>MFC</category>
      </categories>
  </entry>
</search>
